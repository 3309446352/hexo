---
title: HTML八股文
date: 2024-03-18 17:27:43
CATEGORYS: 前端
tags:
  - 前端
categories: 前端
cover: https://raw.githubusercontent.com/3309446352/Images/main/img/屏幕截图(1).png
feature: true
---
# 1、HTML

![1709997145390](https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg)

## 1.你对 HTML 语义化的理解？★★★★★

1. html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、[搜索引擎](https://so.csdn.net/so/search?q=搜索引擎&spm=1001.2101.3001.7020)解析；即使在没有样式 CSS 情况下也以    一种文档格式显示，并且是容易阅读的;
2. 搜索引擎的[爬虫](https://so.csdn.net/so/search?q=爬虫&spm=1001.2101.3001.7020)也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;

## 2、 title 与 alt 属性的区别是什么？

1. alt 是给搜索引擎识别，在图像无法显示时的替代文本；
2. title 是关于元素的注释信息，主要是给用户解读。
3. 当鼠标放到文字或是图片上时有 title 文字显示。（因为 IE 不标准）在 IE 浏览器中 alt 起到了 title 的作用，变成文字提示。

## 3、href 与 src？

> href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。（目的不是为了引用资源，而是为了建立联系，让当前标签能够链接到目标地址。）
> src source（缩写），指向外部资源的位置，指向的内容将会应用到文档中当前标签所在位置。
> href与src的区别
> 1、请求资源类型不同：href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；
> 2、作用结果不同：href 用于在当前文档和引用资源之间确立联系；src 用于替换当前内容；
> 3、浏览器解析方式不同：当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。

src和href都是对外部资源的引用，区别如下：

src: 表示对资源的引用，用在js脚本、img、frame等元素上，当浏览器解析到该元素时，会**暂停**其他资源的下载和处理，直到该资源加载、编译、执行完成，所以js脚本会放在页面的底部，而不是头部。

href：表示超文本引用，指向一些网络资源，当浏览器识别它指向的文件时，就会**并行**下载资源，不会停止对当前文件的处理，用在a、link上

## 4、HTML5、CSS3 里面都新增了那些新特性？

HTML5

- [ ]  新的语义标签
  article 独立的内容。
  aside 侧边栏。
  header 头部。
  nav 导航。
  section 文档中的节。
  footer 页脚。
  画布(Canvas) API
  地理(Geolocation) API
  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
  sessionStorage 的数据在浏览器关闭后自动删除
  新的技术webworker, websocket, Geolocation
  拖拽释放(Drag and drop) API
  音频、视频API(audio,video)
  表单控件，calendar、date、time、email、url、searc
  CSS3

- 2d，3d变换
  Transition, animation
  媒体查询
  新的单位（rem, vw，vh 等）
  圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜
  rgba

## 5、行内元素与块级元素

### 块级元素： 独占一行，可以设置宽高，设置margin和padding都有效，代表如下：

div、p、h1…h6、table、tr、ol、li、ul

### 行内元素元素： 可以排成一行，设置宽高无效，对margin设置左右方向有效，而上下无效，padding设置都无效，代表如下：

基本上都是文本标签

span、img、b、strong、font、br、a

## 什么是BFC?

BFC全称是Block Formatting Context，意思就是块级格式化上下文。你可以把BFC看做一个容器，容器里边的元素不会影响到容器外部的元素。

BFC有什么特性？
BFC是一个块级元素，块级元素在垂直方向上依次排列。

BFC是一个独立的容器，内部元素不会影响容器外部的元素。

属于同一个BFC的两个盒子，外边距margin会发生重叠，并且取最大外边距。

[[面试官：什么是BFC？BFC有什么特性？如何创建BFC？BFC有什么作用？-CSDN博客](https://blog.csdn.net/guoao20000915/article/details/125685983?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170929193616777224499886%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170929193616777224499886&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125685983-null-null.142^v99^pc_search_result_base2&utm_term=bfc&spm=1018.2226.3001.4187)](https://)

解决当父级元素没有高度时，子级元素浮动会使父级元素高度塌陷的问题

解决子级元素外边距会使父级元素塌陷的问题

# 2、CSS

## 1、介绍一下 CSS 的盒子模型？★★★★★

有两种， IE 盒子模型、W3C 盒子模型；
盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；
区 别： IE 的 content 部分把 border 和 padding 计算了进去;

## 2、css 选择器优先级？★★★★★

!important > 行内样式（比重1000）> ID 选择器（比重100） > 类选择器（比重10） > 标签（比重1） > 通配符 > 继承 > 浏览器默认属性

## 3、垂直居中几种方式？★★★★★

单行文本: line-height = height
图片: vertical-align: middle;
absolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);
flex: display:flex;margin

- 1 使用flex布局
  利用flex的alignItems:center垂直居中，justifycontent:center水平居中
- 2 利用相对定位和绝对定位的margin:auto
- 相对定位下，使用绝对定位将上下左右都设置为0，再设置margin:auto即可实现居中
- 3 利用相对定位和绝对定位，再加上外边距和平移的配合
  相对定位下，使用绝对定位，利用margin偏移外容器的50%，再利用translate平移回补自身宽高的50%即可
- 4 利用textAlign和verticalAlign
  利用textAlign:center实现行内元素的水平居中，再利用verticalAlign:middle实现行内元素的垂直居中，前提是要先加上伪元素并给设置高度为100%，用过elementUI的可以去看看其消息弹窗居中实现方式就是如此

**四种方式：**

**利用绝对定位**，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。

```css
.div {
        position: absolute;
        width: 200px;height: 200px;
         left: 50%;top: 50%;
        transform: translate(-50%, -50%);
        或//margin-left:-50px;margin-top:-50px;
      }
```

**利用绝对定位**，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于盒子有宽高的情况。

```css
.div {
        position: relative;
        width: 200px;height: 200px;
        left: 50%; top: 50%;
       transfrom:trable(-50%,-50%)
      }
```

使用**flex布局****，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。

```
.div {
       // width: 100%; //height: 100%;
        display: flex;
        justify-content: center;
        align-items:center;
      }
```

## 4.flex布局的父级元素中有哪些常用属性。

答：

flex-direction: 设置主轴的方向

justify-content: 设置主轴上的子元素对齐方式

flex-wrap: 设置子元素是否换行

align-content: 设置侧轴上的子元素的排列方式(多行)

align-items:  设置侧轴上的子元素排列方式 (单行)

flex-flow: 复合属性, 相当于同时设置了 flex-direction 和 flex-wrap

## 5、var、let、const 区别？★★★★★

var 存在变量提升。
let 只能在块级作用域内访问。
const 用来定义常量，必须初始化，不能修改（对象特殊）

var 全局作用域 变量更新 重新声明 可以变量提升(**将var变量放到第一行**)

let 块作用域  变量更新 不能重新声明

const 块作用域  不能变量更新 不能重新声明

var 初始化为undefined

## 6、1rem、1em、1vh、1px各自代表的含义？

rem
rem是全部的长度都相对于根元素元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。
em
子元素字体大小的em是相对于父元素字体大小
元素的width/height/padding/margin用em的话是相对于该元素的font-size
vw/vh
全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。
px
px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。
一般电脑的分辨率有{19201024}等不同的分辨率
19201024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素

## 7、怎么解决浮动中塌陷的问题

### 第一种：开启BFC

根据W3C的标准，在页面中元素都有一个隐含的属性 Block Formatting Context,简称BFC，默认是关闭的；

开启元素BFC后，元素将会具有以下特性：

父元素的垂直外边距不会和子元素重叠
开启BFC的元素不会被浮动元素所覆盖
开启BFC的元素可以包含浮动元素
开启BFC的方法：。

** overflow【常见，副作用最小】**

overflow设置为非visible的值。推荐使用hidden（副作用最小）

a) auto （溢出显示滚动条）

b) scroll （默认就显示滚动条）

c) hidden （溢出隐藏）[常用]

注：但在IE6及以下的浏览器中不支持BFC，所以使用这种方式不兼容IE6。在IE6中有类似BFC的隐含属性 hasLayout，开启方式很多，推荐使用zoom:1

### 第二种：在浮动元素后添加元素，并设置其clear属性

### 第三种：br元素的clear属性

br元素本身没有高度，所以也就不会存在IE低版本下最小高度问题。只需要在浮动元素下添加一句 :

※第四种：after伪类【各大公司推荐】

可以通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动，和第二种方法原理相同，可达到相同的效果，而且不会在页面中添加多余的div，这是最推荐的方式，几乎没有副作用

## 8、display:none和visibility:hidden的区别？

display:none：     隐藏元素,不占空间 继承属性

visibility:hidden：隐藏元素,不占空间 继承属性

> display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。
> visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。

## 9、position的值， relative和absolute分别是相对于谁进行定位的？

relative:相对定位，相对于自己本身在正常文档流中的位置进行定位。
absolute:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。
fixed: （老版本IE不支持）生成绝对定位，相对于浏览器窗口或者frame进行定位。
static:默认值，没有定位，元素出现在正常的文档流中。
sticky:生成粘性定位的元素，容器的位置根据正常文档流计算得出。

10、

## 10、画一条0.5px的直线？

> 考查的是css3的transform

```
height: 1px;
transform: scale(0.5);
```

## 11、BFC 是什么？

BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。
可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。
只要元素满足下面任一条件即可触发 BFC 特性

body 根元素
浮动元素：float 除 none 以外的值
绝对定位元素：position (absolute、fixed)
display 为 inline-block、table-cells、flex
overflow 除了 visible 以外的值 (hidden、auto、scroll)

## 8、前端常见的布局方式

### 一、静态布局

静态布局是最为原始的布局方式，没有什么技术性可言，往往是计算机行业刚刚入门的小白使用的布局方式。制作的网页上的元素尺寸一律以px为单位

布局特点： 页面上的布局是按最初写代码时候的布局方式进行布局的，常规的pc网站是进行设置了宽度值进行布局的，不会随着pc端的屏幕的大小而变化。
优点: 这种布局方式不管是对资深的前端开发工程师还是刚入门的小白来说都是最简单的，最让人容易以接受、学习的，没有我们所说的兼容性的问题。这种布局方式大多用在门户网站和企业的官网上，这些官网的设备的尺寸是固定的，这种布局方式往往是最简单的方法。
缺点： 不会随着pc端的屏幕大小而变化。

### 二、弹性布局（flexbox）

弹性布局可以简便、完整、响应的实现各种页面上的布局。与静态不同的是，使用em或rem单位（lem=16px，1rem=10px）进行相对布局，相对使用百分比更加方便、灵活，相应同时支持浏览器的字体大小调整和缩放的等正常显示。
优点：
1.适应性强，在做多种不同的屏幕分辨率不同的界面是非常使用。
2.随意按照宽度、比例划分元素的宽高。
3.可以轻松的改变元素的显示顺序。
4.网页布局实现快捷，维护起来更加容易。
如果做移动端时，如果客户对细微的之处的要求不高，使用弹性布局进行制作是最好的选择，一份css+一份js调节font-size搞定。
缺点： 浏览器兼容性较差，只能兼容到IE9及以上。

### 三、自适应布局（bootstrap）

自适应布局分别为不同屏幕不同分辨率定义布局，即是创建多个静态页面，每个静态页面对应一个屏幕分辨率的一个范围内。在改变不同的屏幕分辨率可以切换到不同的静态布局上，但是布局中的元素位置会发生改变，但是在每个静态布局中，页面中的元素不会随着窗口大小的调整发生变化。使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。
优点：
1.对网站的复杂程度兼容性更大；
2.对开发工程师来说制作的成本代价更低；
3.代码执行效果更高效；
4.测试时更加容易，运营相对更加精准。
缺点： 在现如今的移动端设计百花齐放的时期之下，同一个网站往往需要为不同的设备制作不同的页面，不但会增加开发成本，还会因为客户的需求改变时，可能会改动多套代码、流程相比较来说较繁琐。

### 四、流式布局（fluid）

流式布局的布局方式是页面的元素的宽度按照屏幕的分辨率进行适配的调整，但是整体布局不变，也称之为栅栏系统。使用%百分比定义宽度，高度大都是用px来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。
缺点： 屏幕大小变化时，页面元素也随之变化但是布局不变。这就会因为如果屏幕太大或太小都会布局时元素无法正常显示。

### 五、响应式布局

响应式布局是css3增加的新布局方式，该布局方式2010年提出来的一个概念，说白了就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。响应式几乎成为优秀页面布局的标准。
设计方法： 媒体查询+流式布局。通常使用@media媒体查询，和网格系统配合相对布局单位进行布局，实际上说白了就是综合响应式等技术通过css给单一网页不同设备分辨率返回不式时的技术。
优点： 适应pc端和移动端，如果有足够的耐心，页面效果会很完美。
缺点：
1.只能适应主流的宽高；
2.如果匹配足够多的设备屏幕的大小，对于工程师来说工作量不小，设计更需要多个版本，工作量增大。

### 六、浮动布局

浮动布局进行调用浮动属性改变页面中元素的位置，浮动布局应该是目前各大网站用的最多的一种布局方式了，但是也特别复杂。浮动元素是脱离文档流的，但不脱离文本流。浮动元素有左浮动（float : left）和右浮动（float : right）两种

优点： 兼容性比较好
缺点： 浮动带来的影响比较多，页面宽度不够的时候会影响布局。

### 七、定位布局

定位布局时利用position属性控制页面元素设置一些不规则布局。

# 3、js

## 什么是async？

async 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用 await 来表示异步。相较于 Generator，async 函数的改进在于下面四点：

内置执行器。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，调用方式跟普通函数的调用一样
更好的语义。async 和 await 相较于 * 和 yield 更加语义化
更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise对象。而 async 函数的 await 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）
返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用

## await是什么？

await意思是async wait(异步等待)。这个关键字只能在使用async定义的函数里面使用。任何async函数都会默认返回promise，并且这个promise解析的值都将会是这个函数的返回值，而async函数必须等到内部所有的 await 命令的 Promise 对象执行完，才会发生状态改变。

打个比方，await是学生，async是校车，必须等人齐了再开车。

就是说，必须等所有await 函数执行完毕后，才会告诉promise我成功了还是失败了，执行then或者catch

## 19、var,let ,const 三者区别？

共同点：都是可以声明变量

区别1：var具有变量提升的机制，let和const 没有变量提升机制，

区别2：var可以多次声明同一个变量，let和const 不可以多次声明同一个变量，

区别3：var和let声明的是常量，const声明常量，var和let声明的变量可以再一次赋值，而const 不可以再次赋值

面试的时候会问const 一个对象，里面是a:1，我现在想打印console.log(obj.a)这个结果是1，我想改变a:2,打印的就是2因为里面的值不是const,从内存的角度看，一个对象里面修改了对量里面的属性值，那么再次打印会打印出新的值，

什么是常量：常量是一个在程序执行过程中不能被改变或修改的固定值。它是被赋予一个固定值后就不能再改变的变量。理解成，不能被操作所修改的变量就是常量。用途：保护数据，可以提高程序的可读性、可维护性

变量：变量是用于存储和表示数据的一种命名容器。它是程序中的一个基本概念，用于在内存中存储和操作数据。变量的值可以被修改和更新。

区别4：var没有作用域，在ES6之后才出现的作用域块的概念，

### null 和 undefined 区别

首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型
分别都只有一个值，就是 undefined 和 null。
undefined 代表的含义是未定义，null 代表的含义是空对象。一般
变量声明了但还没有定义的时候会返回 undefined，null 主要用于
赋值给一些可能会返回对象的变量，作为初始化。

### 作用域链

在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个
变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域
查找，依次向上级作用域查找，直到访问到 window 对象就被终止，
这一层层的关系就是作用域链

### **1、深拷贝、浅拷贝（笔试题）★★★★★**

【{},[]】

- 浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个**地址**，修改时原对象也会受到影响
  - Object.assign
  - 展开运算符 ...
- 深拷贝: 完全拷贝一个新**对象**，修改时原对象不再受到任何影响

## 2、作用域、作用域链

作用域：变量和函数起作用的范围。

作用域链：是js查找方式，决定的变量和函数向上查找的范围。

作用域是可访问的变量的
集合。在JavaScript中，作用域为可访问变量，对象，函数的集合，它分为局部作用域和全局作用域。作用域决定了这些变量的可访问性（可见性）。

作用域链

我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含
父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。

它由两部分组成:
[[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO
AO: 自身活动对象
如此 [[scope]]包含[[scope]]，便自上而下形成一条 链式作用域。

## 1、闭包★★★★★

### 1、变量作用域

```
要理解闭包，首先要理解 JavasSript 的特殊的变量作用域。
```

```
变量的作用域无非就两种：全局变量和局部变量。
```

```
JavasSript 语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局                    部变量。
```

**注意点：**在函数内部声明变量的时候，一定要使用 var 命令。如果不用的话，你实际上声明的是一个全局变量！

### 2、如何从外部读取函数内部的局部变量？

出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。

那就是在函数内部，再定义一个函数。

```js
function f1(){
    var n=999;
    function f2(){
        alert(n); // 999
    }
}
```

在上面的代码中，函数 f2 就被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。

这就是 JavasSript 语言特有的"链式作用域"结构（chain scope）

### 3、闭包的概念

上面代码中的 f2 函数，就是闭包。

各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。

由于在 JavaScript 中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成"定义在一个函数内部的函数"。

所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数

使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。

闭包有三个特性：

1.函数嵌套函数

2.函数内部可以引用外部的参数和变量

3.参数和变量不会被垃圾回收机制回收

### 4、闭包的用途

闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在 f1 调用后被自动清除。

为什么会这样呢？原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

这段代码中另一个值得注意的地方，就是 “nAdd=function(){n+=1}” 这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量。其次，nAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。

* 使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。
* 闭包有三个特性：
* 函数嵌套函数
* 函数内部可以引用外部的参数和变量
* 参数和变量不会被垃圾回收机制回收

应用场景：

* 设置私有变量的方法
* 不适用场景：返回闭包的函数是个非常大的函数
  闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏

### 5、使用闭包的注意点

（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值

## 2、 原型链★★★★★

那什么是原型链呢？

简单理解就是原型组成的链，对象的__proto__它的是原型，而原型也是一个对象，也有__proto__属性，原型的__proto__又是原型的原型，就这样可以一直通过__proto__想上找，这就是原型链，当向上找找到Object的原型的时候，这条原型链就算到头了。

原型对象和实例之间有什么作用呢？

通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。

在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法。

## 3、 请列举几种隐藏元素的方法

visibility: hidden;这个属性只是简单的隐藏某个元素，但是元素占用的空间仍然存在
opacity: 0; CSS3属性，设置0可以使一个元素完全透明，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的
display: none;元素会变得不可见，并且不会再占用元素位置。会改变页面布局。
transform: scale(0);将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留。

## 4、 防抖和节流★★★★★

本质上是优化高频率执行代码的一种手段

如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能

为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（防抖）和debounce（节流）的方式来减少调用频率

定义：

**节流**: **n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效**
**防抖**: **n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时**
一个经典的比喻:

想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应

假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制

电梯第一个人进来后，15秒后准时运送一次，这是节流。

电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖。

防抖应用场景

搜索框搜索输入。只需用户最后一次输入完，再发送请求
手机号、邮箱验证输入检测 onchange / oninput事件
窗口大小计算。只需窗口调整完成后，计算窗口大小。防止重复渲染。
节流应用场景

懒加载、滚动加载、加载更多或监听滚动条位置；
百度搜索框，搜索联想功能；
防止高频点击提交，防止表单重复提交；

## 5、==和=== 的区别?

==（相等操作符）：比较时会进行类型转换，尝试将两个操作数转换为相同的类型，然后进行值的比较。如果操作数的类型不同，会进行类型转换后再比较。这种比较方式被称为弱类型相等比较。

===（严格相等操作符）：比较时不进行类型转换，仅当两个操作数的类型相同且值相等时，返回true。这种比较方式要求比较的操作数类型和值都要相同。

==，当且仅当两个运算数相等时，它返回 true，即不检查数据类型
===，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型

## 6、JS 数据类型 ?

数据类型主要包括两部分：

基本数据类型： Undefined、Null、Boolean、Number 和 String
引用数据类型： Object (包括 Object 、Array 、Function)
ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )

## 7、null 和 undefined 的区别？

null 表示一个对象被定义了，值为“空值”；**无对象**
undefined 表示不存在这个值。**无值**
（1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。

null 和 undefined 区别

首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型
分别都只有一个值，就是 undefined 和 null。
undefined 代表的含义是未定义，null 代表的含义是空对象。一般
变量声明了但还没有定义的时候会返回 undefined，null 主要用于
赋值给一些可能会返回对象的变量，作为初始化。

## 8、★★★★★ promise理解、手写promise

Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，避免了地狱回调
Promise有三种状态： pending(等待态)，fulfilled(成功态)，rejected(失败态) ；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。
Promise拥有一个then方法，用以处理resolved或rejected状态下的值
then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。
then方法返回一个新的Promise对象，因此可以通过链式调用then方法

Promise 是异步编程的一种解决方案，它是一个对象，可以获取异步
操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，
它比传统的解决方案回调函数和事件更合理和更强大。
所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束
的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一
个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，
各种异步操作都可以用同样的方法进行处理。
（1）Promise 的实例有三个状态:
Pending（进行中）
Resolved（已完成）
Rejected（已拒绝）
当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了
状态就变成了 Resolved、没有完成失败了就变成了 Rejected。
（2）Promise 的实例有两个过程：
pending -> fulfilled : Resolved（已完成）
pending -> rejected：Rejected（已拒绝）
注意：一旦从进行状态变成为其他状态就永远不能更改状态了。

## 9、async await函数★★★★★

async/await函数是异步代码的新方式
async/await是基于promise实现的
async/await使异步代码更像同步代码
await 只能在async函数中使用，不能再普通函数中使用，要成对出现
默认返回一个promise实例，不能被改变
await下面的代码是异步，后面的代码是同步的

### 10、异步编程的实现方式？

回调函数

使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。
Promise

### 使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。

async 函数

async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。

## 箭头函数与普通函数的区别？

### 1、箭头函数比普通函数更加简洁

如果没有参数，就直接写一个空括号即可

如果只有一个参数，可以省去参数的括号

如果有多个参数，用逗号分割

如果函数体的返回值只有一句，可以省略大括号

### 2. 箭头函数没有自己的this

箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。

### 3. 箭头函数继承来的this指向永远不会改变

```js
var id = 'GLOBAL';
var obj = {
  id: 'OBJ',
  a: function(){
    console.log(this.id);
  },
  b: () => {
    console.log(this.id);
  }
};
obj.a();    // 'OBJ'
obj.b();    // 'GLOBAL'
new obj.a()  // undefined
new obj.b()  // Uncaught TypeError: obj.b is not a constructor
```

对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号**{ }**是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。

### 4. call()、apply()、bind()等方法不能改变箭头函数中this的指向

```js
var id = 'Global';
let fun1 = () => {
    console.log(this.id)
};
fun1();                     // 'Global'
fun1.call({id: 'Obj'});     // 'Global'
fun1.apply({id: 'Obj'});    // 'Global'
fun1.bind({id: 'Obj'})();   // 'Global'
```

### 5、箭头函数不能作为构造函数使用

由于箭头函数时没有自己的this，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。

### 6、箭头函数没有自己的arguments

箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。

### 7、箭头函数没有prototype

### 8、箭头函数的this指向哪⾥？★★★★★

箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。

## 10、常见的DOM操作有哪些

Create：动态增加DOM 节点

Delete：删除DOM 节点

Update：更新DOM 节点的内容

Read：获取DOM 节点

1 Document.getElementById()

2 Document.getElementsByTagName()

3 Document.getElementsByClassName()

4 Document.querySelector()

5 Document.querySelectorAll()

6 父节点Node.parentNode

## 11、对this对象的理解

##### this 关键字含义是什么？

解答：this总是返回一个对象，**this就是属性或方法“当前”所在对象。\**由于对象的属性可以赋值给另一个对象，所以属性所在的当前对象是可变的，即\**this指向是可变的**。

1.this是js 的一个关键字，随着函数的使用场合的不同，this 的值会发生变化。

2.一个总原则：即this指的是调用函数的那个对象。

3.一般情况下，this 是全局对象，可以作为方法调用。

## 12、 call、apply 及 bind 函数 ★★★★★

**call()、apply()、bind()都是用于改变this指向的方法，不同点传参方式不太相同以及返回不同。**

* call( ) 是接收一个及其以上的参数，第一个参数表示this要指向的对象，其余参数表示调用函数需要传入的参数，返回调用函数的返回结果，属于立即执行函数；
* apply( ) 是接收两个参数，第一个参数表示this要指向的对象，第二参数表示调用函数需要传入的参数所组成的数组，返回调用函数的返回结果，属于立即执行函数；
* bind( ) 是接收一个及其以上的参数，和call(）一致，但是其返回是一个函数，而不是调用函数的返回结果；

## 13 、**异步编程 ★★★★★**

### 一、回调函数

这是异步编程最基本的方法

```js
function asyncFn(callback) {
    setTimeout(() => {
        console.log('asyncFn');
        callback();
    }, 0)
}
function normalFn() {
    console.log('normalFn');
}

asyncFn(normalFn);
```

- 缺点
  - 容易出现回调地狱
  - 当多个回调函数嵌套，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪
  - 不能使用 try catch 不能直接return
- 优点
  - 简单、容易理解和实现

### 二、事件触发模式

另一种思路是采用事件驱动模式。即**异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。**
比如一个我们注册一个按钮的点击事件或者注册一个自定义事件，然后通过点击或者trigger的方式触发这个事件。

```js
var btn = document.getElementById('Button');
btn.onclick = function() {
    console.log('展示异步操作');
}
```

- 缺点
  - 整个程序变成事件驱动型，运行流程不清晰
- 优点
  - 可以绑定多个事件，每个事件可以指定多个回调函数
  - 可以“去耦合”，有利于实现模块化

### 三、发布订阅

发布/订阅模式，又称[观察者模式](https://so.csdn.net/so/search?q=观察者模式&spm=1001.2101.3001.7020)

我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subcribe）这个信号，从而知道什么时候自己可以开始执行。

```js
//f2向信号中心Jquery订阅done信号
	jQuery.subscribe("done", f2);
	function f1(){
　　　　setTimeout(function () {
　　　　　　// f1的任务代码
		   //发布done信号
　　　　　　jQuery.publish("done");
　　　　}, 1000);
　　}
　　//f2执行完成后，取消订阅
　　jQuery.unsubscribe("done", f2);
```

发布/订阅，性质与“事件监听类似”，但是明显优于后者，因为我们可以通过查看”消息中心“，了解存在多少信号，多少个订阅者，从而监听程序的运行。

### 四、Promises对象

Promises对象是CommonJs工作提出的一种规范，目的是为了异步编程提供统一接口

他的思想是每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数，比如f1的回调函数f2，可以写成：

```js
f1().then(f2);
　	function f1(){
　		//deferred对象就是jQuery的回调函数解决方案。
　　　　var dfd = $.Deferred();
　　　　setTimeout(function () {
　　　　　　// f1的任务代码
		   //将dtd对象的执行状态从"未完成"改为"已完成"，从而触发done()方法
　　　　　　dfd.resolve();
　　　　}, 500);
	   //返回promise对象 
	   // deferred.promise()方法。它的作用是，在原来的deferred对象上返回另一个deferred对象，
	   //后者只开放与改变执行状态无关的方法（比如done()方法和fail()方法），
	   //屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），
	   //从而使得执行状态不能被改变。
　　　　return dfd.promise;
　　}
 
	f1().then(f2).then(f3); //指定多个回调函数
	f1().then(f2).fail(f3); //指定发生错误时的回调函数
```

### 五、生成器函数 Generator/yield

Generator函数是 ES6 提供的一种异步编程解决方案。

yield表达式可以暂停函数执行，next方法用于恢复函数执行，这使得Generator函数非常适合将异步任务同步化。
yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。
每个yield返回的是｛value:yield返回的值，done:true/false(执行状态)｝

```js
function *generatorDemo() {
	 yield 'hello';
	 yield 1 + 2;
	 return 'ok';
	}
	 
	var demo = generatorDemo()
	 
	demo.next()  // { value: 'hello', done: false } 
	demo.next()  // { value: 3, done: false } 
	demo.next()  // { value: 'ok', done: ture } 
	demo.next()  // { value: undefined, done: ture }
```

六、async/await 函数的实现
async是“异步”的意思，而 await 是等待的意思。所以应该很好理解 async 用于申明一个 异步的function （实际上是asnyc function 对象）

await 用于等待一个异步任务执行完成的结果，并且await只等出现在 async 函数中

一个函数如果加上 asnyc，那么该函数就会返回一个 Promise

```js
async function async1() {
  return "1"
}
console.log(async1()) // -> Promise {<resolved>: "1"}
```

async函数返回的是一个 Promise 对象，可以使用 then 方法添加回调函数，async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。
1.await命令后面返回的是 Promise 对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。

## 14、seTimeout，Promise，Async/await的区别

共同点

```
都是用来解决异步回调问题
区别：
```

```
1.setTimeout属于宏任务。
```

```
2.Promise属于异步操作，只有当只有当.then(), resove(),.catch()等操作后才会进入微任务。
```

3.Async/await 在await之前都是异步操作，只有在await后才会进入微任务。
也可以说如果函数体有一个await，async就一定会异步，没有的话就是同步。
15、Promise理解
（1）抽象描述：

```
①promise 是一门新的技术(ES6 规范)；

②promise 是 js 中进行异步编程的新解决方案(旧方案是单纯使用回调函数)。
```

（2）具体描述：

```
①从语法上看：promise 是一个构造函数；

②从功能上看：promise 对象用来封装一个异步操作并可以获取其成功或者失败的结果值。
```

## 15、async、await详解

async/awiat的使用规则:

1. async 表示这是一个async函数， await只能用在async函数里面，不能单独使用
2. async 返回的是一个Promise对象，await就是等待这个promise的返回结果后，再继续执行
3. await 等待的是一个Promise对象，后面必须跟一个Promise对象，但是不必写then()，直接就可以得到返回值

## 16、什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？

[回调函数](https://so.csdn.net/so/search?q=回调函数&spm=1001.2101.3001.7020)：就是把一个函数当作一个函数的参数

## 回调地狱：

当[异步操作](https://so.csdn.net/so/search?q=异步操作&spm=1001.2101.3001.7020)想要有顺序时，只能在一个异步成功以后的回调函数里面嵌套另一个异步的操作，如果嵌套的层数过多就形成了回调地狱

回调地狱的弊端：后期代码维护比较困难

**async await  回调地狱的最终解决方法 （es7）**

**原理：**实际上就是生成器函数的语法糖

可以将异步嵌套的语法，改成像是同步一样。不需要嵌套，就可以有先后顺序

# vue

一、var、let、const的相同点

二、var、let、const的不同

区别一：var 存在变量提升 而 let 与 const 不存在变量提升

区别二：var定义的变量可以声明多次，而let、const定义的变量只能声明

区别三：var、let声明的变量可以再次赋值，而const声明的变量不能再次赋值

## v-if和v-show的详解

v-if:通过移除元素来实现元素的显示与隐藏，每次显示都会触发组件的mouted钩子函数。可以用来表面意义上的刷新组件
v-show:通过设置元素的display属性来控制元素的显示与隐藏。elementui的弹窗组件就是利用v-show来控制显示与隐藏的。
二.v-if和v-show的区别
加载速度不同，v-show要比v-if快，实际项目中就是这样。
原理不同。
应用场景不同，v-if多用于需要刷新的组件。v-show多用于不需要刷新组件的显示与隐藏。
组件内缓存子组件就是用的v-show。
做项目优化的时候可以尽量使用v-show,具体看需求。

## vue2和vue3的区别

### 1、双向数据绑定原理不同

**vue2**：[vue2](https://so.csdn.net/so/search?q=vue2&spm=1001.2101.3001.7020)的双向数据绑定是利用**ES5的一个APIObject.definePropert()** 对数据进行劫持，结合发布订阅模式的方式来实现的。

**vue3**：[vue3](https://so.csdn.net/so/search?q=vue3&spm=1001.2101.3001.7020)中使用了**ES6的Proxy API**对数据代理。相比vue2.x，使用proxy的优势如下：

* defineProperty只能监听某个属性，不能对全对象监听
* 可以省去for in，闭包等内容来提升效率(直接绑定整个对象即可)
* 可以监听数组，不用再去单独的对数组做特异性操作vue3.x可以检测到数组内部数据的变化。

### 2、是否支持碎片

**vue2**：vue2**不支持**碎片。

**vue3**：vue3**支持碎片（Fragments）** ，就是说可以拥有多个根节点。

### 3、API类型不同

**vue2**：vue2使用**选项类型api**，选项型api在代码里分割了不同的属性：data,computed,methods等。

**vue3**：vue3使用**合成型api**，新的合成型api能让我们使用方法来分割，相比于旧的api使用属性来分组，这样代码会更加简便和整洁。

### 4、定义数据变量和方法不同

**vue2**：vue2是把数据放入data中，在vue2中定义数据变量是**data(){}** ，创建的方法要在**methods:{}** 中。

**vue3**：，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。使用以下三个步骤来建立反应性数据：

* 从vue引入**reactive**；
* 使用**reactive()** 方法来声明数据为响应性数据；
* 使用setup()方法来返回我们的响应性数据，从而**template**可以获取这些响应性数据。

### 5、生命周期钩子函数不同

**vue2**：**vue2中的生命周期**：

* beforeCreate 组件创建之前
* created 组件创建之后
* beforeMount 组价挂载到页面之前执行
* mounted 组件挂载到页面之后执行
* beforeUpdate 组件更新之前
* updated 组件更新之后

**vue3**：**vue3中的生命周期**：

* setup 开始创建组件
* onBeforeMount 组价挂载到页面之前执行
* onMounted 组件挂载到页面之后执行
* onBeforeUpdate 组件更新之前
* onUpdated 组件更新之后

而且vue3.x 生命周期在调用前需要先进行引入。除了这些钩子函数外，vue3.x还增加了onRenderTracked 和onRenderTriggered函数。

### 6、父子传参不同

**vue2**：父传子，用props,子传父用事件 Emitting Events。在vue2中，会**调用this\$emit**然后传入事件名和对象。

**vue3**：父传子，用props,子传父用事件 Emitting Events。在vue3中的setup()中的第二个参数content对象中就有emit，那么我们只要在setup()接收**第二个参数中使用分解对象法取出emit**就可以在setup方法中随意使用了。

### 7、指令与插槽不同

**vue2**：vue2中使用slot可以**直接使用slot**；v-for与v-if在vue2中优先级高的是**v-for指令**，而且不建议一起使用。

**vue3**：vue3中必须使用**v-slot的形式**；vue3中v-for与v-if,只会把当前v-if当做v-for中的一个判断语句，**不会相互冲突**；vue3中移除keyCode作为v-on的修饰符，当然也不支持config.keyCodes；vue3中**移除v-on.native修饰符**；vue3中**移除过滤器filter**。

### 8、main.js文件不同

**vue2**：vue2中我们可以使用**pototype(原型)** 的形式去进行操作，引入的是**构造函数**。

**vue3**：vue3中需要使用**结构**的形式进行操作，引入的是**工厂函数**；vue3中app组件中可以**没有根标签**。

#### 拓展阅读

### setup()函数特性

* setup()函数接收两个参数：props、context(包含attrs、slots、emit)。
* setup函数是处于生命周期beforeCreated和created俩个钩子函数之前。
* 执行setup时，组件实例尚未被创建（在setup()内部，this不会是该活跃实例得引用，即不指向vue实例，Vue为了避免我们错误得使用，直接将setup函数中得this修改成了undefined）。
* 与模板一起使用时，需要返回一个对象。
* 因为setup函数中，props是响应式得，当传入新的prop时，它将会被更新，所以不能使用es6解构，因为它会消除prop得响应性，如需解构prop，可以通过使用setup函数中得toRefs来完成此操作。
* 在setup()内使用响应式数据时，需要通过 .value 获取。
* 从setup() 中返回得对象上得property 返回并可以在模板中被访问时，它将自动展开为内部值。不需要在模板中追加.value。
* setup函数只能是同步的不能是异步的。

### 1.vuex

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。

（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。
主要包括以下几个模块：

- **State =>** 基本数据，定义了应用状态的数据结构，可以在这里设置默认的初始状态。页面状态管理容器对象。集中存储 Vuecomponents 中 data对象的零散数据
- **Getter =>** 从基本数据派生的数据，允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。
- **Mutation =>** 是唯一更改 store 中状态的方法，且必须是同步函数。状态改变操作方法
- **Actions =>** 像一个装饰器，包裹mutations，使之可以异步。用于提**交 mutation**，而不是直接变更状态，可以包含任意异步操作。操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。
- **Module =>** 模块化Vuex，允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。

### 为什么 Vuex 的 mutation 中不能做异步操作？

Vuex 中所有的状态更新的唯一途径都是 mutation，异步操作通过
Action 来提交 mutation 实现，这样可以方便地跟踪每一个状态的
变化，从而能够实现一些工具帮助更好地了解我们的应用。
每个 mutation 执行完成后都会对应到一个新的状态变更，这样
devtools 就可以打个快照存下来，然后就可以实现 time-travel 了。
如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，
无法很好的进行状态的追踪，给调试带来困难。

## 2、生命周期

beforeCreate	组件实例被创建之初，组件的属性生效之前
created	组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用
beforeMount	在挂载开始之前被调用：相关的 render 函数首次被调用
mounted	el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子
beforeUpdate	组件数据更新之前调用，发生在虚拟 DOM 打补丁之前
updated	组件数据更新之后
activited	keep-alive 专属，组件被激活时调用
deadctivated	keep-alive 专属，组件被销毁时调用
beforeDestory	组件销毁前调用
destoryed	组件销毁后调用

**beforeCreate** 在实例初始化之后，数据观测（data observe）和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。

**created** 实例已经创建完成之后被调用。在这一步，实例已经完成以下的配置：数据观测（data observe ），属性和方法的运算，watch/event 事件回调。这里没有 $el，如果非要想与 DOM 进行交互，可以通过vm.$nextTick 来访问 DOM。

**beforeMount** 在挂载开始之前被调用：相关的 render 函数首次被调用。

**mounted** 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom节点。

**beforeUpdate** 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁 （patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。（数据修改页面未修改）

**updated** 发生在更新完成之后，当前阶段组件 Dom 已经完成更新。要注意的是避免在此期间更新数据，因为这个可能导致无限循环的更新，该钩子在服务器渲染期间不被调用。

**beforeDestroy** 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行 善后收尾工作，比如清除定时器。

**destroyed**  Vue实例销毁后调用。调用后，Vue实例指示的东西都会解绑定，所有的事件监听器会被移除，左右的子实例也会被销毁，该钩子在服务器端渲染不被调用。

**activated keep-alive** 专属，组件被激活时调用

## 3、Vue 组件间通信有哪几种方式？

Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。
（1）props / $emit 适用 父子组件通信

这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。
（2）ref 与 $parent / $children适用 父子组件通信

ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例
$parent / $children：访问父 / 子实例
（3）EventBus （$emit / $on）适用于 父子、隔代、兄弟组件通信

这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。
（4）$attrs/$listeners适用于 隔代组件通信

$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。
$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件
（5）provide / inject适用于 隔代组件通信

祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。
（6）Vuex适用于 父子、隔代、兄弟组件通信

### Vue组件通讯有哪些方式？

1、props 和 $emit。父组件向子组件传递数据是通过props传递的，子组件传递给父组件是通过$emit触发事件来做到的。

2、$parent 和 $children 获取单签组件的父组件和当前组件的子组件。

3、$attrs 和 $listeners A -> B -> C。Vue2.4开始提供了$attrs和$listeners来解决这个问题。

4、父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。（官方不推荐在实际业务中适用，但是写组件库时很常用。）

5、$refs 获取组件实例。

6、envetBus 兄弟组件数据传递，这种情况下可以使用事件总线的方式。

7、vuex 状态管理

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。
Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。

## 4、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？

### （1）hash 模式的实现原理

早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：
https://www.word.com#search
hash 路由模式的实现主要是基于下面几个特性：

URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；
可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；
我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。

### （2）history 模式的实现原理

HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。
唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：
window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
history 路由模式的实现主要基于存在下面几个特性：

pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；
我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；
history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。

## 5、computed 和 watch 区分使用场景

### computed：

是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；

### watch：

更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

### 运用场景：

当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

computed： 是**计算属性**，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；
watch： 更多的是「**观察**」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；
运用场景：
当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

## 6、v-if 和 v-show 有什么区别？

v-if 是真正的条件渲染，会控制这个 DOM 节点的存在与否。因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：**如果在初始渲染时条件为假**，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
**v-show 就简单得多——不管初始条件是什么，元素总是会被渲染**，并且只是简单地基于 CSS 的 “display” 属性进行切换。
当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。

## 7、怎样理解 Vue 的单向数据流？

所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。
这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。
额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。
这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。
子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。

## 8、v-model 的原理？

我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：

* text 和 textarea 元素使用 value 属性和 input 事件；
* checkbox 和 radio 使用 checked 属性和 change 事件
* select 字段将 value 作为 prop 并将 change 作为事件。

## 9、vue-router历史模式和hash模式的区别？

**hash模式**：
url里面带有#号，开发中默认的就是hash模式，hash虽然出现在URL中，但是不会被包括在HTTP请求中，所以改变hash不会重新刷新页面

路由的哈希模式就是利用了window.onhashchange事件，也就是url中的hash值（#号后面的值）如果有变化，就会自动调用hashchange的监听事件，在hashchange的监听事件内可以得到改变后的url，这样就能找到对应页面进行加载

**历史模式**：
利用了H5新增的pushState()、replaceState()方法。当这两个方法执行时，只能改变当前地址栏的URL，但是浏览器不会像后端发起请求，也不会触发popstate事件的执行。

## 10、created和mounted的区别

**created**：**在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成识图。**
**mounted**：**在模板渲染成html后调用，通常初始化页面完成后，再对html的dom节点进行一些需要的操作**。

## 11、v-[model]是如何实现的实现原理

### 1. 作用在普通表单元素上

- 动态绑定了 `input` 的 `value` 指向了 `message` 变量，并且在触发 `input` 事件的时候去动态把 `message` 设置为目标值
- ### 作用在组件上

  - 在自定义组件中，`v-model` 默认会利用名为 `value` 的 `prop` 和名为 `input` 的事件
  - 本质是一个父子组件通信的语法糖，通过 prop 和 $emit 实现

## 12、vue列表为什么加key

* 1、性能优化
* 2、diff算法节点比对
* 3、key不能是index

## 13路由的 hash 和 history 模式的区别

Vue-Router 有两种模式：hash 模式和 history 模式。默认的路由模
式是 hash 模式。

hash 模式是开发中默认的模式，它的 URL 带着一个#，例如：
http://www.abc.com/#/vue，它的 hash 值就是#/vue。
特点：hash 值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对
后端完全没有影响。所以改变 hash 值，不会重新加载页面。这种模
式的浏览器支持度很好，低版本的 IE 浏览器也支持这种模式。hash
路由被称为是前端路由，已经成为 SPA（单页面应用）的标配。

原理： hash 模式的主要原理就是 onhashchange()事件：

![1709212160938](images/前端八股文/1709212160938.png)

2. history 模式
   简介： history 模式的 URL 中没有#，它使用的是传统的路由分发模
   式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个
   URL，然后做出相应的逻辑处理。
   特 点 ： 当 使 用 history 模 式 时 ， URL 就 像 这 样 ：
   http://abc.com/user/id。相比 hash 模式更加好看。但是，history
   模式需要后台配置支持。如果后台没有正确配置，访问时会返回 404。
   API： history api 可以分为两大部分，切换历史状态和修改历史状
   态：
   修 改 历 史 状 态 ： 包 括 了 HTML5 History Interface 中 新 增 的
   pushState() 和 replaceState() 方法，这两个方法应用于浏览器的
   历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修
   改时，虽然修改了 url，但浏览器不会立即向后端发送请求。如果要
   做到改变 url 但又不刷新页面的效果，就需要前端用上这两个 API。
   切换历史状态： 包括 forward()、back()、go()三个方法，对应浏
   览器的前进，后退，跳转操作。
   虽然 history 模式丢弃了丑陋的#。但是，它也有自己的缺点，就是
   在刷新页面的时候，如果没有相应的路由或资源，就会刷出 404 来。
   如果想要切换到 history 模式，就要进行以下配置（后端也要进行配
   置）：
3. 两种模式对比
   调用 history.pushState() 相比于直接修改 hash，存在以下优势:
   pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而
   hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的
   URL；
   pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把
   记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动
   作将记录添加到栈中；
   pushState() 通过 stateObject 参数可以添加任意类型的数据到记
   录中；而 hash 只可添加短字符串；
   pushState() 可额外设置 title 属性供后续使用。
   hash 模式下，仅 hash 符号之前的 url 会被包含在请求中，后端如果
   没有做到对路由的全覆盖，也不会返回 404 错误；history 模式下，
   前端的 url 必须和实际向后端发起请求的 url 一致，如果没有对用的
   路由处理，将返回 404 错误。
   hash 模式和 history 模式都有各自的优势和缺陷，还是要根据实际
   情况选择性的使用。

# 5、状态码

常用的请求状态码

### 500 内部服务器错误

Internal Server Error 500内部服务器错误，服务器遇到未知无法解决的问题。

一般情况下，出现500响应状态的原因有很多种，但是主要的是“程序代码和服务器配置”两个问题。相对于代码而言，就是对站点进行升级，网页改版，新增加了一些常用的插件。就比如WordPress插件的版本可能就需要更高版本的PHP才能兼容。

而相对服务器而言的话，更多的是在系统版本升级导致，就比如最开始使用的是Windows Server 2003，后期想要升级2008、2012等版本的时候配置稍有不慎就会导致Internal Server Error 500。

### 404 请求错误

Not Found 404 错误请求，因发送的请求语法错误,服务器无法正常读取。

相信绝大多数的人都见过404的状态码，当用户试图请求Web服务器上一个不存在的资源时，就会触发Not Found404。出现404状态码可能是链接失效导致，也有可能是URL拼写错误，还有可能是因为Web服务器将所请求的资源移到了其他的地方。一般的网站都会设置自定义页面以防链接失效所产生不良的影响。

403 禁止访问
Forbidden 403 禁止访问，客户端没有权利访问所请求内容,服务器拒绝本次请求。

### 状态码403通常代表客户端错误

是指的服务器端有能力处理该请求，但是拒绝授权访问。这个状态码类似于401，但是进入该状态后不能再继续进行验证，该访问是长期禁止的，并且与应用逻辑密切相关，比如密码不正确等。

### 400 错误请求

Bad Request 400 错误请求，因发送的请求语法错误,服务器无法正常读取。

状态码400表示该语法无效，服务器无法理解该请求。客服端不应该在未经修改的情况下重复此请求。一般会因为前端提交数据的字段名称，或者是字段类型和后台的实体类不一致，导致无法封装。

### 401 未经授权

Unauthorized 401 未经授权，需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过。

状态码401就是Web服务器认为，客户端发送的HTTP数据流浪是正确的，但是进入URL资源的时候需要身份验证，而客户端尚未提供相关的验证信息，或者是已提供但是没有通过验证。这也是通常所知的“HTTP基本验证”。

### 200 请求成功

200 OK 请求成功，表示已经请求成功，默认情况下的状态码为200的响应就可以被缓存了。

不同请求方式对于请求成功的意义如下：

GET: 已经取得资源，并将资源添加到响应的消息体中。
HEAD: 响应的消息体为头部信息。
POST: 响应的消息体中包含此次请求的结果。
TRACE: 响应的消息体中包含服务器接收到的请求信息。

PUT 和 DELETE 的请求成功通常并不是响应200OK的状态码而是 204No Content 表示无内容(或者 201Created表示一个资源首次被创建成功)。

### 206 部分内容

Partial Content 206 部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码。

状态码206表示服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。

### 301 永久重定向

Moved Permanently 301 永久移动，该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的Location:头字段里找到。

尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用301，其他情况使用308 来替代301。

### 302 临时重定向

Found 302临时移动，该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的Location:头字段里找到。

即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代，因为在这些场景下方法变换是明确禁止的。

### 502 无效网关

Bad Gateway 502 网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应。

### 404 请求错误

Not Found 404 错误请求，因发送的请求语法错误,服务器无法正常读取。

相信绝大多数的人都见过404的状态码，当用户试图请求Web服务器上一个不存在的资源时，就会触发Not Found404。出现404状态码可能是链接失效导致，也有可能是URL拼写错误，还有可能是因为Web服务器将所请求的资源移到了其他的地方。一般的网站都会设置自定义页面以防链接失效所产生不良的影响。

### 403 禁止访问

Forbidden 403 禁止访问，客户端没有权利访问所请求内容,服务器拒绝本次请求。

状态码403通常代表客户端错误，是指的服务器端有能力处理该请求，但是拒绝授权访问。这个状态码类似于401，但是进入该状态后不能再继续进行验证，该访问是长期禁止的，并且与应用逻辑密切相关，比如密码不正确等。

### 400 错误请求

Bad Request 400 错误请求，因发送的请求语法错误,服务器无法正常读取。

状态码400表示该语法无效，服务器无法理解该请求。客服端不应该在未经修改的情况下重复此请求。一般会因为前端提交数据的字段名称，或者是字段类型和后台的实体类不一致，导致无法封装。

### 401 未经授权

Unauthorized 401 未经授权，需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过。

状态码401就是Web服务器认为，客户端发送的HTTP数据流浪是正确的，但是进入URL资源的时候需要身份验证，而客户端尚未提供相关的验证信息，或者是已提供但是没有通过验证。这也是通常所知的“HTTP基本验证”。

### 200 请求成功

200 OK 请求成功，表示已经请求成功，默认情况下的状态码为200的响应就可以被缓存了。

不同请求方式对于请求成功的意义如下：

GET: 已经取得资源，并将资源添加到响应的消息体中。
HEAD: 响应的消息体为头部信息。
POST: 响应的消息体中包含此次请求的结果。
TRACE: 响应的消息体中包含服务器接收到的请求信息。

PUT 和 DELETE 的请求成功通常并不是响应200OK的状态码而是 204No Content 表示无内容(或者 201Created表示一个资源首次被创建成功)。

### 206 部分内容

Partial Content 206 部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码。

状态码206表示服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。

### 301 永久重定向

Moved Permanently 301 永久移动，该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的Location:头字段里找到。

尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用301，其他情况使用308 来替代301。

### 302 临时重定向

Found 302临时移动，该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的Location:头字段里找到。

即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代，因为在这些场景下方法变换是明确禁止的。

### 502 无效网关

Bad Gateway 502 网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应。

bad gateway502代表您所访问的网站出了问题，因为502 Bad Gateway 服务器作为网关或者代理时，是为了完成访问下一个服务器，但该服务器返回了非法的应答。也许是暂时的，也许是永久的。建议大家稍等一下再从新访问试试。
