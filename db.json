{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/svg/Snipaste_2024-03-22_01-49-53.png","path":"svg/Snipaste_2024-03-22_01-49-53.png","modified":0,"renderable":0},{"_id":"source/svg/OIP.jpg","path":"svg/OIP.jpg","modified":0,"renderable":0},{"_id":"source/svg/60b9ed3cae5a9ba4024b411c.png","path":"svg/60b9ed3cae5a9ba4024b411c.png","modified":0,"renderable":0},{"_id":"source/svg/blibli.svg","path":"svg/blibli.svg","modified":0,"renderable":0},{"_id":"source/svg/logo.jpg","path":"svg/logo.jpg","modified":0,"renderable":0},{"_id":"source/svg/prwe.jpg","path":"svg/prwe.jpg","modified":0,"renderable":0},{"_id":"source/svg/discord.svg","path":"svg/discord.svg","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","path":"icons/favicon-16x16.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","path":"icons/favicon-32x32.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/886a749e.css","path":"static/886a749e.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/6b275704.css","path":"static/css/6b275704.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/3e25f349.css","path":"static/css/3e25f349.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/8e0e69c4.css","path":"static/css/8e0e69c4.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/882f9706.css","path":"static/css/882f9706.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/img/dccf965f.jpg","path":"static/img/dccf965f.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/a14e1a22.css","path":"static/css/a14e1a22.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/120aa8f8.js","path":"static/js/120aa8f8.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/9a0271b0.css","path":"static/css/9a0271b0.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/22ac7e7f.js","path":"static/js/22ac7e7f.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/36429e9b.js","path":"static/js/36429e9b.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/415fa29b.js","path":"static/js/415fa29b.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/7d897144.js","path":"static/js/7d897144.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/53ed1a6f.js","path":"static/js/53ed1a6f.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/7e80f274.js","path":"static/js/7e80f274.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/8da07a12.js","path":"static/js/8da07a12.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/9aa0d897.js","path":"static/js/9aa0d897.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/a92e6a1c.js","path":"static/js/a92e6a1c.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/9cb479b5.js","path":"static/js/9cb479b5.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/c562793b.js","path":"static/js/c562793b.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/d57a5994.js","path":"static/js/d57a5994.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/ff251d5d.js","path":"static/js/ff251d5d.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/fffbee97.js","path":"static/js/fffbee97.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/Genshin/index.md","hash":"a10ed487c00baba5653eb4e6b9d07b209436234f","modified":1711286373022},{"_id":"source/ChasingFan/index.md","hash":"bf9db3cd08dc10714a1c1a0111e7ea69db996690","modified":1711370078852},{"_id":"source/_posts/Api接口大全.md","hash":"dcc93790ba096effa35ddd21e8d9896c7ee9418a","modified":1711202592250},{"_id":"source/_posts/Communis.md","hash":"dad3840425dfc5fef23d798d53c3a9bec0542271","modified":1711087721789},{"_id":"source/_posts/Docker.md","hash":"cca0d1bc9c7ec36ec84b76e0aa700ff8328d670a","modified":1711085416096},{"_id":"source/_posts/EJS-简介.md","hash":"045d311a346c41531a59fd628b71117a93097bbc","modified":1711112339055},{"_id":"source/_posts/Hexo-aurora.md","hash":"d1e96aedcb6f5879aa26a56396a278260187a4ef","modified":1711204491256},{"_id":"source/_posts/Qexo.md","hash":"b3bd53cafdf9b5f51edc8ca742741857ffd94b23","modified":1711204491257},{"_id":"source/_posts/RabbitMQ的使用详解.md","hash":"e3dfcc6bb19c26d41604951776a5714de7a9440c","modified":1711379469871},{"_id":"source/_posts/Mysql.md","hash":"ac3ac316a36b649787be2cfa85b8204637085e59","modified":1710915881115},{"_id":"source/_posts/SSM.md","hash":"a7383d04f8277ce34f6610c69303b902ffc183a3","modified":1710908308269},{"_id":"source/_posts/Springboot-Mybatis-plus-Vue项目.md","hash":"ee676f07f4beeec4ef6bc3072a4e6ecbf94bd802","modified":1711299508441},{"_id":"source/_posts/Redis使用方法.md","hash":"8914bcde6949333026ed1c0f4ab3eafabdf88dad","modified":1711299897572},{"_id":"source/_posts/hexo-文档详解.md","hash":"d19de6067b41a19d2a55af211b7b9ffe64e8e4e6","modified":1711204030024},{"_id":"source/_posts/blender笔记.md","hash":"940ce6b787651869fd6d46b7aff6c84cf4f0626c","modified":1711108293627},{"_id":"source/_posts/React.md","hash":"b980a2c7d25f59c2bce444ab38493f419b30cf8c","modified":1710948446724},{"_id":"source/_posts/jsoup.md","hash":"b988d493d9cd1d9dd7ca503c23f27ef9488797f3","modified":1710915908957},{"_id":"source/_posts/VueRouter.md","hash":"f74c78ba471addc48fae4edbe717d01e75805e3e","modified":1710908067700},{"_id":"source/_posts/python.md","hash":"8e55a5bf4be9c28407cb7209866a326cabfd1193","modified":1711199031699},{"_id":"source/_posts/k8s.md","hash":"035685d3e844e313fa82f25f5c9f8e0e7b1ebd17","modified":1711004502932},{"_id":"source/_posts/liunx.md","hash":"f6041758bc3472acb8f25e0d6008a7bc91d7fb2c","modified":1710908249930},{"_id":"source/_posts/python爬虫.md","hash":"562cd62a5332941e48090d3ef1adc8af0eab1927","modified":1711379518739},{"_id":"source/_posts/pinia.md","hash":"f2105c600a87635100cc3050b3c4bd0f9081f33e","modified":1710915843102},{"_id":"source/_posts/代码工具.md","hash":"018bcc59693a78d7578bb843f27a15593b6c207f","modified":1711299508445},{"_id":"source/about/index.md","hash":"be00d0bc69b7d474baf33e8a3cffce34ddb311be","modified":1711150425506},{"_id":"source/_posts/springboot.md","hash":"852dce136ffe580065b17bf4bc444784939c4097","modified":1710915951047},{"_id":"source/_posts/少年锦衣卫.md","hash":"fdb9cbdd9dd5c7ff35be6fabc5b9c3f2bf19671e","modified":1711031929034},{"_id":"source/_posts/数据结构与算法.md","hash":"e70b1f09985374595ee15c3bcde006ff7f8e8743","modified":1711301277390},{"_id":"source/links/index.md","hash":"f12d0664bef08653c929ceb6e6092c9191bdff28","modified":1711296966561},{"_id":"source/message-board/index.md","hash":"0610e718d52cd20b604bef22d07a256e90d66763","modified":1710872408052},{"_id":"source/_posts/设计模式.md","hash":"45b21a33ec444fc07af21b240d05d24dd55f78ad","modified":1711113970345},{"_id":"source/svg/OIP.jpg","hash":"ef00f73eeb6a3f1cdb9a5f5c26a8f933c6d71b3b","modified":1711117480725},{"_id":"source/svg/60b9ed3cae5a9ba4024b411c.png","hash":"71525a7d007fbfc016bd52694f4b86d8e2fb9d8f","modified":1711110260596},{"_id":"source/svg/blibli.svg","hash":"857f0db17dcf95bb83912d5ac780280ec0951d8e","modified":1710937289759},{"_id":"source/svg/discord.svg","hash":"a6fe80a99253f5422425494d53736d309fb4279a","modified":1710945764408},{"_id":"source/_posts/hexo-文档详解/60b9ed3cae5a9ba4024b411c.png","hash":"71525a7d007fbfc016bd52694f4b86d8e2fb9d8f","modified":1711110260596},{"_id":"source/_posts/前端八股文.md","hash":"6087c00836cb153a71e8e2d052a6106c53d5a064","modified":1711107963124},{"_id":"source/_posts/java八股文.md","hash":"a814a1880d67e73cecb90eb1726559c6cc81711e","modified":1710907569532},{"_id":"source/svg/Snipaste_2024-03-22_01-49-53.png","hash":"a706797d1365817ac04b46cff24a63b392a6b834","modified":1711043399020},{"_id":"source/svg/prwe.jpg","hash":"18ade2013bf5645fcb9c85c2f89c68701bd8991b","modified":1624711667000},{"_id":"node_modules/hexo-theme-aurora/layout/index.ejs","hash":"64204d37402271ab2f5307a346cdb46090a88315","modified":1711094135405},{"_id":"node_modules/hexo-theme-aurora/LICENSE","hash":"21cf269018b0cf04e1126b6b9b1a5e6af7c5e61f","modified":1711072507887},{"_id":"node_modules/hexo-theme-aurora/package.json","hash":"953a91ce5eb62368e3fe1d335e8ccd024983b4fb","modified":1711072509885},{"_id":"node_modules/hexo-theme-aurora/README.md","hash":"8b5aea1bd91a6428040ec154ef313d20129fd1ce","modified":1711072509902},{"_id":"node_modules/hexo-theme-aurora/public/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1711072509073},{"_id":"node_modules/hexo-theme-aurora/public/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1711072509950},{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1711072509232},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1711072509937},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1711072509962},{"_id":"node_modules/hexo-theme-aurora/public/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1711072509919},{"_id":"node_modules/hexo-theme-aurora/source/static/css/6b275704.css","hash":"b04a2cd1a356e16cded5392bad271ce2f5b1c455","modified":1711072508193},{"_id":"node_modules/hexo-theme-aurora/source/static/886a749e.css","hash":"46ef385b52d11142f603d0916042be66e4e04b46","modified":1711072508499},{"_id":"node_modules/hexo-theme-aurora/source/static/css/3e25f349.css","hash":"2859941dbaabcdf25bfb6379a0efaf6b02b45971","modified":1711072508081},{"_id":"node_modules/hexo-theme-aurora/source/static/css/8e0e69c4.css","hash":"5e2ac4baf9923ea59d1dbddccb44a0e4ffbdc87f","modified":1711072508569},{"_id":"node_modules/hexo-theme-aurora/source/static/js/22ac7e7f.js","hash":"cdc1e66e812e4ce762170e6c2008a89ddb50ac22","modified":1711072509639},{"_id":"node_modules/hexo-theme-aurora/source/static/js/36429e9b.js","hash":"f1eb144273d1914ffd000cd6ab8ebf4603566fa1","modified":1711072509659},{"_id":"node_modules/hexo-theme-aurora/source/static/css/882f9706.css","hash":"156eb90b06b5f6f6f0bf24973874ecd85906f8fd","modified":1711072508305},{"_id":"node_modules/hexo-theme-aurora/source/static/js/415fa29b.js","hash":"8bbf6514805e9634eeb37d58ab9476fe7b4acab9","modified":1711072509679},{"_id":"node_modules/hexo-theme-aurora/source/static/js/7d897144.js","hash":"bc14613b9e836e8802949241e443176c3923a4ae","modified":1711072509712},{"_id":"node_modules/hexo-theme-aurora/source/static/js/53ed1a6f.js","hash":"392525c36d6f623723427c09a42cc7178f0aa65c","modified":1711072509696},{"_id":"node_modules/hexo-theme-aurora/source/static/css/9a0271b0.css","hash":"140052b8339ae6633bfdb6544050ba97c72ee630","modified":1711072508629},{"_id":"node_modules/hexo-theme-aurora/source/static/js/7e80f274.js","hash":"3e055cf0e8e1e795571b0ac307ebd9d055874bd9","modified":1711072509728},{"_id":"node_modules/hexo-theme-aurora/source/static/js/9aa0d897.js","hash":"da073d8793e58e2bd92cd879d753966950ea6d7e","modified":1711072509767},{"_id":"node_modules/hexo-theme-aurora/source/static/js/8da07a12.js","hash":"bbf25dc2749fc8ec6cd379e69a27d5e5ee116da1","modified":1711072509745},{"_id":"node_modules/hexo-theme-aurora/source/static/js/9cb479b5.js","hash":"41d6681d53d8ca77f4df159d831237550a80939c","modified":1711072509786},{"_id":"node_modules/hexo-theme-aurora/source/static/js/a92e6a1c.js","hash":"15838a598d2c67734d4e28d6667a148e3315862f","modified":1711072509803},{"_id":"node_modules/hexo-theme-aurora/source/static/js/c562793b.js","hash":"ef13be62aaee32758e059e625e6b85504c53f822","modified":1711072509819},{"_id":"node_modules/hexo-theme-aurora/source/static/js/d57a5994.js","hash":"baeabc2ef1f3ed1b2f651a436032cedc42e16d78","modified":1711072509835},{"_id":"node_modules/hexo-theme-aurora/source/static/js/ff251d5d.js","hash":"21fe31757fa0993c2a3d34009b8fa19e421e4dfb","modified":1711072509856},{"_id":"node_modules/hexo-theme-aurora/source/static/js/fffbee97.js","hash":"6a539112698cb0925ea4da8af22f3e8cdc554e3f","modified":1711072509870},{"_id":"node_modules/hexo-theme-aurora/source/static/css/a14e1a22.css","hash":"d4f364239f1c63b66b9917062e6a7cd9fa26fcba","modified":1711072508830},{"_id":"source/svg/logo.jpg","hash":"f856101dd12c02c76f5fdbe3f92ff47caab9252d","modified":1644599636000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/120aa8f8.js","hash":"84afbda7eecf891fae3fdac5219582c322d903ee","modified":1711072509621},{"_id":"node_modules/hexo-theme-aurora/source/static/img/dccf965f.jpg","hash":"a7a01b5a8d6882e4b8df4082fd4e84aabad4b64a","modified":1629879739378},{"_id":"public/api/posts/1.json","hash":"a9fdab43440ef5d4e0f87203cac49f6db465fd93","modified":1711382178630},{"_id":"public/api/posts/2.json","hash":"7cb0b0bf57acb751101d906855644e50047b2683","modified":1711382178630},{"_id":"public/api/posts/3.json","hash":"7923a9606b078c9fa61f56197a57258a184925db","modified":1711382178630},{"_id":"public/api/archives/1.json","hash":"a9fdab43440ef5d4e0f87203cac49f6db465fd93","modified":1711382178630},{"_id":"public/api/archives/2.json","hash":"7cb0b0bf57acb751101d906855644e50047b2683","modified":1711382178630},{"_id":"public/api/archives/3.json","hash":"7923a9606b078c9fa61f56197a57258a184925db","modified":1711382178630},{"_id":"public/api/articles/python爬虫.json","hash":"6df3a3b7f8b3d470d6eecc5d9322402e1c8c462a","modified":1711382178630},{"_id":"public/api/articles/RabbitMQ的使用详解.json","hash":"4fa8d5e51c12a46b11bb76f4edc3e453759fb5e0","modified":1711382178630},{"_id":"public/api/articles/Redis使用方法.json","hash":"8aac570f4048a8dbbf77d99f8791a84cac407f0e","modified":1711382178630},{"_id":"public/api/articles/Api接口大全.json","hash":"79c2d8ac09a8204e1ba07d7366bf45c057f91993","modified":1711382178630},{"_id":"public/api/articles/数据结构与算法.json","hash":"cff2b74a90ddc769daec93231e5c8b7aade28d0e","modified":1711382178630},{"_id":"public/api/articles/Qexo.json","hash":"866c62542ff07ede9ce19b3fb9850c435e02b494","modified":1711382178630},{"_id":"public/api/articles/Springboot-Mybatis-plus-Vue项目.json","hash":"54874f6d42fabac46294ab5902b9512e24963c15","modified":1711382178630},{"_id":"public/api/articles/代码工具.json","hash":"b1f6bc0a35c74ce9c37edaa024c3acc46cb0f044","modified":1711382178630},{"_id":"public/api/articles/EJS-简介.json","hash":"783b2c723d3839a4a1f2fdd995eac85c889a3804","modified":1711382178630},{"_id":"public/api/articles/设计模式.json","hash":"0e1aa7402ede718817e1bbdeaef549b6e6a75e8f","modified":1711382178630},{"_id":"public/api/articles/hexo-文档详解.json","hash":"995ee693a876d66da56ba061ec74b89dd332d16e","modified":1711382178630},{"_id":"public/api/articles/blender笔记.json","hash":"f4c3a3d206d2a04e01351f6200c0ceefe0aec634","modified":1711382178630},{"_id":"public/api/articles/少年锦衣卫.json","hash":"87c34479ab6b895618d5ccd6d61b3dfaad5f7520","modified":1711382178630},{"_id":"public/api/articles/Docker.json","hash":"6c435d6070eef8a37d175a31366ee62b3a7d9600","modified":1711382178630},{"_id":"public/api/articles/pinia.json","hash":"578d53c4c5fdd31cb5ee9e9a71e5dd68d4dc95a2","modified":1711382178630},{"_id":"public/api/articles/Communis.json","hash":"b26e5bb9be89e84f819422bae580313fc77dcd00","modified":1711382178630},{"_id":"public/api/articles/jsoup.json","hash":"b4719bbe378e7109e0995b784bbae2077e09e1d6","modified":1711382178630},{"_id":"public/api/articles/python.json","hash":"1241f005827ee1efdf19cb0785f25716719a71c3","modified":1711382178630},{"_id":"public/api/articles/VueRouter.json","hash":"e651be916f89dbf328c61109d994dea7902871a0","modified":1711382178630},{"_id":"public/api/articles/SSM.json","hash":"8aa630b824fde24af274ca7570cb668c7d274abc","modified":1711382178630},{"_id":"public/api/articles/React.json","hash":"b18ac8bbe29f557efbd2607a989d86a0e9f70db9","modified":1711382178630},{"_id":"public/api/articles/k8s.json","hash":"23aeef310298cbb42538aae614132728c793f07a","modified":1711382178630},{"_id":"public/api/articles/liunx.json","hash":"f9ba5b161aa364cd3aafd5946f49b18e5a2d24b7","modified":1711382178630},{"_id":"public/api/articles/springboot.json","hash":"4722b7966b4b0ebf700d5709a589dd642a9899a3","modified":1711382178630},{"_id":"public/api/articles/Mysql.json","hash":"5d2d65ab27d2f50ebc4bcd363d9d6e02089ef334","modified":1711382178630},{"_id":"public/api/articles/前端八股文.json","hash":"7bd5d75a595e3f6f904db552ba2f35cc39c9c587","modified":1711382178630},{"_id":"public/api/articles/java八股文.json","hash":"727b40e8da7cc823a08d87f0a40e22097283784d","modified":1711382178630},{"_id":"public/api/articles/Hexo-aurora.json","hash":"1564846afcf839c82137bf5f2426434dbfb12e00","modified":1711382178630},{"_id":"public/api/features.json","hash":"9a59a2188f3649a98bac53f8f80b97fa8b2f5087","modified":1711382178630},{"_id":"public/api/authors/blog-author.json","hash":"c878fbc53c62bc99ee460c5c489c8b815d1604bb","modified":1711382178630},{"_id":"public/api/authors/好名字都是狗起的.json","hash":"5a2de99fa2cac36d702d3f2063c4f2e3d35d10c1","modified":1711382178630},{"_id":"public/api/authors/jerry.json","hash":"25186470864878feb0de9fd7e440a8026ddcea5f","modified":1711382178630},{"_id":"public/api/authors/zmc-作者名字.json","hash":"cf4c58fb9e924dc30291ee5a1a0a614c6a262a50","modified":1711382178630},{"_id":"public/api/authors/zmc.json","hash":"96749475ac2d28992ce20f253224410861d7b153","modified":1711382178630},{"_id":"public/api/authors/tridiamond.json","hash":"f518664f16dba24ab553b8b66013a74a88fde10e","modified":1711382178630},{"_id":"public/api/categories.json","hash":"8aa83437d6789a7d30559357372a367a9a2a2508","modified":1711382178630},{"_id":"public/api/categories/毛选.json","hash":"0c020b7a76439ace593458d1e88ccfbeeb1fe6de","modified":1711382178630},{"_id":"public/api/categories/运维.json","hash":"6b79e942660e5d9f47c128f60c3cc4a86a9da599","modified":1711382178630},{"_id":"public/api/categories/数据库.json","hash":"677d300f1cf3a848679cc75db111a6fe960b0cf3","modified":1711382178630},{"_id":"public/api/categories/后端.json","hash":"558785a42d12f1c7d7950d0f83abdcb6775d0fc0","modified":1711382178630},{"_id":"public/api/categories/Blender建模.json","hash":"1f71f30736e9c6e5abe7eb1bfbacee966c8b52c2","modified":1711382178630},{"_id":"public/api/categories/爬虫.json","hash":"5201d1573b458222dcba77fecfa35a84bff250a5","modified":1711382178630},{"_id":"public/api/categories/前端.json","hash":"2f3eb263459db443154b4b3fc05a2730adb65173","modified":1711382178630},{"_id":"public/api/categories/工具.json","hash":"66bb4040e306992f82b2d20781feb7be3df524f3","modified":1711382178630},{"_id":"public/api/categories/动漫.json","hash":"1fbe5baadce4db1979906765ed6be682439373c3","modified":1711382178630},{"_id":"public/api/tags.json","hash":"a46106a0dbc70d6d8c28261600c251a7f9e5a20c","modified":1711382178630},{"_id":"public/api/tags/农民运动.json","hash":"d9c764ac0c4771d64abd35319359845cdb0fbfe1","modified":1711382178630},{"_id":"public/api/tags/Docker.json","hash":"d0269170850f9f472f3068183f52f359021e1d64","modified":1711382178630},{"_id":"public/api/tags/博客搭建.json","hash":"ea0bfed26e2b7dd0ff2a032ecba6e5e51497b392","modified":1711382178630},{"_id":"public/api/tags/Mysql.json","hash":"742165d2431688e4c344ab55209fb69cdce160cd","modified":1711382178630},{"_id":"public/api/tags/后端.json","hash":"a64ecc2427a9533625736891720af24a1793104f","modified":1711382178630},{"_id":"public/api/tags/RabbitMQ.json","hash":"e5a74d7040350748adc825b0a5042554e8874065","modified":1711382178630},{"_id":"public/api/tags/SSM.json","hash":"e02a2cda07860ac0966695d59117b394626b43e9","modified":1711382178630},{"_id":"public/api/tags/springboot.json","hash":"60124c8d6a8d3fc75818f732b75f87179e545245","modified":1711382178630},{"_id":"public/api/tags/React.json","hash":"0b5620126db779928469984bff886f0125658d0e","modified":1711382178630},{"_id":"public/api/tags/Blender.json","hash":"18fc30ad23fae9071fa1848e533a3e93f8143246","modified":1711382178630},{"_id":"public/api/tags/3D建模.json","hash":"beb53cf1886220475618a0a3bd5538e0a0ae11d1","modified":1711382178630},{"_id":"public/api/tags/爬虫.json","hash":"5c0d78cf34e010c719468e22a6a84b1337ce06b3","modified":1711382178630},{"_id":"public/api/tags/Vue.json","hash":"fd3648bc84429d829af8ecf617185a546b67712d","modified":1711382178630},{"_id":"public/api/tags/k8s.json","hash":"f6f8d058ed65976701cee67860864fb46b51f1f7","modified":1711382178630},{"_id":"public/api/tags/面试题.json","hash":"3be949033a1581f69691e814a00ed834014e55b3","modified":1711382178630},{"_id":"public/api/tags/liunx.json","hash":"3791dc3746d9b6aaa6f6696d9aeff57ae3271eb0","modified":1711382178630},{"_id":"public/api/tags/pinia.json","hash":"cd9ed399b1d838d477ae06304be1babd375a527d","modified":1711382178630},{"_id":"public/api/tags/工具.json","hash":"66bb4040e306992f82b2d20781feb7be3df524f3","modified":1711382178630},{"_id":"public/api/tags/插件.json","hash":"95ec5f6f743d107df11a9f0f669a7d30a5884b8b","modified":1711382178630},{"_id":"public/api/tags/Spingboot.json","hash":"b38ff5c2e8b5b6029eb745c12f98cd0310ffc759","modified":1711382178630},{"_id":"public/api/tags/动漫.json","hash":"1fbe5baadce4db1979906765ed6be682439373c3","modified":1711382178630},{"_id":"public/api/tags/音乐.json","hash":"852f082c1b8d171a9231681f1ff53d4c5fa45a35","modified":1711382178630},{"_id":"public/api/tags/Tag.json","hash":"61aa98b14f5b305ca50fc5bf6abca7adf86fb349","modified":1711382178630},{"_id":"public/api/tags/HTML.json","hash":"bf17409a95b5b39b58a8c929d139baaddeb3ebd8","modified":1711382178630},{"_id":"public/api/tags/CSS.json","hash":"78dad533363cf72cfe304e8bfc279e3b6ec4435b","modified":1711382178630},{"_id":"public/api/tags/JavaScript.json","hash":"0acfb50af4d92c328267acb0043b8d37fc6e9ea0","modified":1711382178630},{"_id":"public/api/tags/Node-js.json","hash":"cc9b6853a808ca03488c5ea940ac7a8d30c63960","modified":1711382178630},{"_id":"public/api/tags/Webpack.json","hash":"c26448463c829f816eac01830d6241c61cd75e20","modified":1711382178630},{"_id":"public/api/tags/Babel.json","hash":"7461848b84e7b9781f927aea4305a3102c47b40f","modified":1711382178630},{"_id":"public/api/tags/TypeScript.json","hash":"d4c9765ecefe1a3717c2f425b1b0677be3376259","modified":1711382178630},{"_id":"public/api/tags/Vuex.json","hash":"ef82258682b99eaf724c315079fc8aac84f453c1","modified":1711382178630},{"_id":"public/api/tags/设计模式.json","hash":"ffaf8c753d6ecf7f8b0b3eee9ee6a9040ac7cfa4","modified":1711382178630},{"_id":"public/api/pages/Genshin/index.json","hash":"bbf69ac929c853acf0409e57dc893d579c24435e","modified":1711382178630},{"_id":"public/api/pages/ChasingFan/index.json","hash":"e57a6ab839fc3877338d005af69136f31ff971b9","modified":1711382178630},{"_id":"public/api/pages/about/index.json","hash":"28d82abfd5522ffad00eb4266e889672dd9cfbde","modified":1711382178630},{"_id":"public/api/pages/links/index.json","hash":"54d8bfbdebbadf0fb8dd402579fffa7663385e88","modified":1711382178630},{"_id":"public/api/pages/message-board/index.json","hash":"10c51e749d4cb23b2537f5bc89c7ee091b1511d6","modified":1711382178630},{"_id":"public/api/statistic.json","hash":"8d3bffbc442754aa9cb55c81e3a04112f0aa1158","modified":1711382178630},{"_id":"public/api/search.json","hash":"b1b579cbe3fbb46b1feb26ca6bbb0688fa4bcdf9","modified":1711382178630},{"_id":"public/api/site.json","hash":"89586fc3d66d5996bd268513c4841a3c77205fc8","modified":1711382178630},{"_id":"public/post/python爬虫.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/RabbitMQ的使用详解.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/Redis使用方法.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/Api接口大全.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/数据结构与算法.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/Qexo.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/Springboot-Mybatis-plus-Vue项目.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/代码工具.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/EJS-简介.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/设计模式.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/hexo-文档详解.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/blender笔记.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/少年锦衣卫.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/Docker.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/pinia.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/Communis.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/jsoup.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/python.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/VueRouter.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/SSM.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/React.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/k8s.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/liunx.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/springboot.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/Mysql.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/前端八股文.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/index.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/java八股文.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/post/Hexo-aurora.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/page/2/index.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/page/3/index.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/tags/index.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/archives/index.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/links/index.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/page/Genshin/index.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/page/ChasingFan/index.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/page/about/index.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/page/links/index.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/page/message-board/index.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/tags/search/index.html","hash":"081492a34c29ddb39b7d608c29ca0c35c9c5b5f9","modified":1711382178630},{"_id":"public/svg/blibli.svg","hash":"857f0db17dcf95bb83912d5ac780280ec0951d8e","modified":1711382178630},{"_id":"public/svg/60b9ed3cae5a9ba4024b411c.png","hash":"71525a7d007fbfc016bd52694f4b86d8e2fb9d8f","modified":1711382178630},{"_id":"public/svg/OIP.jpg","hash":"ef00f73eeb6a3f1cdb9a5f5c26a8f933c6d71b3b","modified":1711382178630},{"_id":"public/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1711382178630},{"_id":"public/svg/discord.svg","hash":"a6fe80a99253f5422425494d53736d309fb4279a","modified":1711382178630},{"_id":"public/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1711382178630},{"_id":"public/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1711382178630},{"_id":"public/post/hexo-文档详解/60b9ed3cae5a9ba4024b411c.png","hash":"71525a7d007fbfc016bd52694f4b86d8e2fb9d8f","modified":1711382178630},{"_id":"public/static/886a749e.css","hash":"46ef385b52d11142f603d0916042be66e4e04b46","modified":1711382178630},{"_id":"public/static/css/882f9706.css","hash":"156eb90b06b5f6f6f0bf24973874ecd85906f8fd","modified":1711382178630},{"_id":"public/static/css/8e0e69c4.css","hash":"5e2ac4baf9923ea59d1dbddccb44a0e4ffbdc87f","modified":1711382178630},{"_id":"public/static/css/3e25f349.css","hash":"2859941dbaabcdf25bfb6379a0efaf6b02b45971","modified":1711382178630},{"_id":"public/static/css/6b275704.css","hash":"b04a2cd1a356e16cded5392bad271ce2f5b1c455","modified":1711382178630},{"_id":"public/static/css/9a0271b0.css","hash":"140052b8339ae6633bfdb6544050ba97c72ee630","modified":1711382178630},{"_id":"public/static/js/36429e9b.js","hash":"f1eb144273d1914ffd000cd6ab8ebf4603566fa1","modified":1711382178630},{"_id":"public/static/js/415fa29b.js","hash":"8bbf6514805e9634eeb37d58ab9476fe7b4acab9","modified":1711382178630},{"_id":"public/static/js/53ed1a6f.js","hash":"392525c36d6f623723427c09a42cc7178f0aa65c","modified":1711382178630},{"_id":"public/static/js/22ac7e7f.js","hash":"cdc1e66e812e4ce762170e6c2008a89ddb50ac22","modified":1711382178630},{"_id":"public/static/js/7e80f274.js","hash":"3e055cf0e8e1e795571b0ac307ebd9d055874bd9","modified":1711382178630},{"_id":"public/static/js/7d897144.js","hash":"bc14613b9e836e8802949241e443176c3923a4ae","modified":1711382178630},{"_id":"public/static/js/8da07a12.js","hash":"bbf25dc2749fc8ec6cd379e69a27d5e5ee116da1","modified":1711382178630},{"_id":"public/static/js/9cb479b5.js","hash":"41d6681d53d8ca77f4df159d831237550a80939c","modified":1711382178630},{"_id":"public/static/js/9aa0d897.js","hash":"da073d8793e58e2bd92cd879d753966950ea6d7e","modified":1711382178630},{"_id":"public/static/js/a92e6a1c.js","hash":"15838a598d2c67734d4e28d6667a148e3315862f","modified":1711382178630},{"_id":"public/static/js/c562793b.js","hash":"ef13be62aaee32758e059e625e6b85504c53f822","modified":1711382178630},{"_id":"public/static/js/d57a5994.js","hash":"baeabc2ef1f3ed1b2f651a436032cedc42e16d78","modified":1711382178630},{"_id":"public/static/js/ff251d5d.js","hash":"21fe31757fa0993c2a3d34009b8fa19e421e4dfb","modified":1711382178630},{"_id":"public/static/js/fffbee97.js","hash":"6a539112698cb0925ea4da8af22f3e8cdc554e3f","modified":1711382178630},{"_id":"public/static/css/a14e1a22.css","hash":"d4f364239f1c63b66b9917062e6a7cd9fa26fcba","modified":1711382178630},{"_id":"public/static/js/120aa8f8.js","hash":"84afbda7eecf891fae3fdac5219582c322d903ee","modified":1711382178630},{"_id":"public/svg/Snipaste_2024-03-22_01-49-53.png","hash":"a706797d1365817ac04b46cff24a63b392a6b834","modified":1711382178630},{"_id":"public/svg/prwe.jpg","hash":"18ade2013bf5645fcb9c85c2f89c68701bd8991b","modified":1711382178630},{"_id":"public/svg/logo.jpg","hash":"f856101dd12c02c76f5fdbe3f92ff47caab9252d","modified":1711382178630},{"_id":"public/static/img/dccf965f.jpg","hash":"a7a01b5a8d6882e4b8df4082fd4e84aabad4b64a","modified":1711382178630}],"Category":[{"name":"毛选","_id":"clu74rgxc0006iou26k6eho53"},{"name":"运维","_id":"clu74rgxi000diou2a8vg9ob9"},{"name":"数据库","_id":"clu74rgxl000kiou2aqj93ade"},{"name":"后端","_id":"clu74rgxo000riou204kqbdei"},{"name":"Blender建模","_id":"clu74rgxv0017iou27y0j61k1"},{"name":"爬虫","_id":"clu74rgxy001fiou20prm6llq"},{"name":"前端","_id":"clu74rgy3001piou28714eh2p"},{"name":"工具","_id":"clu74rgye001wiou25bgz29ze"},{"name":"动漫","_id":"clu74rgyf0020iou2dhqqgrrk"}],"Data":[],"Page":[{"title":"ChasingFan","date":"2024-03-22T05:55:00.000Z","tags":"","published":true,"_content":"# 原神\n\n## 简介\n   - 《原神》是由中国游戏公司miHoYo（米哈游）开发的一款开放世界动作角色扮演游戏。游戏于2020年9月28日正式发布，支持Windows、PlayStation 4、iOS和Android平台。游戏以开放世界为背景，玩家可以在游戏中探索世界、解开谜题、与敌人战斗、完成任务等。游戏的世界观设定在一个名为提瓦特的幻想世界，玩家可以在游戏中扮演“旅行者”这个角色，通过与其他角色的互动来推动游戏的剧情发展。","source":"Genshin/index.md","raw":"---\ntitle: ChasingFan\ndate: 2024-03-22 13:55:00\ntags: ''\npublished: true\n---\n# 原神\n\n## 简介\n   - 《原神》是由中国游戏公司miHoYo（米哈游）开发的一款开放世界动作角色扮演游戏。游戏于2020年9月28日正式发布，支持Windows、PlayStation 4、iOS和Android平台。游戏以开放世界为背景，玩家可以在游戏中探索世界、解开谜题、与敌人战斗、完成任务等。游戏的世界观设定在一个名为提瓦特的幻想世界，玩家可以在游戏中扮演“旅行者”这个角色，通过与其他角色的互动来推动游戏的剧情发展。","updated":"2024-03-24T13:19:33.022Z","path":"Genshin/index.html","comments":1,"layout":"page","_id":"clu74rgx20000iou2h9tc9x6w","content":"<h1 id=\"原神\"><a href=\"#原神\" class=\"headerlink\" title=\"原神\"></a>原神</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li>《原神》是由中国游戏公司miHoYo（米哈游）开发的一款开放世界动作角色扮演游戏。游戏于2020年9月28日正式发布，支持Windows、PlayStation 4、iOS和Android平台。游戏以开放世界为背景，玩家可以在游戏中探索世界、解开谜题、与敌人战斗、完成任务等。游戏的世界观设定在一个名为提瓦特的幻想世界，玩家可以在游戏中扮演“旅行者”这个角色，通过与其他角色的互动来推动游戏的剧情发展。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"原神\"><a href=\"#原神\" class=\"headerlink\" title=\"原神\"></a>原神</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li>《原神》是由中国游戏公司miHoYo（米哈游）开发的一款开放世界动作角色扮演游戏。游戏于2020年9月28日正式发布，支持Windows、PlayStation 4、iOS和Android平台。游戏以开放世界为背景，玩家可以在游戏中探索世界、解开谜题、与敌人战斗、完成任务等。游戏的世界观设定在一个名为提瓦特的幻想世界，玩家可以在游戏中扮演“旅行者”这个角色，通过与其他角色的互动来推动游戏的剧情发展。</li>\n</ul>\n"},{"title":"ChasingFan","date":"2024-03-20T16:37:12.000Z","tags":["ChasingFan"],"categories":["追番"],"_content":"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Jc</title>\n   <style>\n    *{\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\nbody{\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    min-height: 100vh;\n    background-color: #161623;\n}\nbody::before{\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background:linear-gradient(#f00,#f0f);\n    clip-path: circle(30% at right 70%);\n}\nbody::after{\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background:linear-gradient(#2196f3,#e91e63);\n    clip-path: circle(20% at 10% 10%);\n}\n.container{\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    max-width: 1200px;\n    flex-wrap: wrap;\n    z-index: 1;\n    /*background-color: #0fb6d6;*/\n}\n.container .card{\n    position: relative;\n    width:  150px;\n    height: 150px;\n    margin: 30px;\n    box-shadow: 20px 20px 50px rgba(0,0,0,0.5);\n    border-radius: 15px;\n    background-color: rgba(255,255,255,0.1);\n    overflow: hidden;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-top: rgba(255,255,255,0.5) 1px solid;\n    border-left: rgba(255,255,255,0.5) 1px solid;\n    backdrop-filter: blur(5px);\n}\n\n   </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n    </div>\n    <br>\n    <div class=\"container\">\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n    </div>\n    <br>\n    <div class=\"container\">\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n    </div>\n</body>\n</html>","source":"ChasingFan/index.md","raw":"---\ntitle: ChasingFan\ndate: 2024-03-21 00:37:12\ntags:\n  - ChasingFan\ncategories:\n  - 追番\n---\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Jc</title>\n   <style>\n    *{\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\nbody{\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    min-height: 100vh;\n    background-color: #161623;\n}\nbody::before{\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background:linear-gradient(#f00,#f0f);\n    clip-path: circle(30% at right 70%);\n}\nbody::after{\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background:linear-gradient(#2196f3,#e91e63);\n    clip-path: circle(20% at 10% 10%);\n}\n.container{\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    max-width: 1200px;\n    flex-wrap: wrap;\n    z-index: 1;\n    /*background-color: #0fb6d6;*/\n}\n.container .card{\n    position: relative;\n    width:  150px;\n    height: 150px;\n    margin: 30px;\n    box-shadow: 20px 20px 50px rgba(0,0,0,0.5);\n    border-radius: 15px;\n    background-color: rgba(255,255,255,0.1);\n    overflow: hidden;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-top: rgba(255,255,255,0.5) 1px solid;\n    border-left: rgba(255,255,255,0.5) 1px solid;\n    backdrop-filter: blur(5px);\n}\n\n   </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n    </div>\n    <br>\n    <div class=\"container\">\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n    </div>\n    <br>\n    <div class=\"container\">\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n    </div>\n</body>\n</html>","updated":"2024-03-25T16:18:05.811Z","path":"ChasingFan/index.html","_id":"clu74rgx90002iou271a3h6a6","comments":1,"layout":"page","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Jc</title>\n   <style>\n    *{\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\nbody{\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    min-height: 100vh;\n    background-color: #161623;\n}\nbody::before{\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background:linear-gradient(#f00,#f0f);\n    clip-path: circle(30% at right 70%);\n}\nbody::after{\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background:linear-gradient(#2196f3,#e91e63);\n    clip-path: circle(20% at 10% 10%);\n}\n.container{\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    max-width: 1200px;\n    flex-wrap: wrap;\n    z-index: 1;\n    /*background-color: #0fb6d6;*/\n}\n.container .card{\n    position: relative;\n    width:  150px;\n    height: 150px;\n    margin: 30px;\n    box-shadow: 20px 20px 50px rgba(0,0,0,0.5);\n    border-radius: 15px;\n    background-color: rgba(255,255,255,0.1);\n    overflow: hidden;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-top: rgba(255,255,255,0.5) 1px solid;\n    border-left: rgba(255,255,255,0.5) 1px solid;\n    backdrop-filter: blur(5px);\n}\n\n<p>   </style></p>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n    </div>\n    <br>\n    <div class=\"container\">\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n    </div>\n    <br>\n    <div class=\"container\">\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n    </div>\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Jc</title>\n   <style>\n    *{\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\nbody{\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    min-height: 100vh;\n    background-color: #161623;\n}\nbody::before{\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background:linear-gradient(#f00,#f0f);\n    clip-path: circle(30% at right 70%);\n}\nbody::after{\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background:linear-gradient(#2196f3,#e91e63);\n    clip-path: circle(20% at 10% 10%);\n}\n.container{\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    max-width: 1200px;\n    flex-wrap: wrap;\n    z-index: 1;\n    /*background-color: #0fb6d6;*/\n}\n.container .card{\n    position: relative;\n    width:  150px;\n    height: 150px;\n    margin: 30px;\n    box-shadow: 20px 20px 50px rgba(0,0,0,0.5);\n    border-radius: 15px;\n    background-color: rgba(255,255,255,0.1);\n    overflow: hidden;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-top: rgba(255,255,255,0.5) 1px solid;\n    border-left: rgba(255,255,255,0.5) 1px solid;\n    backdrop-filter: blur(5px);\n}\n\n<p>   </style></p>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n    </div>\n    <br>\n    <div class=\"container\">\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n    </div>\n    <br>\n    <div class=\"container\">\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n        <div class=\"card\">\n            <div class=\"content\">\n            </div>\n        </div>\n    </div>\n</body>\n</html>"},{"title":"about","date":"2024-03-19T07:22:25.000Z","_content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>山羊の前端小窝</title>\n    <style>\n        body{\n            background-color: rgb(204, 212, 230);\n            display: flex;\n            justify-content: center;\n        }\n        .a{\n            position: relative;\n            width: 700px;\n            height: 400px;\n            border: #fff 10px solid;\n            background-color: rgb(120,140,200);\n            top: 120px;\n            border-radius: 20px;\n            overflow: hidden;\n        }\n        .b{\n            position: absolute;\n            width: 200px;\n            height: 300px;\n            left: 0;\n            margin: 75px 50px;\n            transition: 1s;\n        }\n        .b a{\n            text-decoration: none;\n            color: #fff;\n            font: 900 28px '';\n        }\n        .b h2{\n            /* 鼠标放开时的动画，第一个值是动画的过渡时间\n            第二个值是延迟一秒后执行动画 */\n            transition: .5s 1s;\n            opacity: 0;\n            color: rgb(30,210,200);\n        }\n        .b span{\n            transition: .5s 1s;\n            color: #fff;\n            font: 500 15px '';\n            position: absolute;\n            top: 70px;\n        }\n        .c{\n            position: absolute;\n            top: -130px;\n            right: -240px;\n        }\n        .d,.e{\n            position: absolute;\n            right: calc(var(--i)*100px);\n            width: calc(var(--w)*40px);\n            height: 500px;\n            overflow: hidden;\n            border-radius: 100px;\n            transform: rotateZ(220deg) translate(0,0);\n            background: rgb(240,220,150);\n            transition: .5s .5s;\n        }\n        .d:nth-child(2){\n            background: rgb(240,190,230);\n        }\n        .e{\n            left: -470px;\n            top: -140px;\n            width: 70px;\n            background-color: rgb(90,220,150);\n        }\n        .a:hover .c div{\n            /* 设置延迟动画 */\n            transition: .5s calc(var(--i)*.1s);\n            /* 移动的轨迹 */\n            transform: rotateZ(220deg) translate(-200px,400px);\n        }\n        .a:hover .b{\n            transition: 1s .5s;\n            left: 370px;\n        }\n        .a:hover .b span{\n            transition: 1s .5s;\n            top: 105px;\n        }\n        .a:hover .b h2{\n            transition: 1s .5s;\n            opacity: 1;\n        }\n        .f{\n            width: 250px;\n            height: 250px;\n            position: absolute;\n            background-image: url(\"https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-04-19_18-35-56.png?token=ASFPQIH5ZFVFELX7P4ECQWLF7JJY6\");\n            background-size: cover;\n            margin: 70px;\n            opacity: 0;\n            transition: .5s;\n        }\n        .a:hover .f{\n            transition: 1s 1.3s;\n            opacity: 1;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"a\">\n        <div class=\"b\">\n            <a href=\"#\">山羊の前端小窝</a>\n            <h2>WX:Sod-of-goat</h2>\n            <span>我是一个前端开发爱好者</br>我每天都在学习新知识，与您分享，<br/>我希望在未来的日子里<br/>继续前进!!</span>\n        </div>\n        <div class=\"c\">\n            <div class=\"d\" style=\"--i:1;--w:1.5\"></div>\n            <div class=\"d\" style=\"--i:2;--w:1.6\"></div>\n            <div class=\"d\" style=\"--i:3;--w:1.4\"></div>\n            <div class=\"d\" style=\"--i:4;--w:1.7\"></div>\n            <div class=\"e\" style=\"--i:1\"></div>\n        </div>\n        <div class=\"f\"></div>\n    </div>","source":"about/index.md","raw":"---\ntitle: about\ndate: 2024-03-19 15:22:25\n---\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>山羊の前端小窝</title>\n    <style>\n        body{\n            background-color: rgb(204, 212, 230);\n            display: flex;\n            justify-content: center;\n        }\n        .a{\n            position: relative;\n            width: 700px;\n            height: 400px;\n            border: #fff 10px solid;\n            background-color: rgb(120,140,200);\n            top: 120px;\n            border-radius: 20px;\n            overflow: hidden;\n        }\n        .b{\n            position: absolute;\n            width: 200px;\n            height: 300px;\n            left: 0;\n            margin: 75px 50px;\n            transition: 1s;\n        }\n        .b a{\n            text-decoration: none;\n            color: #fff;\n            font: 900 28px '';\n        }\n        .b h2{\n            /* 鼠标放开时的动画，第一个值是动画的过渡时间\n            第二个值是延迟一秒后执行动画 */\n            transition: .5s 1s;\n            opacity: 0;\n            color: rgb(30,210,200);\n        }\n        .b span{\n            transition: .5s 1s;\n            color: #fff;\n            font: 500 15px '';\n            position: absolute;\n            top: 70px;\n        }\n        .c{\n            position: absolute;\n            top: -130px;\n            right: -240px;\n        }\n        .d,.e{\n            position: absolute;\n            right: calc(var(--i)*100px);\n            width: calc(var(--w)*40px);\n            height: 500px;\n            overflow: hidden;\n            border-radius: 100px;\n            transform: rotateZ(220deg) translate(0,0);\n            background: rgb(240,220,150);\n            transition: .5s .5s;\n        }\n        .d:nth-child(2){\n            background: rgb(240,190,230);\n        }\n        .e{\n            left: -470px;\n            top: -140px;\n            width: 70px;\n            background-color: rgb(90,220,150);\n        }\n        .a:hover .c div{\n            /* 设置延迟动画 */\n            transition: .5s calc(var(--i)*.1s);\n            /* 移动的轨迹 */\n            transform: rotateZ(220deg) translate(-200px,400px);\n        }\n        .a:hover .b{\n            transition: 1s .5s;\n            left: 370px;\n        }\n        .a:hover .b span{\n            transition: 1s .5s;\n            top: 105px;\n        }\n        .a:hover .b h2{\n            transition: 1s .5s;\n            opacity: 1;\n        }\n        .f{\n            width: 250px;\n            height: 250px;\n            position: absolute;\n            background-image: url(\"https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-04-19_18-35-56.png?token=ASFPQIH5ZFVFELX7P4ECQWLF7JJY6\");\n            background-size: cover;\n            margin: 70px;\n            opacity: 0;\n            transition: .5s;\n        }\n        .a:hover .f{\n            transition: 1s 1.3s;\n            opacity: 1;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"a\">\n        <div class=\"b\">\n            <a href=\"#\">山羊の前端小窝</a>\n            <h2>WX:Sod-of-goat</h2>\n            <span>我是一个前端开发爱好者</br>我每天都在学习新知识，与您分享，<br/>我希望在未来的日子里<br/>继续前进!!</span>\n        </div>\n        <div class=\"c\">\n            <div class=\"d\" style=\"--i:1;--w:1.5\"></div>\n            <div class=\"d\" style=\"--i:2;--w:1.6\"></div>\n            <div class=\"d\" style=\"--i:3;--w:1.4\"></div>\n            <div class=\"d\" style=\"--i:4;--w:1.7\"></div>\n            <div class=\"e\" style=\"--i:1\"></div>\n        </div>\n        <div class=\"f\"></div>\n    </div>","updated":"2024-03-22T23:33:45.506Z","path":"about/index.html","comments":1,"layout":"page","_id":"clu74rgxb0004iou2492y01fv","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>山羊の前端小窝</title>\n    <style>\n        body{\n            background-color: rgb(204, 212, 230);\n            display: flex;\n            justify-content: center;\n        }\n        .a{\n            position: relative;\n            width: 700px;\n            height: 400px;\n            border: #fff 10px solid;\n            background-color: rgb(120,140,200);\n            top: 120px;\n            border-radius: 20px;\n            overflow: hidden;\n        }\n        .b{\n            position: absolute;\n            width: 200px;\n            height: 300px;\n            left: 0;\n            margin: 75px 50px;\n            transition: 1s;\n        }\n        .b a{\n            text-decoration: none;\n            color: #fff;\n            font: 900 28px '';\n        }\n        .b h2{\n            /* 鼠标放开时的动画，第一个值是动画的过渡时间\n            第二个值是延迟一秒后执行动画 */\n            transition: .5s 1s;\n            opacity: 0;\n            color: rgb(30,210,200);\n        }\n        .b span{\n            transition: .5s 1s;\n            color: #fff;\n            font: 500 15px '';\n            position: absolute;\n            top: 70px;\n        }\n        .c{\n            position: absolute;\n            top: -130px;\n            right: -240px;\n        }\n        .d,.e{\n            position: absolute;\n            right: calc(var(--i)*100px);\n            width: calc(var(--w)*40px);\n            height: 500px;\n            overflow: hidden;\n            border-radius: 100px;\n            transform: rotateZ(220deg) translate(0,0);\n            background: rgb(240,220,150);\n            transition: .5s .5s;\n        }\n        .d:nth-child(2){\n            background: rgb(240,190,230);\n        }\n        .e{\n            left: -470px;\n            top: -140px;\n            width: 70px;\n            background-color: rgb(90,220,150);\n        }\n        .a:hover .c div{\n            /* 设置延迟动画 */\n            transition: .5s calc(var(--i)*.1s);\n            /* 移动的轨迹 */\n            transform: rotateZ(220deg) translate(-200px,400px);\n        }\n        .a:hover .b{\n            transition: 1s .5s;\n            left: 370px;\n        }\n        .a:hover .b span{\n            transition: 1s .5s;\n            top: 105px;\n        }\n        .a:hover .b h2{\n            transition: 1s .5s;\n            opacity: 1;\n        }\n        .f{\n            width: 250px;\n            height: 250px;\n            position: absolute;\n            background-image: url(\"https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-04-19_18-35-56.png?token=ASFPQIH5ZFVFELX7P4ECQWLF7JJY6\");\n            background-size: cover;\n            margin: 70px;\n            opacity: 0;\n            transition: .5s;\n        }\n        .a:hover .f{\n            transition: 1s 1.3s;\n            opacity: 1;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"a\">\n        <div class=\"b\">\n            <a href=\"#\">山羊の前端小窝</a>\n            <h2>WX:Sod-of-goat</h2>\n            <span>我是一个前端开发爱好者</br>我每天都在学习新知识，与您分享，<br/>我希望在未来的日子里<br/>继续前进!!</span>\n        </div>\n        <div class=\"c\">\n            <div class=\"d\" style=\"--i:1;--w:1.5\"></div>\n            <div class=\"d\" style=\"--i:2;--w:1.6\"></div>\n            <div class=\"d\" style=\"--i:3;--w:1.4\"></div>\n            <div class=\"d\" style=\"--i:4;--w:1.7\"></div>\n            <div class=\"e\" style=\"--i:1\"></div>\n        </div>\n        <div class=\"f\"></div>\n    </div>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>山羊の前端小窝</title>\n    <style>\n        body{\n            background-color: rgb(204, 212, 230);\n            display: flex;\n            justify-content: center;\n        }\n        .a{\n            position: relative;\n            width: 700px;\n            height: 400px;\n            border: #fff 10px solid;\n            background-color: rgb(120,140,200);\n            top: 120px;\n            border-radius: 20px;\n            overflow: hidden;\n        }\n        .b{\n            position: absolute;\n            width: 200px;\n            height: 300px;\n            left: 0;\n            margin: 75px 50px;\n            transition: 1s;\n        }\n        .b a{\n            text-decoration: none;\n            color: #fff;\n            font: 900 28px '';\n        }\n        .b h2{\n            /* 鼠标放开时的动画，第一个值是动画的过渡时间\n            第二个值是延迟一秒后执行动画 */\n            transition: .5s 1s;\n            opacity: 0;\n            color: rgb(30,210,200);\n        }\n        .b span{\n            transition: .5s 1s;\n            color: #fff;\n            font: 500 15px '';\n            position: absolute;\n            top: 70px;\n        }\n        .c{\n            position: absolute;\n            top: -130px;\n            right: -240px;\n        }\n        .d,.e{\n            position: absolute;\n            right: calc(var(--i)*100px);\n            width: calc(var(--w)*40px);\n            height: 500px;\n            overflow: hidden;\n            border-radius: 100px;\n            transform: rotateZ(220deg) translate(0,0);\n            background: rgb(240,220,150);\n            transition: .5s .5s;\n        }\n        .d:nth-child(2){\n            background: rgb(240,190,230);\n        }\n        .e{\n            left: -470px;\n            top: -140px;\n            width: 70px;\n            background-color: rgb(90,220,150);\n        }\n        .a:hover .c div{\n            /* 设置延迟动画 */\n            transition: .5s calc(var(--i)*.1s);\n            /* 移动的轨迹 */\n            transform: rotateZ(220deg) translate(-200px,400px);\n        }\n        .a:hover .b{\n            transition: 1s .5s;\n            left: 370px;\n        }\n        .a:hover .b span{\n            transition: 1s .5s;\n            top: 105px;\n        }\n        .a:hover .b h2{\n            transition: 1s .5s;\n            opacity: 1;\n        }\n        .f{\n            width: 250px;\n            height: 250px;\n            position: absolute;\n            background-image: url(\"https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-04-19_18-35-56.png?token=ASFPQIH5ZFVFELX7P4ECQWLF7JJY6\");\n            background-size: cover;\n            margin: 70px;\n            opacity: 0;\n            transition: .5s;\n        }\n        .a:hover .f{\n            transition: 1s 1.3s;\n            opacity: 1;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"a\">\n        <div class=\"b\">\n            <a href=\"#\">山羊の前端小窝</a>\n            <h2>WX:Sod-of-goat</h2>\n            <span>我是一个前端开发爱好者</br>我每天都在学习新知识，与您分享，<br/>我希望在未来的日子里<br/>继续前进!!</span>\n        </div>\n        <div class=\"c\">\n            <div class=\"d\" style=\"--i:1;--w:1.5\"></div>\n            <div class=\"d\" style=\"--i:2;--w:1.6\"></div>\n            <div class=\"d\" style=\"--i:3;--w:1.4\"></div>\n            <div class=\"d\" style=\"--i:4;--w:1.7\"></div>\n            <div class=\"e\" style=\"--i:1\"></div>\n        </div>\n        <div class=\"f\"></div>\n    </div>"},{"title":"links","date":"2024-03-19T07:22:44.000Z","type":"friends","categoryMode":"fasle","data":[{"nick":"三钻","avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg","description":"Think like an artist, develop like an artisan.","link":"https://tridiamond.tech/","label":"links-badge-vip"},{"nick":"LuiYang的博客","avatar":"https://luiyang08.github.io/img/head.jpg","description":"与其临渊羡鱼，不如退而结网！","link":"https://luiyang08.github.io/","label":"links-badge-personal"},{"nick":"依水而安","avatar":"https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/b8d3b3c382fa44e5c92a361d33e0c616_hd.4sew3rxcedq0.jpg","description":"温故而知新","link":"https://yishuihean.cn/","label":"links-badge-personal"},{"nick":"铭心石刻","link":"https://blog.kouseki.cn/","avatar":"https://blog.kouseki.cn/imgs/avatar.webp","description":"愿岁并谢，与友长兮","siteshot":"https://blog.kouseki.cn/imgs/siteshot.webp","label":"links-badge-personal"},{"nick":"微笑工房","link":"https://smilin.net","avatar":"https://smilin.net/img/avatar.png","description":"Code · Thinking · ACG","siteshot":"https://blog.kouseki.cn/imgs/siteshot.webp","label":"links-badge-personal"},{"nick":"青桔气球","link":"https://blog.qjqq.cn/","avatar":"https://avatar.qjqq.cn/1/6503bb1b7fa1a.webp!avatar","description":"分享网络安全与科技生活","siteshot":"https://www.qingjuqiqiu.com/img/siteshot.jpg","label":"links-badge-designer"},{"nick":"一只程序猿","link":"https://www.yizhicheng.com/","avatar":"https://www.yizhicheng.com/img/avatar.jpg","description":"一个程序猿的日常","siteshot":"https://www.yizhicheng.com/img/siteshot.jpg","label":"links-badge-tech"}],"_content":"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/qexo-friends/friends.css\"/>\n</head>\n<body>\n  <div id=\"qexo-friends\"></div>\n</body>\n</html>\n\n<script src=\"https://cdn.jsdelivr.net/npm/qexo-static@1.6.0/hexo/friends.js\"></script>\n<script>loadQexoFriends(\"qexo-friends\", \"https://qexohexoblog.vercel.app\")</script>\n\n:::tip Hello\n# 添加友链格式\n这里是zmc的博客，欢迎各位大佬光临！\n来访的朋友，你好！这里是我的友链页面，欢迎来交换友链哦！\n- 博客名称：好名字都是狗起的\n- 博客简介：古来圣贤皆寂寞，惟有饮者留其名。\n- 博客地址：https://hexo-git-test-3309446352s-projects.vercel.app/ or https://3309446352.github.io/\n- 头像地址：https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\n- 交换方式：在下方的gitalk留言板留言即可！\n\n:::\n\n\n\n","source":"links/index.md","raw":"---\ntitle: links\ndate: 2024-03-19 15:22:44\ntype: friends\ncategoryMode: fasle #用于控制友链展示的格式，true 就是把友链按 label 分类展示，false 就是都在一起展示\ndata:\n  - nick: 三钻\n    avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\n    description: Think like an artist, develop like an artisan.\n    link: https://tridiamond.tech/\n    label: links-badge-vip\n  - nick: LuiYang的博客\n    avatar: https://luiyang08.github.io/img/head.jpg\n    description: 与其临渊羡鱼，不如退而结网！\n    link: https://luiyang08.github.io/\n    label: links-badge-personal\n  - nick: 依水而安\n    avatar: https://cdn.staticaly.com/gh/jankin12138/IMG@main/img/b8d3b3c382fa44e5c92a361d33e0c616_hd.4sew3rxcedq0.jpg\n    description: 温故而知新\n    link: https://yishuihean.cn/\n    label: links-badge-personal\n  - nick: 铭心石刻\n    link: https://blog.kouseki.cn/\n    avatar: https://blog.kouseki.cn/imgs/avatar.webp\n    description: 愿岁并谢，与友长兮\n    siteshot: https://blog.kouseki.cn/imgs/siteshot.webp\n    label: links-badge-personal\n  - nick: 微笑工房\n    link: https://smilin.net\n    avatar: https://smilin.net/img/avatar.png\n    description: Code · Thinking · ACG\n    siteshot: https://blog.kouseki.cn/imgs/siteshot.webp\n    label: links-badge-personal\n  - nick: 青桔气球\n    link: https://blog.qjqq.cn/\n    avatar: https://avatar.qjqq.cn/1/6503bb1b7fa1a.webp!avatar\n    description: 分享网络安全与科技生活\n    siteshot: https://www.qingjuqiqiu.com/img/siteshot.jpg\n    label: links-badge-designer\n  - nick: 一只程序猿\n    link: https://www.yizhicheng.com/\n    avatar: https://www.yizhicheng.com/img/avatar.jpg\n    description: 一个程序猿的日常\n    siteshot: https://www.yizhicheng.com/img/siteshot.jpg\n    label: links-badge-tech\n---\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/qexo-friends/friends.css\"/>\n</head>\n<body>\n  <div id=\"qexo-friends\"></div>\n</body>\n</html>\n\n<script src=\"https://cdn.jsdelivr.net/npm/qexo-static@1.6.0/hexo/friends.js\"></script>\n<script>loadQexoFriends(\"qexo-friends\", \"https://qexohexoblog.vercel.app\")</script>\n\n:::tip Hello\n# 添加友链格式\n这里是zmc的博客，欢迎各位大佬光临！\n来访的朋友，你好！这里是我的友链页面，欢迎来交换友链哦！\n- 博客名称：好名字都是狗起的\n- 博客简介：古来圣贤皆寂寞，惟有饮者留其名。\n- 博客地址：https://hexo-git-test-3309446352s-projects.vercel.app/ or https://3309446352.github.io/\n- 头像地址：https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\n- 交换方式：在下方的gitalk留言板留言即可！\n\n:::\n\n\n\n","updated":"2024-03-24T16:16:06.561Z","path":"links/index.html","comments":1,"layout":"page","_id":"clu74rgxe0008iou2dv4lhy9p","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/qexo-friends/friends.css\"/>\n</head>\n<body>\n  <div id=\"qexo-friends\"></div>\n</body>\n</html>\n\n<script src=\"https://cdn.jsdelivr.net/npm/qexo-static@1.6.0/hexo/friends.js\"></script>\n<script>loadQexoFriends(\"qexo-friends\", \"https://qexohexoblog.vercel.app\")</script>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">Hello</p>\n<p><h1 id=\"添加友链格式\"><a href=\"#添加友链格式\" class=\"headerlink\" title=\"添加友链格式\"></a>添加友链格式</h1><p>这里是zmc的博客，欢迎各位大佬光临！<br>来访的朋友，你好！这里是我的友链页面，欢迎来交换友链哦！</p>\n<ul>\n<li>博客名称：好名字都是狗起的</li>\n<li>博客简介：古来圣贤皆寂寞，惟有饮者留其名。</li>\n<li>博客地址：<a href=\"https://hexo-git-test-3309446352s-projects.vercel.app/\">https://hexo-git-test-3309446352s-projects.vercel.app/</a> or <a href=\"https://3309446352.github.io/\">https://3309446352.github.io/</a></li>\n<li>头像地址：<a href=\"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\">https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg</a></li>\n<li>交换方式：在下方的gitalk留言板留言即可！</li>\n</ul>\n</p>\n</div>\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/qexo-friends/friends.css\"/>\n</head>\n<body>\n  <div id=\"qexo-friends\"></div>\n</body>\n</html>\n\n<script src=\"https://cdn.jsdelivr.net/npm/qexo-static@1.6.0/hexo/friends.js\"></script>\n<script>loadQexoFriends(\"qexo-friends\", \"https://qexohexoblog.vercel.app\")</script>\n\n<p>:::tip Hello</p>\n<h1 id=\"添加友链格式\"><a href=\"#添加友链格式\" class=\"headerlink\" title=\"添加友链格式\"></a>添加友链格式</h1><p>这里是zmc的博客，欢迎各位大佬光临！<br>来访的朋友，你好！这里是我的友链页面，欢迎来交换友链哦！</p>\n<ul>\n<li>博客名称：好名字都是狗起的</li>\n<li>博客简介：古来圣贤皆寂寞，惟有饮者留其名。</li>\n<li>博客地址：<a href=\"https://hexo-git-test-3309446352s-projects.vercel.app/\">https://hexo-git-test-3309446352s-projects.vercel.app/</a> or <a href=\"https://3309446352.github.io/\">https://3309446352.github.io/</a></li>\n<li>头像地址：<a href=\"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\">https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg</a></li>\n<li>交换方式：在下方的gitalk留言板留言即可！</li>\n</ul>\n<p>:::</p>\n"},{"title":"message-board","date":"2024-03-19T07:08:17.000Z","tags":"message-board","favicon":"favicon.ico","_content":"# 留言板\n## 感谢我的朋友\n```","source":"message-board/index.md","raw":"---\ntitle: message-board\ndate: 2024-03-19 15:08:17\ntags: message-board\nfavicon: favicon.ico\n---\n# 留言板\n## 感谢我的朋友\n```","updated":"2024-03-19T18:20:08.052Z","path":"message-board/index.html","comments":1,"layout":"page","_id":"clu74rgxg000aiou29i15auri","content":"<h1 id=\"留言板\"><a href=\"#留言板\" class=\"headerlink\" title=\"留言板\"></a>留言板</h1><h2 id=\"感谢我的朋友\"><a href=\"#感谢我的朋友\" class=\"headerlink\" title=\"感谢我的朋友\"></a>感谢我的朋友</h2><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\"></span></span></code></pre></div>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"留言板\"><a href=\"#留言板\" class=\"headerlink\" title=\"留言板\"></a>留言板</h1><h2 id=\"感谢我的朋友\"><a href=\"#感谢我的朋友\" class=\"headerlink\" title=\"感谢我的朋友\"></a>感谢我的朋友</h2><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\"></span></span></code></pre></div>"}],"Post":[{"abbrlink":"","abstracts":"API（Application Programming Interface，应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。","author":{"avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg","description":"古来圣贤皆寂寞，惟有饮者留其名。","link":"https://hexo-git-test-3309446352s-projects.vercel.app/","name":"好名字都是狗起的","socials":{"github":"https://github.com/3309446352"}},"cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/00057-3939901662.png","date":"2024-03-23T12:39:52.637Z","description":"API（Application Programming Interface，应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。","title":"api","updated":"2024-03-23T13:42:35.405Z","_content":"# 免费api访问网址（不需要注册）\n\n1. 一、教书先生\n   https://api.oioweb.cn/\n2. 二、UomgAPI\n   https://api.uomg.com/\n3. 三、短网址API\n   https://api.d5.nz\n4. 四、韩小韩API\n   https://api.vvhan.com\n5. 五、JSON API免费接口\n   各种提供JSON格式数据返回服务网站的API接口\n6. http://www.bejson.com/knownjson/webInterface/\n7. 六、末日API\n   http://api.weijieyue.cn/#\n8. 七、顾宇API\n   http://47.94.135.214/\n9. 八、free-api\n   https://www.free-api.com/\n10. 免费api接口（需要注册）\n    一、聚合数据\n    https://www.juhe.cn/docs?bd_vid=12366660879320847918\n11. 二、万维易源\n    https://www.showapi.com/?renqun_youhua=259537\n12. 三、极速数据\n    https://www.jisuapi.com/api/?isfree=1\n13. 四、百度AI平台\n    https://ai.baidu.com/\n14. 五、阿里云免费api\n    https://www.aliyun.com/?spm=a2c4e.11155472.1280361.1.3f665d02tWDTRR\n15. 下面分享一些在网上找到的免费API\n    新实时段子\n    https://api.apiopen.top/getJoke?page=1&count=2&type=video\n16. 通过Id查段子\n    https://api.apiopen.top/getSingleJoke?sid=28654780\n17. 快递查询：\n    https://api.apiopen.top/EmailSearch?number=1012002\n18. 随机单句诗词推荐：\n    https://api.apiopen.top/singlePoetry\n19. 随机一首诗词推荐：\n    https://api.apiopen.top/recommendPoetry\n20. 搜索古诗词：\n    https://api.apiopen.top/searchPoetry?name=古风二首%20二\n21. 搜索古诗词作者：\n    https://api.apiopen.top/searchAuthors?name=李白\n22. 模糊搜索古诗词（可搜索诗词名、诗词内容、诗词作者）：\n    https://api.apiopen.top/likePoetry?name=李白\n23. 获取宋朝古诗词：\n    https://api.apiopen.top/getSongPoetry?page=1&count=20\n24. 获取唐朝古诗词：\n    https://api.apiopen.top/getTangPoetry?page=1&count=20\n25. 音乐搜索接口：\n    https://api.apiopen.top/searchMusic?name=不要说话\n26. 音乐电台接口：\n    https://api.apiopen.top/musicBroadcasting\n27. 音乐电台详情接口：\n    https://api.apiopen.top/musicBroadcastingDetails?channelname=public_tuijian_spring\n28. 音乐详情接口：\n    https://api.apiopen.top/musicDetails?id=604392760\n29. 音乐排行榜接口：\n    https://api.apiopen.top/musicRankings\n30. 音乐排行榜详情接口：\n    https://api.apiopen.top/musicRankingsDetails?type=1\n31. 每日视频推荐接口：\n    https://api.apiopen.top/todayVideo\n32. 视频大纲获取接口：\n    https://api.apiopen.top/videoHomeTab\n33. 视频分类推荐接口：\n    https://api.apiopen.top/videoCategory\n34. 视频分类推荐接口：\n    https://api.apiopen.top/videoCategoryDetails?id=14\n35. 根据ID推荐接口：\n    https://api.apiopen.top/videoRecommend?id=127398\n36. 新闻接口：\n    https://www.apiopen.top/journalismApi\n37. 随机推荐热门段子（包含文字、图片、GIF、视频）：\n    https://www.apiopen.top/satinApi?type=1&page=1\n38. 随机推荐热门段子【神评版本】（包含文字、图片、GIF、视频）：\n    https://www.apiopen.top/satinGodApi?type=1&page=1\n39. 随机推荐热门段子【神评版本】评论列表：\n    https://www.apiopen.top/satinCommentApi?id=27610708&page=1\n40. 热门小说推荐列表\n    https://www.apiopen.top/novelApi\n41. 小说搜索接口\n    https://www.apiopen.top/novelSearchApi?name=盗墓笔记\n42. 小说详情接口\n    https://www.apiopen.top/novelInfoApi?name=盗墓笔记\n43. 天气获取接口\n    https://www.apiopen.top/weatherApi?city=成都\n44. 美图获取接口\n    https://www.apiopen.top/meituApi?page=1\n45. 个性网名获取接口\n    https://www.apiopen.top/femaleNameApi?page=1\n46. 创建应用接口\n    https://www.apiopen.top/createUserKey?appId=com.chat.peakchao&passwd=123456\n47. 增加统计信息接口\n    https://www.apiopen.top/addStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5&type=点击统计&typeId=1&count=2\n48. 查询统计信息接口\n    https://www.apiopen.top/findStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5\n49. 用户注册接口\n    https://www.apiopen.top/createUser?key=00d91e8e0cca2b76f515926a36db68f5&phone=13594347817&passwd=123654\n50. 用户登陆接口\n    https://www.apiopen.top/login?key=00d91e8e0cca2b76f515926a36db68f5&phone=13594347817&passwd=123456\n51. 快递查询：\n    https://api.apiopen.top/EmailSearch?number=1012002\n52. 随机单句诗词推荐：\n    https://api.apiopen.top/singlePoetry\n53. 随机一首诗词推荐：\n    https://api.apiopen.top/recommendPoetry\n54. 搜索古诗词：\n    https://api.apiopen.top/searchPoetry?name=古风二首%20二\n55. 搜索古诗词作者：\n    https://api.apiopen.top/searchAuthors?name=李白\n56. 模糊搜索古诗词（可搜索诗词名、诗词内容、诗词作者）：\n    https://api.apiopen.top/likePoetry?name=李白\n57. 获取宋朝古诗词：\n    https://api.apiopen.top/getSongPoetry?page=1&count=20\n58. 获取唐朝古诗词：\n    https://api.apiopen.top/getTangPoetry?page=1&count=20\n59. 新实时段子\n    https://api.apiopen.top/getJoke?page=1&count=2&type=video\n60. 通过Id查段子\n    https://api.apiopen.top/getSingleJoke?sid=28654780\n61. 音乐搜索接口：\n    https://api.apiopen.top/searchMusic?name=不要说话\n62. 音乐电台接口：\n    https://api.apiopen.top/musicBroadcasting\n63. 音乐电台详情接口：\n    https://api.apiopen.top/musicBroadcastingDetails?channelname=public_tuijian_spring\n64. 音乐详情接口：\n    https://api.apiopen.top/musicDetails?id=604392760\n65. 音乐排行榜接口：\n    https://api.apiopen.top/musicRankings\n66. 音乐排行榜详情接口：\n    https://api.apiopen.top/musicRankingsDetails?type=1\n67. 每日视频推荐接口：\n    https://api.apiopen.top/todayVideo\n68. 视频大纲获取接口：\n    https://api.apiopen.top/videoHomeTab\n69. 视频分类推荐接口：\n    https://api.apiopen.top/videoCategory\n70. 视频分类推荐接口：\n    https://api.apiopen.top/videoCategoryDetails?id=14\n71. 根据ID推荐接口：\n    https://api.apiopen.top/videoRecommend?id=127398\n\n# 其他参考：\n\nhttps://segmentfault.com/a/1190000017047048?utm_source=tag-newest\n\nhttps://api.aa1.cn/\n\n# 以上来自 [API 接口大全 | 小笨猴 (nonoas.top)](https://www.nonoas.top/archives/apishare)\n","source":"_posts/Api接口大全.md","raw":"---\nabbrlink: ''\nabstracts: API（Application Programming Interface，应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。\nauthor:\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\n  description: 古来圣贤皆寂寞，惟有饮者留其名。\n  link: https://hexo-git-test-3309446352s-projects.vercel.app/\n  name: 好名字都是狗起的\n  socials:\n    github: https://github.com/3309446352\ncategories: []\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/00057-3939901662.png\ndate: '2024-03-23T20:39:52.637845+08:00'\ndescription: API（Application Programming Interface，应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。\ntags: []\ntitle: api\nupdated: '2024-03-23T21:42:35.405+08:00'\n---\n# 免费api访问网址（不需要注册）\n\n1. 一、教书先生\n   https://api.oioweb.cn/\n2. 二、UomgAPI\n   https://api.uomg.com/\n3. 三、短网址API\n   https://api.d5.nz\n4. 四、韩小韩API\n   https://api.vvhan.com\n5. 五、JSON API免费接口\n   各种提供JSON格式数据返回服务网站的API接口\n6. http://www.bejson.com/knownjson/webInterface/\n7. 六、末日API\n   http://api.weijieyue.cn/#\n8. 七、顾宇API\n   http://47.94.135.214/\n9. 八、free-api\n   https://www.free-api.com/\n10. 免费api接口（需要注册）\n    一、聚合数据\n    https://www.juhe.cn/docs?bd_vid=12366660879320847918\n11. 二、万维易源\n    https://www.showapi.com/?renqun_youhua=259537\n12. 三、极速数据\n    https://www.jisuapi.com/api/?isfree=1\n13. 四、百度AI平台\n    https://ai.baidu.com/\n14. 五、阿里云免费api\n    https://www.aliyun.com/?spm=a2c4e.11155472.1280361.1.3f665d02tWDTRR\n15. 下面分享一些在网上找到的免费API\n    新实时段子\n    https://api.apiopen.top/getJoke?page=1&count=2&type=video\n16. 通过Id查段子\n    https://api.apiopen.top/getSingleJoke?sid=28654780\n17. 快递查询：\n    https://api.apiopen.top/EmailSearch?number=1012002\n18. 随机单句诗词推荐：\n    https://api.apiopen.top/singlePoetry\n19. 随机一首诗词推荐：\n    https://api.apiopen.top/recommendPoetry\n20. 搜索古诗词：\n    https://api.apiopen.top/searchPoetry?name=古风二首%20二\n21. 搜索古诗词作者：\n    https://api.apiopen.top/searchAuthors?name=李白\n22. 模糊搜索古诗词（可搜索诗词名、诗词内容、诗词作者）：\n    https://api.apiopen.top/likePoetry?name=李白\n23. 获取宋朝古诗词：\n    https://api.apiopen.top/getSongPoetry?page=1&count=20\n24. 获取唐朝古诗词：\n    https://api.apiopen.top/getTangPoetry?page=1&count=20\n25. 音乐搜索接口：\n    https://api.apiopen.top/searchMusic?name=不要说话\n26. 音乐电台接口：\n    https://api.apiopen.top/musicBroadcasting\n27. 音乐电台详情接口：\n    https://api.apiopen.top/musicBroadcastingDetails?channelname=public_tuijian_spring\n28. 音乐详情接口：\n    https://api.apiopen.top/musicDetails?id=604392760\n29. 音乐排行榜接口：\n    https://api.apiopen.top/musicRankings\n30. 音乐排行榜详情接口：\n    https://api.apiopen.top/musicRankingsDetails?type=1\n31. 每日视频推荐接口：\n    https://api.apiopen.top/todayVideo\n32. 视频大纲获取接口：\n    https://api.apiopen.top/videoHomeTab\n33. 视频分类推荐接口：\n    https://api.apiopen.top/videoCategory\n34. 视频分类推荐接口：\n    https://api.apiopen.top/videoCategoryDetails?id=14\n35. 根据ID推荐接口：\n    https://api.apiopen.top/videoRecommend?id=127398\n36. 新闻接口：\n    https://www.apiopen.top/journalismApi\n37. 随机推荐热门段子（包含文字、图片、GIF、视频）：\n    https://www.apiopen.top/satinApi?type=1&page=1\n38. 随机推荐热门段子【神评版本】（包含文字、图片、GIF、视频）：\n    https://www.apiopen.top/satinGodApi?type=1&page=1\n39. 随机推荐热门段子【神评版本】评论列表：\n    https://www.apiopen.top/satinCommentApi?id=27610708&page=1\n40. 热门小说推荐列表\n    https://www.apiopen.top/novelApi\n41. 小说搜索接口\n    https://www.apiopen.top/novelSearchApi?name=盗墓笔记\n42. 小说详情接口\n    https://www.apiopen.top/novelInfoApi?name=盗墓笔记\n43. 天气获取接口\n    https://www.apiopen.top/weatherApi?city=成都\n44. 美图获取接口\n    https://www.apiopen.top/meituApi?page=1\n45. 个性网名获取接口\n    https://www.apiopen.top/femaleNameApi?page=1\n46. 创建应用接口\n    https://www.apiopen.top/createUserKey?appId=com.chat.peakchao&passwd=123456\n47. 增加统计信息接口\n    https://www.apiopen.top/addStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5&type=点击统计&typeId=1&count=2\n48. 查询统计信息接口\n    https://www.apiopen.top/findStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5\n49. 用户注册接口\n    https://www.apiopen.top/createUser?key=00d91e8e0cca2b76f515926a36db68f5&phone=13594347817&passwd=123654\n50. 用户登陆接口\n    https://www.apiopen.top/login?key=00d91e8e0cca2b76f515926a36db68f5&phone=13594347817&passwd=123456\n51. 快递查询：\n    https://api.apiopen.top/EmailSearch?number=1012002\n52. 随机单句诗词推荐：\n    https://api.apiopen.top/singlePoetry\n53. 随机一首诗词推荐：\n    https://api.apiopen.top/recommendPoetry\n54. 搜索古诗词：\n    https://api.apiopen.top/searchPoetry?name=古风二首%20二\n55. 搜索古诗词作者：\n    https://api.apiopen.top/searchAuthors?name=李白\n56. 模糊搜索古诗词（可搜索诗词名、诗词内容、诗词作者）：\n    https://api.apiopen.top/likePoetry?name=李白\n57. 获取宋朝古诗词：\n    https://api.apiopen.top/getSongPoetry?page=1&count=20\n58. 获取唐朝古诗词：\n    https://api.apiopen.top/getTangPoetry?page=1&count=20\n59. 新实时段子\n    https://api.apiopen.top/getJoke?page=1&count=2&type=video\n60. 通过Id查段子\n    https://api.apiopen.top/getSingleJoke?sid=28654780\n61. 音乐搜索接口：\n    https://api.apiopen.top/searchMusic?name=不要说话\n62. 音乐电台接口：\n    https://api.apiopen.top/musicBroadcasting\n63. 音乐电台详情接口：\n    https://api.apiopen.top/musicBroadcastingDetails?channelname=public_tuijian_spring\n64. 音乐详情接口：\n    https://api.apiopen.top/musicDetails?id=604392760\n65. 音乐排行榜接口：\n    https://api.apiopen.top/musicRankings\n66. 音乐排行榜详情接口：\n    https://api.apiopen.top/musicRankingsDetails?type=1\n67. 每日视频推荐接口：\n    https://api.apiopen.top/todayVideo\n68. 视频大纲获取接口：\n    https://api.apiopen.top/videoHomeTab\n69. 视频分类推荐接口：\n    https://api.apiopen.top/videoCategory\n70. 视频分类推荐接口：\n    https://api.apiopen.top/videoCategoryDetails?id=14\n71. 根据ID推荐接口：\n    https://api.apiopen.top/videoRecommend?id=127398\n\n# 其他参考：\n\nhttps://segmentfault.com/a/1190000017047048?utm_source=tag-newest\n\nhttps://api.aa1.cn/\n\n# 以上来自 [API 接口大全 | 小笨猴 (nonoas.top)](https://www.nonoas.top/archives/apishare)\n","slug":"Api接口大全","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgx50001iou2hkpj2rra","content":"<h1 id=\"免费api访问网址（不需要注册）\"><a href=\"#免费api访问网址（不需要注册）\" class=\"headerlink\" title=\"免费api访问网址（不需要注册）\"></a>免费api访问网址（不需要注册）</h1><ol>\n<li>一、教书先生<br><a href=\"https://api.oioweb.cn/\">https://api.oioweb.cn/</a></li>\n<li>二、UomgAPI<br><a href=\"https://api.uomg.com/\">https://api.uomg.com/</a></li>\n<li>三、短网址API<br><a href=\"https://api.d5.nz/\">https://api.d5.nz</a></li>\n<li>四、韩小韩API<br><a href=\"https://api.vvhan.com/\">https://api.vvhan.com</a></li>\n<li>五、JSON API免费接口<br>各种提供JSON格式数据返回服务网站的API接口</li>\n<li><a href=\"http://www.bejson.com/knownjson/webInterface/\">http://www.bejson.com/knownjson/webInterface/</a></li>\n<li>六、末日API<br><a href=\"http://api.weijieyue.cn/#\">http://api.weijieyue.cn/#</a></li>\n<li>七、顾宇API<br><a href=\"http://47.94.135.214/\">http://47.94.135.214/</a></li>\n<li>八、free-api<br><a href=\"https://www.free-api.com/\">https://www.free-api.com/</a></li>\n<li>免费api接口（需要注册）<br>一、聚合数据<br><a href=\"https://www.juhe.cn/docs?bd_vid=12366660879320847918\">https://www.juhe.cn/docs?bd_vid=12366660879320847918</a></li>\n<li>二、万维易源<br><a href=\"https://www.showapi.com/?renqun_youhua=259537\">https://www.showapi.com/?renqun_youhua=259537</a></li>\n<li>三、极速数据<br><a href=\"https://www.jisuapi.com/api/?isfree=1\">https://www.jisuapi.com/api/?isfree=1</a></li>\n<li>四、百度AI平台<br><a href=\"https://ai.baidu.com/\">https://ai.baidu.com/</a></li>\n<li>五、阿里云免费api<br><a href=\"https://www.aliyun.com/?spm=a2c4e.11155472.1280361.1.3f665d02tWDTRR\">https://www.aliyun.com/?spm=a2c4e.11155472.1280361.1.3f665d02tWDTRR</a></li>\n<li>下面分享一些在网上找到的免费API<br>新实时段子<br><a href=\"https://api.apiopen.top/getJoke?page=1&count=2&type=video\">https://api.apiopen.top/getJoke?page=1&amp;count=2&amp;type=video</a></li>\n<li>通过Id查段子<br><a href=\"https://api.apiopen.top/getSingleJoke?sid=28654780\">https://api.apiopen.top/getSingleJoke?sid=28654780</a></li>\n<li>快递查询：<br><a href=\"https://api.apiopen.top/EmailSearch?number=1012002\">https://api.apiopen.top/EmailSearch?number=1012002</a></li>\n<li>随机单句诗词推荐：<br><a href=\"https://api.apiopen.top/singlePoetry\">https://api.apiopen.top/singlePoetry</a></li>\n<li>随机一首诗词推荐：<br><a href=\"https://api.apiopen.top/recommendPoetry\">https://api.apiopen.top/recommendPoetry</a></li>\n<li>搜索古诗词：<br><a href=\"https://api.apiopen.top/searchPoetry?name=%E5%8F%A4%E9%A3%8E%E4%BA%8C%E9%A6%96%20%E4%BA%8C\">https://api.apiopen.top/searchPoetry?name=古风二首%20二</a></li>\n<li>搜索古诗词作者：<br><a href=\"https://api.apiopen.top/searchAuthors?name=%E6%9D%8E%E7%99%BD\">https://api.apiopen.top/searchAuthors?name=李白</a></li>\n<li>模糊搜索古诗词（可搜索诗词名、诗词内容、诗词作者）：<br><a href=\"https://api.apiopen.top/likePoetry?name=%E6%9D%8E%E7%99%BD\">https://api.apiopen.top/likePoetry?name=李白</a></li>\n<li>获取宋朝古诗词：<br><a href=\"https://api.apiopen.top/getSongPoetry?page=1&count=20\">https://api.apiopen.top/getSongPoetry?page=1&amp;count=20</a></li>\n<li>获取唐朝古诗词：<br><a href=\"https://api.apiopen.top/getTangPoetry?page=1&count=20\">https://api.apiopen.top/getTangPoetry?page=1&amp;count=20</a></li>\n<li>音乐搜索接口：<br><a href=\"https://api.apiopen.top/searchMusic?name=%E4%B8%8D%E8%A6%81%E8%AF%B4%E8%AF%9D\">https://api.apiopen.top/searchMusic?name=不要说话</a></li>\n<li>音乐电台接口：<br><a href=\"https://api.apiopen.top/musicBroadcasting\">https://api.apiopen.top/musicBroadcasting</a></li>\n<li>音乐电台详情接口：<br><a href=\"https://api.apiopen.top/musicBroadcastingDetails?channelname=public_tuijian_spring\">https://api.apiopen.top/musicBroadcastingDetails?channelname=public_tuijian_spring</a></li>\n<li>音乐详情接口：<br><a href=\"https://api.apiopen.top/musicDetails?id=604392760\">https://api.apiopen.top/musicDetails?id=604392760</a></li>\n<li>音乐排行榜接口：<br><a href=\"https://api.apiopen.top/musicRankings\">https://api.apiopen.top/musicRankings</a></li>\n<li>音乐排行榜详情接口：<br><a href=\"https://api.apiopen.top/musicRankingsDetails?type=1\">https://api.apiopen.top/musicRankingsDetails?type=1</a></li>\n<li>每日视频推荐接口：<br><a href=\"https://api.apiopen.top/todayVideo\">https://api.apiopen.top/todayVideo</a></li>\n<li>视频大纲获取接口：<br><a href=\"https://api.apiopen.top/videoHomeTab\">https://api.apiopen.top/videoHomeTab</a></li>\n<li>视频分类推荐接口：<br><a href=\"https://api.apiopen.top/videoCategory\">https://api.apiopen.top/videoCategory</a></li>\n<li>视频分类推荐接口：<br><a href=\"https://api.apiopen.top/videoCategoryDetails?id=14\">https://api.apiopen.top/videoCategoryDetails?id=14</a></li>\n<li>根据ID推荐接口：<br><a href=\"https://api.apiopen.top/videoRecommend?id=127398\">https://api.apiopen.top/videoRecommend?id=127398</a></li>\n<li>新闻接口：<br><a href=\"https://www.apiopen.top/journalismApi\">https://www.apiopen.top/journalismApi</a></li>\n<li>随机推荐热门段子（包含文字、图片、GIF、视频）：<br><a href=\"https://www.apiopen.top/satinApi?type=1&page=1\">https://www.apiopen.top/satinApi?type=1&amp;page=1</a></li>\n<li>随机推荐热门段子【神评版本】（包含文字、图片、GIF、视频）：<br><a href=\"https://www.apiopen.top/satinGodApi?type=1&page=1\">https://www.apiopen.top/satinGodApi?type=1&amp;page=1</a></li>\n<li>随机推荐热门段子【神评版本】评论列表：<br><a href=\"https://www.apiopen.top/satinCommentApi?id=27610708&page=1\">https://www.apiopen.top/satinCommentApi?id=27610708&amp;page=1</a></li>\n<li>热门小说推荐列表<br><a href=\"https://www.apiopen.top/novelApi\">https://www.apiopen.top/novelApi</a></li>\n<li>小说搜索接口<br><a href=\"https://www.apiopen.top/novelSearchApi?name=%E7%9B%97%E5%A2%93%E7%AC%94%E8%AE%B0\">https://www.apiopen.top/novelSearchApi?name=盗墓笔记</a></li>\n<li>小说详情接口<br><a href=\"https://www.apiopen.top/novelInfoApi?name=%E7%9B%97%E5%A2%93%E7%AC%94%E8%AE%B0\">https://www.apiopen.top/novelInfoApi?name=盗墓笔记</a></li>\n<li>天气获取接口<br><a href=\"https://www.apiopen.top/weatherApi?city=%E6%88%90%E9%83%BD\">https://www.apiopen.top/weatherApi?city=成都</a></li>\n<li>美图获取接口<br><a href=\"https://www.apiopen.top/meituApi?page=1\">https://www.apiopen.top/meituApi?page=1</a></li>\n<li>个性网名获取接口<br><a href=\"https://www.apiopen.top/femaleNameApi?page=1\">https://www.apiopen.top/femaleNameApi?page=1</a></li>\n<li>创建应用接口<br><a href=\"https://www.apiopen.top/createUserKey?appId=com.chat.peakchao&passwd=123456\">https://www.apiopen.top/createUserKey?appId=com.chat.peakchao&amp;passwd=123456</a></li>\n<li>增加统计信息接口<br><a href=\"https://www.apiopen.top/addStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5&type=%E7%82%B9%E5%87%BB%E7%BB%9F%E8%AE%A1&typeId=1&count=2\">https://www.apiopen.top/addStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5&amp;type=点击统计&amp;typeId=1&amp;count=2</a></li>\n<li>查询统计信息接口<br><a href=\"https://www.apiopen.top/findStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5\">https://www.apiopen.top/findStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5</a></li>\n<li>用户注册接口<br><a href=\"https://www.apiopen.top/createUser?key=00d91e8e0cca2b76f515926a36db68f5&phone=13594347817&passwd=123654\">https://www.apiopen.top/createUser?key=00d91e8e0cca2b76f515926a36db68f5&amp;phone=13594347817&amp;passwd=123654</a></li>\n<li>用户登陆接口<br><a href=\"https://www.apiopen.top/login?key=00d91e8e0cca2b76f515926a36db68f5&phone=13594347817&passwd=123456\">https://www.apiopen.top/login?key=00d91e8e0cca2b76f515926a36db68f5&amp;phone=13594347817&amp;passwd=123456</a></li>\n<li>快递查询：<br><a href=\"https://api.apiopen.top/EmailSearch?number=1012002\">https://api.apiopen.top/EmailSearch?number=1012002</a></li>\n<li>随机单句诗词推荐：<br><a href=\"https://api.apiopen.top/singlePoetry\">https://api.apiopen.top/singlePoetry</a></li>\n<li>随机一首诗词推荐：<br><a href=\"https://api.apiopen.top/recommendPoetry\">https://api.apiopen.top/recommendPoetry</a></li>\n<li>搜索古诗词：<br><a href=\"https://api.apiopen.top/searchPoetry?name=%E5%8F%A4%E9%A3%8E%E4%BA%8C%E9%A6%96%20%E4%BA%8C\">https://api.apiopen.top/searchPoetry?name=古风二首%20二</a></li>\n<li>搜索古诗词作者：<br><a href=\"https://api.apiopen.top/searchAuthors?name=%E6%9D%8E%E7%99%BD\">https://api.apiopen.top/searchAuthors?name=李白</a></li>\n<li>模糊搜索古诗词（可搜索诗词名、诗词内容、诗词作者）：<br><a href=\"https://api.apiopen.top/likePoetry?name=%E6%9D%8E%E7%99%BD\">https://api.apiopen.top/likePoetry?name=李白</a></li>\n<li>获取宋朝古诗词：<br><a href=\"https://api.apiopen.top/getSongPoetry?page=1&count=20\">https://api.apiopen.top/getSongPoetry?page=1&amp;count=20</a></li>\n<li>获取唐朝古诗词：<br><a href=\"https://api.apiopen.top/getTangPoetry?page=1&count=20\">https://api.apiopen.top/getTangPoetry?page=1&amp;count=20</a></li>\n<li>新实时段子<br><a href=\"https://api.apiopen.top/getJoke?page=1&count=2&type=video\">https://api.apiopen.top/getJoke?page=1&amp;count=2&amp;type=video</a></li>\n<li>通过Id查段子<br><a href=\"https://api.apiopen.top/getSingleJoke?sid=28654780\">https://api.apiopen.top/getSingleJoke?sid=28654780</a></li>\n<li>音乐搜索接口：<br><a href=\"https://api.apiopen.top/searchMusic?name=%E4%B8%8D%E8%A6%81%E8%AF%B4%E8%AF%9D\">https://api.apiopen.top/searchMusic?name=不要说话</a></li>\n<li>音乐电台接口：<br><a href=\"https://api.apiopen.top/musicBroadcasting\">https://api.apiopen.top/musicBroadcasting</a></li>\n<li>音乐电台详情接口：<br><a href=\"https://api.apiopen.top/musicBroadcastingDetails?channelname=public_tuijian_spring\">https://api.apiopen.top/musicBroadcastingDetails?channelname=public_tuijian_spring</a></li>\n<li>音乐详情接口：<br><a href=\"https://api.apiopen.top/musicDetails?id=604392760\">https://api.apiopen.top/musicDetails?id=604392760</a></li>\n<li>音乐排行榜接口：<br><a href=\"https://api.apiopen.top/musicRankings\">https://api.apiopen.top/musicRankings</a></li>\n<li>音乐排行榜详情接口：<br><a href=\"https://api.apiopen.top/musicRankingsDetails?type=1\">https://api.apiopen.top/musicRankingsDetails?type=1</a></li>\n<li>每日视频推荐接口：<br><a href=\"https://api.apiopen.top/todayVideo\">https://api.apiopen.top/todayVideo</a></li>\n<li>视频大纲获取接口：<br><a href=\"https://api.apiopen.top/videoHomeTab\">https://api.apiopen.top/videoHomeTab</a></li>\n<li>视频分类推荐接口：<br><a href=\"https://api.apiopen.top/videoCategory\">https://api.apiopen.top/videoCategory</a></li>\n<li>视频分类推荐接口：<br><a href=\"https://api.apiopen.top/videoCategoryDetails?id=14\">https://api.apiopen.top/videoCategoryDetails?id=14</a></li>\n<li>根据ID推荐接口：<br><a href=\"https://api.apiopen.top/videoRecommend?id=127398\">https://api.apiopen.top/videoRecommend?id=127398</a></li>\n</ol>\n<h1 id=\"其他参考：\"><a href=\"#其他参考：\" class=\"headerlink\" title=\"其他参考：\"></a>其他参考：</h1><p><a href=\"https://segmentfault.com/a/1190000017047048?utm_source=tag-newest\">https://segmentfault.com/a/1190000017047048?utm_source=tag-newest</a></p>\n<p><a href=\"https://api.aa1.cn/\">https://api.aa1.cn/</a></p>\n<h1 id=\"以上来自-API-接口大全-小笨猴-nonoas-top\"><a href=\"#以上来自-API-接口大全-小笨猴-nonoas-top\" class=\"headerlink\" title=\"以上来自 API 接口大全 | 小笨猴 (nonoas.top)\"></a>以上来自 <a href=\"https://www.nonoas.top/archives/apishare\">API 接口大全 | 小笨猴 (nonoas.top)</a></h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"免费api访问网址（不需要注册）\"><a href=\"#免费api访问网址（不需要注册）\" class=\"headerlink\" title=\"免费api访问网址（不需要注册）\"></a>免费api访问网址（不需要注册）</h1><ol>\n<li>一、教书先生<br><a href=\"https://api.oioweb.cn/\">https://api.oioweb.cn/</a></li>\n<li>二、UomgAPI<br><a href=\"https://api.uomg.com/\">https://api.uomg.com/</a></li>\n<li>三、短网址API<br><a href=\"https://api.d5.nz/\">https://api.d5.nz</a></li>\n<li>四、韩小韩API<br><a href=\"https://api.vvhan.com/\">https://api.vvhan.com</a></li>\n<li>五、JSON API免费接口<br>各种提供JSON格式数据返回服务网站的API接口</li>\n<li><a href=\"http://www.bejson.com/knownjson/webInterface/\">http://www.bejson.com/knownjson/webInterface/</a></li>\n<li>六、末日API<br><a href=\"http://api.weijieyue.cn/#\">http://api.weijieyue.cn/#</a></li>\n<li>七、顾宇API<br><a href=\"http://47.94.135.214/\">http://47.94.135.214/</a></li>\n<li>八、free-api<br><a href=\"https://www.free-api.com/\">https://www.free-api.com/</a></li>\n<li>免费api接口（需要注册）<br>一、聚合数据<br><a href=\"https://www.juhe.cn/docs?bd_vid=12366660879320847918\">https://www.juhe.cn/docs?bd_vid=12366660879320847918</a></li>\n<li>二、万维易源<br><a href=\"https://www.showapi.com/?renqun_youhua=259537\">https://www.showapi.com/?renqun_youhua=259537</a></li>\n<li>三、极速数据<br><a href=\"https://www.jisuapi.com/api/?isfree=1\">https://www.jisuapi.com/api/?isfree=1</a></li>\n<li>四、百度AI平台<br><a href=\"https://ai.baidu.com/\">https://ai.baidu.com/</a></li>\n<li>五、阿里云免费api<br><a href=\"https://www.aliyun.com/?spm=a2c4e.11155472.1280361.1.3f665d02tWDTRR\">https://www.aliyun.com/?spm=a2c4e.11155472.1280361.1.3f665d02tWDTRR</a></li>\n<li>下面分享一些在网上找到的免费API<br>新实时段子<br><a href=\"https://api.apiopen.top/getJoke?page=1&count=2&type=video\">https://api.apiopen.top/getJoke?page=1&amp;count=2&amp;type=video</a></li>\n<li>通过Id查段子<br><a href=\"https://api.apiopen.top/getSingleJoke?sid=28654780\">https://api.apiopen.top/getSingleJoke?sid=28654780</a></li>\n<li>快递查询：<br><a href=\"https://api.apiopen.top/EmailSearch?number=1012002\">https://api.apiopen.top/EmailSearch?number=1012002</a></li>\n<li>随机单句诗词推荐：<br><a href=\"https://api.apiopen.top/singlePoetry\">https://api.apiopen.top/singlePoetry</a></li>\n<li>随机一首诗词推荐：<br><a href=\"https://api.apiopen.top/recommendPoetry\">https://api.apiopen.top/recommendPoetry</a></li>\n<li>搜索古诗词：<br><a href=\"https://api.apiopen.top/searchPoetry?name=%E5%8F%A4%E9%A3%8E%E4%BA%8C%E9%A6%96%20%E4%BA%8C\">https://api.apiopen.top/searchPoetry?name=古风二首%20二</a></li>\n<li>搜索古诗词作者：<br><a href=\"https://api.apiopen.top/searchAuthors?name=%E6%9D%8E%E7%99%BD\">https://api.apiopen.top/searchAuthors?name=李白</a></li>\n<li>模糊搜索古诗词（可搜索诗词名、诗词内容、诗词作者）：<br><a href=\"https://api.apiopen.top/likePoetry?name=%E6%9D%8E%E7%99%BD\">https://api.apiopen.top/likePoetry?name=李白</a></li>\n<li>获取宋朝古诗词：<br><a href=\"https://api.apiopen.top/getSongPoetry?page=1&count=20\">https://api.apiopen.top/getSongPoetry?page=1&amp;count=20</a></li>\n<li>获取唐朝古诗词：<br><a href=\"https://api.apiopen.top/getTangPoetry?page=1&count=20\">https://api.apiopen.top/getTangPoetry?page=1&amp;count=20</a></li>\n<li>音乐搜索接口：<br><a href=\"https://api.apiopen.top/searchMusic?name=%E4%B8%8D%E8%A6%81%E8%AF%B4%E8%AF%9D\">https://api.apiopen.top/searchMusic?name=不要说话</a></li>\n<li>音乐电台接口：<br><a href=\"https://api.apiopen.top/musicBroadcasting\">https://api.apiopen.top/musicBroadcasting</a></li>\n<li>音乐电台详情接口：<br><a href=\"https://api.apiopen.top/musicBroadcastingDetails?channelname=public_tuijian_spring\">https://api.apiopen.top/musicBroadcastingDetails?channelname=public_tuijian_spring</a></li>\n<li>音乐详情接口：<br><a href=\"https://api.apiopen.top/musicDetails?id=604392760\">https://api.apiopen.top/musicDetails?id=604392760</a></li>\n<li>音乐排行榜接口：<br><a href=\"https://api.apiopen.top/musicRankings\">https://api.apiopen.top/musicRankings</a></li>\n<li>音乐排行榜详情接口：<br><a href=\"https://api.apiopen.top/musicRankingsDetails?type=1\">https://api.apiopen.top/musicRankingsDetails?type=1</a></li>\n<li>每日视频推荐接口：<br><a href=\"https://api.apiopen.top/todayVideo\">https://api.apiopen.top/todayVideo</a></li>\n<li>视频大纲获取接口：<br><a href=\"https://api.apiopen.top/videoHomeTab\">https://api.apiopen.top/videoHomeTab</a></li>\n<li>视频分类推荐接口：<br><a href=\"https://api.apiopen.top/videoCategory\">https://api.apiopen.top/videoCategory</a></li>\n<li>视频分类推荐接口：<br><a href=\"https://api.apiopen.top/videoCategoryDetails?id=14\">https://api.apiopen.top/videoCategoryDetails?id=14</a></li>\n<li>根据ID推荐接口：<br><a href=\"https://api.apiopen.top/videoRecommend?id=127398\">https://api.apiopen.top/videoRecommend?id=127398</a></li>\n<li>新闻接口：<br><a href=\"https://www.apiopen.top/journalismApi\">https://www.apiopen.top/journalismApi</a></li>\n<li>随机推荐热门段子（包含文字、图片、GIF、视频）：<br><a href=\"https://www.apiopen.top/satinApi?type=1&page=1\">https://www.apiopen.top/satinApi?type=1&amp;page=1</a></li>\n<li>随机推荐热门段子【神评版本】（包含文字、图片、GIF、视频）：<br><a href=\"https://www.apiopen.top/satinGodApi?type=1&page=1\">https://www.apiopen.top/satinGodApi?type=1&amp;page=1</a></li>\n<li>随机推荐热门段子【神评版本】评论列表：<br><a href=\"https://www.apiopen.top/satinCommentApi?id=27610708&page=1\">https://www.apiopen.top/satinCommentApi?id=27610708&amp;page=1</a></li>\n<li>热门小说推荐列表<br><a href=\"https://www.apiopen.top/novelApi\">https://www.apiopen.top/novelApi</a></li>\n<li>小说搜索接口<br><a href=\"https://www.apiopen.top/novelSearchApi?name=%E7%9B%97%E5%A2%93%E7%AC%94%E8%AE%B0\">https://www.apiopen.top/novelSearchApi?name=盗墓笔记</a></li>\n<li>小说详情接口<br><a href=\"https://www.apiopen.top/novelInfoApi?name=%E7%9B%97%E5%A2%93%E7%AC%94%E8%AE%B0\">https://www.apiopen.top/novelInfoApi?name=盗墓笔记</a></li>\n<li>天气获取接口<br><a href=\"https://www.apiopen.top/weatherApi?city=%E6%88%90%E9%83%BD\">https://www.apiopen.top/weatherApi?city=成都</a></li>\n<li>美图获取接口<br><a href=\"https://www.apiopen.top/meituApi?page=1\">https://www.apiopen.top/meituApi?page=1</a></li>\n<li>个性网名获取接口<br><a href=\"https://www.apiopen.top/femaleNameApi?page=1\">https://www.apiopen.top/femaleNameApi?page=1</a></li>\n<li>创建应用接口<br><a href=\"https://www.apiopen.top/createUserKey?appId=com.chat.peakchao&passwd=123456\">https://www.apiopen.top/createUserKey?appId=com.chat.peakchao&amp;passwd=123456</a></li>\n<li>增加统计信息接口<br><a href=\"https://www.apiopen.top/addStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5&type=%E7%82%B9%E5%87%BB%E7%BB%9F%E8%AE%A1&typeId=1&count=2\">https://www.apiopen.top/addStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5&amp;type=点击统计&amp;typeId=1&amp;count=2</a></li>\n<li>查询统计信息接口<br><a href=\"https://www.apiopen.top/findStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5\">https://www.apiopen.top/findStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5</a></li>\n<li>用户注册接口<br><a href=\"https://www.apiopen.top/createUser?key=00d91e8e0cca2b76f515926a36db68f5&phone=13594347817&passwd=123654\">https://www.apiopen.top/createUser?key=00d91e8e0cca2b76f515926a36db68f5&amp;phone=13594347817&amp;passwd=123654</a></li>\n<li>用户登陆接口<br><a href=\"https://www.apiopen.top/login?key=00d91e8e0cca2b76f515926a36db68f5&phone=13594347817&passwd=123456\">https://www.apiopen.top/login?key=00d91e8e0cca2b76f515926a36db68f5&amp;phone=13594347817&amp;passwd=123456</a></li>\n<li>快递查询：<br><a href=\"https://api.apiopen.top/EmailSearch?number=1012002\">https://api.apiopen.top/EmailSearch?number=1012002</a></li>\n<li>随机单句诗词推荐：<br><a href=\"https://api.apiopen.top/singlePoetry\">https://api.apiopen.top/singlePoetry</a></li>\n<li>随机一首诗词推荐：<br><a href=\"https://api.apiopen.top/recommendPoetry\">https://api.apiopen.top/recommendPoetry</a></li>\n<li>搜索古诗词：<br><a href=\"https://api.apiopen.top/searchPoetry?name=%E5%8F%A4%E9%A3%8E%E4%BA%8C%E9%A6%96%20%E4%BA%8C\">https://api.apiopen.top/searchPoetry?name=古风二首%20二</a></li>\n<li>搜索古诗词作者：<br><a href=\"https://api.apiopen.top/searchAuthors?name=%E6%9D%8E%E7%99%BD\">https://api.apiopen.top/searchAuthors?name=李白</a></li>\n<li>模糊搜索古诗词（可搜索诗词名、诗词内容、诗词作者）：<br><a href=\"https://api.apiopen.top/likePoetry?name=%E6%9D%8E%E7%99%BD\">https://api.apiopen.top/likePoetry?name=李白</a></li>\n<li>获取宋朝古诗词：<br><a href=\"https://api.apiopen.top/getSongPoetry?page=1&count=20\">https://api.apiopen.top/getSongPoetry?page=1&amp;count=20</a></li>\n<li>获取唐朝古诗词：<br><a href=\"https://api.apiopen.top/getTangPoetry?page=1&count=20\">https://api.apiopen.top/getTangPoetry?page=1&amp;count=20</a></li>\n<li>新实时段子<br><a href=\"https://api.apiopen.top/getJoke?page=1&count=2&type=video\">https://api.apiopen.top/getJoke?page=1&amp;count=2&amp;type=video</a></li>\n<li>通过Id查段子<br><a href=\"https://api.apiopen.top/getSingleJoke?sid=28654780\">https://api.apiopen.top/getSingleJoke?sid=28654780</a></li>\n<li>音乐搜索接口：<br><a href=\"https://api.apiopen.top/searchMusic?name=%E4%B8%8D%E8%A6%81%E8%AF%B4%E8%AF%9D\">https://api.apiopen.top/searchMusic?name=不要说话</a></li>\n<li>音乐电台接口：<br><a href=\"https://api.apiopen.top/musicBroadcasting\">https://api.apiopen.top/musicBroadcasting</a></li>\n<li>音乐电台详情接口：<br><a href=\"https://api.apiopen.top/musicBroadcastingDetails?channelname=public_tuijian_spring\">https://api.apiopen.top/musicBroadcastingDetails?channelname=public_tuijian_spring</a></li>\n<li>音乐详情接口：<br><a href=\"https://api.apiopen.top/musicDetails?id=604392760\">https://api.apiopen.top/musicDetails?id=604392760</a></li>\n<li>音乐排行榜接口：<br><a href=\"https://api.apiopen.top/musicRankings\">https://api.apiopen.top/musicRankings</a></li>\n<li>音乐排行榜详情接口：<br><a href=\"https://api.apiopen.top/musicRankingsDetails?type=1\">https://api.apiopen.top/musicRankingsDetails?type=1</a></li>\n<li>每日视频推荐接口：<br><a href=\"https://api.apiopen.top/todayVideo\">https://api.apiopen.top/todayVideo</a></li>\n<li>视频大纲获取接口：<br><a href=\"https://api.apiopen.top/videoHomeTab\">https://api.apiopen.top/videoHomeTab</a></li>\n<li>视频分类推荐接口：<br><a href=\"https://api.apiopen.top/videoCategory\">https://api.apiopen.top/videoCategory</a></li>\n<li>视频分类推荐接口：<br><a href=\"https://api.apiopen.top/videoCategoryDetails?id=14\">https://api.apiopen.top/videoCategoryDetails?id=14</a></li>\n<li>根据ID推荐接口：<br><a href=\"https://api.apiopen.top/videoRecommend?id=127398\">https://api.apiopen.top/videoRecommend?id=127398</a></li>\n</ol>\n<h1 id=\"其他参考：\"><a href=\"#其他参考：\" class=\"headerlink\" title=\"其他参考：\"></a>其他参考：</h1><p><a href=\"https://segmentfault.com/a/1190000017047048?utm_source=tag-newest\">https://segmentfault.com/a/1190000017047048?utm_source=tag-newest</a></p>\n<p><a href=\"https://api.aa1.cn/\">https://api.aa1.cn/</a></p>\n<h1 id=\"以上来自-API-接口大全-小笨猴-nonoas-top\"><a href=\"#以上来自-API-接口大全-小笨猴-nonoas-top\" class=\"headerlink\" title=\"以上来自 API 接口大全 | 小笨猴 (nonoas.top)\"></a>以上来自 <a href=\"https://www.nonoas.top/archives/apishare\">API 接口大全 | 小笨猴 (nonoas.top)</a></h1>"},{"title":"湖南农民运动考察报告","autor":"Zmc","date":"2024-03-18T16:39:00.000Z","feature":true,"cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/007.jpg","_content":"## 谁是我们的敌人，谁是我们的朋友\n\n第一次国内革命战争时期\n\n​        谁是我们的敌人？谁是我们的朋友？分不清敌人与朋友，必不是个革命分子，要分清敌人与朋友呢，却并不是立场。中国革命且三十年而成效甚少，并不是目的错、完全是策略错。所谓策略错，就是不能团结真正的朋友，以攻击真正的敌人．所以不能如此，乃是未分清谁是敌人谁是朋友。革命党是群众的向导。在军队中，未有他的响导领错了路而可以打胜仗，在革命运动中，未有革命党领错了路而这个革命可以不失败。我们都是革命党，都是给群众领路的人，都是群众的向导。但我们不可不自问一问：我们有这个本领没有？我们不至于领了群众到失败的路上去么？我们可以一定完成功吗？要有：“不错了路”和“一定成功”的把握不可不致谨于一个重要的策略，要决定这个策略，就要分清谁是敌人谁是朋友。国民党第一次全国大会宣言，就是宣告这个策略的决定和敌友的分辨。但这个宣言极其简单。我们要认识这重要的策略，要分辨那真正的敌友，不可不将中国社会各阶级的经济地位，阶级性，人数及其对于革命的态度，作一个大概的分析。\n\n​        无论那一个国内，大概地说，都有三等人，上等、中等、下等。详细分析则有五等，大资产阶级、中产阶级、小资产阶级、半无产阶级、无产阶级。拿农村说：大地主是大资产阶级，小，地主是中产阶级，自耕农是小资产阶级，半自耕佃农是半无产阶级，雇农是无产阶级。拿都市说：大银行家、大商业家、大工业家是大资产阶级、钱庄主、中等商人、小工厂主是中产阶级，小商人、手工业主是小资产阶级，店员小贩手工业工人是半无产阶级，产业工人苦力是无产阶级。五种人各有不同的经济地位，各有不同的阶级性。因此对于现代的革命，乃发生反革命，半反革命，对革命守中立，参加革命和向革命的主力军种种不同的态度。\n\n​        小国各阶级对于民族革命的态度，与西欧资本主义国家的各阶级对社会革命的态度，几乎完全一样。看来好似奇怪，实际并不奇怪。因为现代的革命本是一个，其目的与手段均相同，即同以打倒国际资本帝国主义为目的。同以被压迫民族被压迫阶级联合作战为手段。这是现代革命异于历史上一切革命之最大的特点。\n\n我们试看中国社会各阶级是怎么样。\n\n### 第一、大资产阶级\n\n经济落后半殖民地的中国，大资产阶级完全是国际资产阶级的附庸。其生存和发展的条件，即附属于帝国主义。如买办阶级――与外资有密切关系之银行家（陆宋与东兼伯等）商业家（如唐绍仪何东等），工业瘃（如张寒盛恩照等）。\n\n大地主（如张作霖陈恭受等）。\n\n官僚（如孙宝琦颜惠庆等）。\n\n军阀（如张作霖曹锡等）。\n\n反动派知识阶级一一上列四种人之附属物，如买办性质的银行工商业高等员司，财阀，政府之高等事务员，政客，一部分在西洋留学生，一部分大学枝专门学校的教授和学生，大律师等都是这一类。\n\n这一个阶级与民族革命之目的完全不相容，始终站在帝国主义一边，乃极端的反革命派。其人数大概不出一百万即四万万人中四百分之一，乃民族革命运动中之死敌。\n\n### 第二、中产阶级\n\n华资银行工商阶级（因在经济落后的中国，本国资本银行工商业的发展尚限在中产阶级地位．所谓银行业乃指小银行及钱庄，工业乃指小规模工厂，商业乃指国货商。凡是大规模银行工商业无不与外国资本有关系，只能算入买办阶级内。）\n\n小地主\n\n​       许多高等知识分子一华商银行工商业之从业员，大部分东西洋留学生，大部分大学校专门学校教授和学生，小律师等都是这一类。这个阶级的欲望为欲达到大资产阶级的地位，然受外资打击军阀压迫不能发展。这个阶级对于民族革命历取了矛盾的态度。即其受外资打击，军阀压迫感受痛苦时，需要革命，赞成反帝国主义反军阀的革命运动。但国内现在的革命运动，在国内有本国无产阶级的勇猛参加，在国外有国际无产阶级的积极援助，对于其欲达到大资产阶级地位的阶级的发展及存在，感觉着威胁又怀疑革命。这个阶级即所谓民族资产阶级，其政治的主张为国家主义一一实现民族资产阶级一阶级统治的国家。有一个戴季陶的，“真实信徒”（其自称如此）在北京晨报上发表议论说：“举起你的左手打倒帝国主义！举起你的右手打倒共产党！”乃活画出这个阶级的矛盾惶遽态度。他们反对以阶级斗争说解释民主主义，反对国民党联俄及容纳共产派分子。但这个阶级的企图一一实现民族资产阶级统治的国家，是完全不行，因为现在世界上局面，乃革命反革命两大势力作最后争斗的局面，这两大势力竖起两面大旗：一面是赤色的革命的大旗，第三国际高举着，号召全世界被压迫民族被压迫阶级集合子其旗帜之下，站在一边；一面是白色的反革命大旗，国际联盟高举着，号召全世界反革命分子都集于其旗帜之下，站在另一边。那些中间阶级，在西洋如所谓第二国际等类，在中国如所谓国家主义派等类，必须赶快的分化，或者向左跑入革命派或者向右跑入反革命派，没有他们“独立”革命思想，仅仅是个幻想。他们现在虽还站在半反革命的地位，他们现在虽然还不是我们正面的敌人，但到他们感觉工农阶级的威胁日甚时，即是为了工农阶级的利益迫他们让步稍多时（如农村中的减租运动，都市中的罢工运动）他们或他们的一部分（中产阶级右翼）一定会站入帝国主义一边，一定变为完全的反革命，一定要成为我们正面的敌人。本来买办阶级与非买办阶级，有一部是未能截然划分清楚的。以商业论，固然许多商人是洋货商土贷商划分得很清楚，但是在有些商店的店门内，是一部分摆设着土货，一部分又摆设着洋货。以知识阶级论，以小地主子弟的资格赴东洋资本主义国家读书的留学生，固然是明显的除了半身土气之外，又带上了半身洋气。即从小地主子弟的资格在国内专门学校大学校读书受着那半土半洋回国留学生的熏陶，仍然不免是些半身土气半身洋气的脚色。在这类人并不是纯民族的资产阶级性质，可以叫他们做“半民族资产阶级”。这种乃是中产阶级右翼，只要国民革命的斗争加深；这种人一定很快地跑入帝国主义军阀的队伍里，和买办阶级做着（资料不清）。中产险级左翼即与帝国主义完全无缘者，此派在某种情况（如抵制外国朝流高潮时）有革命性。及其死持之空虚的“和平”观念极破，而且对于所谓“赤化”时时怀着恐慌。故其对于反革命极为妥协，不能持久，故中国的中产阶级，无论其右翼，及其左翼，也包括许多危险成分，断不能望其勇敢地跑上革命的路，跟着其余的阶级忠实地做革命事业，除开少数历史和环境都有特别情况的人。中产阶级的人，在全国内至多每百个人里有一个（百分之一）即四百万人。\n\n### 第三小资产阶级\n\n如：自耕农、小商、手工业主、小知识阶级――小员司、小事务员、中学学生、及中小学教员、小律师等都属于这类。这一个阶级，在人数上，在阶级性上，都值得大大注意。小资产的人数，单是自耕农就有一万万至一万万二千万，小商人手工业主，知识阶级，大概自二千万至三千万，合计达到一万万三千万，这个阶级虽然同在小资产阶级之经济地位，但实有三个不同的部分。第一部分：是有余钱剩米的，即用其体力或脑力劳动所得，除自给外，每年还有余剩，用以造成所谓资本的初步积累。这种人“发财”观念极重，虽不妄想发大财。却总想爬上那中产阶级地位。他们看只那些受人尊敬的小财东，往往垂着一尺长涎水，对于赵公元帅（俗财神）礼拜最劝。这种人胆子极小，他们怕官，也有点革命．因为他们的经济地位与中产阶级颇接近，故对于中产阶级的宣传颇相信，对于革命取怀疑的态度。但是这一部分人在小资产中占少数，大概不及小资产阶级全数百分之十约一千五百万，乃小一部资产阶级的右翼。第二部分是恰足自给的，每年收支恰足相抵，不多不少，这部分人比较第一部分人大不相同，他们也想发财，但是赵公元帅总不让他们岁财，随着近年帝国主义军阀大中资产阶级的压迫和剥削，使他们感觉现在的世界已经不是从前的世界。他们感觉现在如果只使用从前相等的劳力，就会不能维持生活。必须增加劳动时间，即每天起早晨，对手职业加倍注意，才能维持生活。他们有点骂人了，他们骂人叫“洋鬼子”，骂军阀叫“抢钱司令”，骂土豪劣绅叫“为富不仁”。对于反帝国主义反军阀的运动，仅怀疑其未能成功，理由是“洋人和司令的来头那么大”，不肯贸然参加，取了中立的态度，但绝不反对革命。这一部分人数甚多，大概小资产的一半：“十分之五”即七千五百万。第三部分是每年要亏本的。这一部分人，好些大概原先本是所谓殷实人家，渐渐变的仅仅保守，渐渐的要亏本了。他们每逢年终结账一次，就吃惊一次，说“咳，又亏了！”这种人因为他们从前过着次日子，后来逐年下降，负债渐多，渐次过着凄凉的日子，“瞻念前途，不寒而栗”。这种人，在精神上感觉的痛苦比一切人大，因为他们有一个从前与现在相反的比较。这种人在革命运动中颇要紧，颇有推动革命的力量。其人数占小资产阶级中百分之四十即六千万一个不小的群众，乃小资产阶级的左翼。以上说小资产阶级的三部分对于革命的态度在平时各不相同，但到战时即革命潮流高涨可以看得见胜利的曙光时，不但小资产阶级的左派参加革命，中派亦可以参加革命，即左派分子受了无产阶级及小资产阶级左派的革命大潮所裹挟，也只得附着革命。我们从工业运动和历年来各地农民运动的经验看来，这个鉴定是不错的。\n\n### 第四、半无产阶级。此处所谓半无产阶级，乃包含：\n\n（1）半自耕农（2）半益农（3）贫农（4）手业工工人（5）店员（6）小贩，之六种。半自耕农的数目，在中国农民中大概占五千万，半益农贫农大概各占六千万，三种共计一万万七千万，乃农村中一个颇大群众，所谓农民问题，一大半就是他们的问题。这三种农民有同属半无产阶级，然从经济状况仍有上中下三个细别：在半自耕农其生活苦于自耕农，因其食粮每年有一半不够，须租种别人田地或者作工或营小商以资弥补。春夏之间，青黄不接虽高利向别人借贷，重价向别人籴粮，较之自耕农之不求于人，自然说过要苦，然优于半益农，因半益农无土地，每年耕种只得收获之一半，半自耕农则租于别人的部分虽只收获一半，或且不足一半，然自有的部分都可全获，故半自耕农之革命性优于自耕农而不及半益农。半益农与贫农都是乡村的佃农，同受地主的剥削，然经济地位颇有分别，半益农无土地，然有比较充足之农具及相当数目的流动资本，此种农人，每年劳动结果自己可以得到一半，不足部分，种杂粮，捞鱼虾，饲鸡豕，勉强维持其生活，于艰难竭蹶之中，存聊以卒岁，想，故其生活苦于半自耕农，然较贫农为优，其革命性则优于半自耕农而不及贫农。贫农之无充足的农具，又无流动的资本，肥料不足，田亩歉收，送租之外，所得无几，荒时暴月向亲友乞哀告怜，借得几斗几升敷衍三日五日，债务丛集，如牛负重，乃农民中之极艰苦者，极易接近革命的宣传。手工业工人所以称以半无产阶级，因其自有工具，且系一种自由职业，其经济地位略与农业中半益农相当，因家庭负担之重，工资与生活物价之不相称，时有贫困的压迫或失业的恐慌，与半益农亦大致相当。店员为中小商人的雇员，以微簿的薪资，供事人畜的费用，物价年年增涨，而薪例往往须数年一更，偶与此辈倾谈，便见叫苦不迭，其地位与手工业工人不相上下，对于革命宣传极易接受。小贩不论是肩挑叫卖或于畔摊售，总之本小利微吃着不够，其地位与贫农不相上下，其需要一个变更现代的革命也和贫农相同。手工业工人人数，大概占全人口百分之六即二千四百万人，店员大概有五百万，小贩大概有一百万，合起半自耕农，半益农、佃农人数半无产阶级人数共计约二万万占全国人口之一半。\n\n### 第五、无产阶级。其种类及人数如左，\n\n工业无产阶级约二百万；\n\n都市苦力约三百万；\n\n农业无产阶级约二千万；\n\n共约四千五百万。中国因经济落后，故产业工人（工业无产阶级）不多，二百万产业工人之中，主要为铁路、矿山、海运、纺织、造船五种产业，而大多数在外资产业之下，故工业无产阶级虽不多，却做了民族革命运动的主力。我们看四年以来的罢工运动，如海员罢工、铁路罢工，开源及焦作煤矿罢工，及五四后，上海、香港两处之大罢工所表现的力量，就可知工业无产阶级在民族革命中所处地位的重要。他们所以能如此，第一个原因是集中，无论那种人都不如他们“有组织的集中”，第二个原因，是经济地位低下。他们失去了工具，剩用两只手，绝了发财的望，又受着帝国主义、军阀买办阶级极惨酷的待遇，所以他们特别能奋斗。都市苦力的力量也很可注意，以码头搬运夫以人力车夫占大多数，粪夫清道夫等都属于这一类。他们除了一双手外，别无长物，其经济地位与产业工人相似，惟不及其有组织的集中及在生产力上的重要。中国尚少新式资本主义的农业，所谓农业无产阶级，乃指长工、月工、零工等雇农而言。此等雇农，不仅无土地，无农具，又无丝毫流动资本，故只得营工度日。其劳动时间之长，工资之少，待遇之薄，职业之不安定，超过其他工人，此种人在乡村中乃最感困难者，在农民运动中，与贫农处于同一要紧的地位。游民无产阶级为失了土地的农民与失了工作的机会的手工业工人，其人数在二千万以上，乃国内兵争匪祸的根源。此游民无产阶级中最多者为匪．其次为兵，次为乞丐，次为盗贼与娼妓。他们乃人类生活中最不安定者，他们在各地都有秘密的组织，如闽粤的“三合会”，湘、鄂、黔、蜀的“哥老会”，皖、豫、鲁等省的“大刀会”，直隶及东三省的“在理会”，上海等处的青红帮，都做了他们政治和经济争斗的互助机关。处置这一批人乃中国最大最难的问题，一个是贫乏，又一个是失业，故若解决了失业问题，就算是解决了中国问题的一半。这一批人很能勇敢奋斗，引导得法可以变成一种革命力量。\n\n谁是敌人谁是朋友，我们现在可以答复了，一切勾结帝国主义的军阀官僚，买办阶级，大地主，反动的知识阶级即所谓中国大资产阶级，乃是我们的敌人，乃是我们真正的敌人；一切小资产阶级、半无产阶级、无产阶级乃是我们的朋友，乃是我们真正的朋友；那动摇不定的中产阶级，其右翼应该把他当做我们的敌人，即使时非敌人也去敌人不远，其左翼可以把他们当做我们的朋友，但不是真正的朋友，我们要时常提防他，不要让他乱了我们的阵线，我们的真正敌人有多少？有四百万！让这四百万算做敌人，也不枉妄他们有一个五百万人的团体，依然抵不住三万万九千五百万人的一铺唾沫。三万万九千五百万人团结起来！","source":"_posts/Communis.md","raw":"---\ntitle: 湖南农民运动考察报告\ntags: 农民运动\nautor: Zmc\ncategories: 毛选\ndate: 2024-03-19 00:39:00\nfeature: true\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/007.jpg\n---\n## 谁是我们的敌人，谁是我们的朋友\n\n第一次国内革命战争时期\n\n​        谁是我们的敌人？谁是我们的朋友？分不清敌人与朋友，必不是个革命分子，要分清敌人与朋友呢，却并不是立场。中国革命且三十年而成效甚少，并不是目的错、完全是策略错。所谓策略错，就是不能团结真正的朋友，以攻击真正的敌人．所以不能如此，乃是未分清谁是敌人谁是朋友。革命党是群众的向导。在军队中，未有他的响导领错了路而可以打胜仗，在革命运动中，未有革命党领错了路而这个革命可以不失败。我们都是革命党，都是给群众领路的人，都是群众的向导。但我们不可不自问一问：我们有这个本领没有？我们不至于领了群众到失败的路上去么？我们可以一定完成功吗？要有：“不错了路”和“一定成功”的把握不可不致谨于一个重要的策略，要决定这个策略，就要分清谁是敌人谁是朋友。国民党第一次全国大会宣言，就是宣告这个策略的决定和敌友的分辨。但这个宣言极其简单。我们要认识这重要的策略，要分辨那真正的敌友，不可不将中国社会各阶级的经济地位，阶级性，人数及其对于革命的态度，作一个大概的分析。\n\n​        无论那一个国内，大概地说，都有三等人，上等、中等、下等。详细分析则有五等，大资产阶级、中产阶级、小资产阶级、半无产阶级、无产阶级。拿农村说：大地主是大资产阶级，小，地主是中产阶级，自耕农是小资产阶级，半自耕佃农是半无产阶级，雇农是无产阶级。拿都市说：大银行家、大商业家、大工业家是大资产阶级、钱庄主、中等商人、小工厂主是中产阶级，小商人、手工业主是小资产阶级，店员小贩手工业工人是半无产阶级，产业工人苦力是无产阶级。五种人各有不同的经济地位，各有不同的阶级性。因此对于现代的革命，乃发生反革命，半反革命，对革命守中立，参加革命和向革命的主力军种种不同的态度。\n\n​        小国各阶级对于民族革命的态度，与西欧资本主义国家的各阶级对社会革命的态度，几乎完全一样。看来好似奇怪，实际并不奇怪。因为现代的革命本是一个，其目的与手段均相同，即同以打倒国际资本帝国主义为目的。同以被压迫民族被压迫阶级联合作战为手段。这是现代革命异于历史上一切革命之最大的特点。\n\n我们试看中国社会各阶级是怎么样。\n\n### 第一、大资产阶级\n\n经济落后半殖民地的中国，大资产阶级完全是国际资产阶级的附庸。其生存和发展的条件，即附属于帝国主义。如买办阶级――与外资有密切关系之银行家（陆宋与东兼伯等）商业家（如唐绍仪何东等），工业瘃（如张寒盛恩照等）。\n\n大地主（如张作霖陈恭受等）。\n\n官僚（如孙宝琦颜惠庆等）。\n\n军阀（如张作霖曹锡等）。\n\n反动派知识阶级一一上列四种人之附属物，如买办性质的银行工商业高等员司，财阀，政府之高等事务员，政客，一部分在西洋留学生，一部分大学枝专门学校的教授和学生，大律师等都是这一类。\n\n这一个阶级与民族革命之目的完全不相容，始终站在帝国主义一边，乃极端的反革命派。其人数大概不出一百万即四万万人中四百分之一，乃民族革命运动中之死敌。\n\n### 第二、中产阶级\n\n华资银行工商阶级（因在经济落后的中国，本国资本银行工商业的发展尚限在中产阶级地位．所谓银行业乃指小银行及钱庄，工业乃指小规模工厂，商业乃指国货商。凡是大规模银行工商业无不与外国资本有关系，只能算入买办阶级内。）\n\n小地主\n\n​       许多高等知识分子一华商银行工商业之从业员，大部分东西洋留学生，大部分大学校专门学校教授和学生，小律师等都是这一类。这个阶级的欲望为欲达到大资产阶级的地位，然受外资打击军阀压迫不能发展。这个阶级对于民族革命历取了矛盾的态度。即其受外资打击，军阀压迫感受痛苦时，需要革命，赞成反帝国主义反军阀的革命运动。但国内现在的革命运动，在国内有本国无产阶级的勇猛参加，在国外有国际无产阶级的积极援助，对于其欲达到大资产阶级地位的阶级的发展及存在，感觉着威胁又怀疑革命。这个阶级即所谓民族资产阶级，其政治的主张为国家主义一一实现民族资产阶级一阶级统治的国家。有一个戴季陶的，“真实信徒”（其自称如此）在北京晨报上发表议论说：“举起你的左手打倒帝国主义！举起你的右手打倒共产党！”乃活画出这个阶级的矛盾惶遽态度。他们反对以阶级斗争说解释民主主义，反对国民党联俄及容纳共产派分子。但这个阶级的企图一一实现民族资产阶级统治的国家，是完全不行，因为现在世界上局面，乃革命反革命两大势力作最后争斗的局面，这两大势力竖起两面大旗：一面是赤色的革命的大旗，第三国际高举着，号召全世界被压迫民族被压迫阶级集合子其旗帜之下，站在一边；一面是白色的反革命大旗，国际联盟高举着，号召全世界反革命分子都集于其旗帜之下，站在另一边。那些中间阶级，在西洋如所谓第二国际等类，在中国如所谓国家主义派等类，必须赶快的分化，或者向左跑入革命派或者向右跑入反革命派，没有他们“独立”革命思想，仅仅是个幻想。他们现在虽还站在半反革命的地位，他们现在虽然还不是我们正面的敌人，但到他们感觉工农阶级的威胁日甚时，即是为了工农阶级的利益迫他们让步稍多时（如农村中的减租运动，都市中的罢工运动）他们或他们的一部分（中产阶级右翼）一定会站入帝国主义一边，一定变为完全的反革命，一定要成为我们正面的敌人。本来买办阶级与非买办阶级，有一部是未能截然划分清楚的。以商业论，固然许多商人是洋货商土贷商划分得很清楚，但是在有些商店的店门内，是一部分摆设着土货，一部分又摆设着洋货。以知识阶级论，以小地主子弟的资格赴东洋资本主义国家读书的留学生，固然是明显的除了半身土气之外，又带上了半身洋气。即从小地主子弟的资格在国内专门学校大学校读书受着那半土半洋回国留学生的熏陶，仍然不免是些半身土气半身洋气的脚色。在这类人并不是纯民族的资产阶级性质，可以叫他们做“半民族资产阶级”。这种乃是中产阶级右翼，只要国民革命的斗争加深；这种人一定很快地跑入帝国主义军阀的队伍里，和买办阶级做着（资料不清）。中产险级左翼即与帝国主义完全无缘者，此派在某种情况（如抵制外国朝流高潮时）有革命性。及其死持之空虚的“和平”观念极破，而且对于所谓“赤化”时时怀着恐慌。故其对于反革命极为妥协，不能持久，故中国的中产阶级，无论其右翼，及其左翼，也包括许多危险成分，断不能望其勇敢地跑上革命的路，跟着其余的阶级忠实地做革命事业，除开少数历史和环境都有特别情况的人。中产阶级的人，在全国内至多每百个人里有一个（百分之一）即四百万人。\n\n### 第三小资产阶级\n\n如：自耕农、小商、手工业主、小知识阶级――小员司、小事务员、中学学生、及中小学教员、小律师等都属于这类。这一个阶级，在人数上，在阶级性上，都值得大大注意。小资产的人数，单是自耕农就有一万万至一万万二千万，小商人手工业主，知识阶级，大概自二千万至三千万，合计达到一万万三千万，这个阶级虽然同在小资产阶级之经济地位，但实有三个不同的部分。第一部分：是有余钱剩米的，即用其体力或脑力劳动所得，除自给外，每年还有余剩，用以造成所谓资本的初步积累。这种人“发财”观念极重，虽不妄想发大财。却总想爬上那中产阶级地位。他们看只那些受人尊敬的小财东，往往垂着一尺长涎水，对于赵公元帅（俗财神）礼拜最劝。这种人胆子极小，他们怕官，也有点革命．因为他们的经济地位与中产阶级颇接近，故对于中产阶级的宣传颇相信，对于革命取怀疑的态度。但是这一部分人在小资产中占少数，大概不及小资产阶级全数百分之十约一千五百万，乃小一部资产阶级的右翼。第二部分是恰足自给的，每年收支恰足相抵，不多不少，这部分人比较第一部分人大不相同，他们也想发财，但是赵公元帅总不让他们岁财，随着近年帝国主义军阀大中资产阶级的压迫和剥削，使他们感觉现在的世界已经不是从前的世界。他们感觉现在如果只使用从前相等的劳力，就会不能维持生活。必须增加劳动时间，即每天起早晨，对手职业加倍注意，才能维持生活。他们有点骂人了，他们骂人叫“洋鬼子”，骂军阀叫“抢钱司令”，骂土豪劣绅叫“为富不仁”。对于反帝国主义反军阀的运动，仅怀疑其未能成功，理由是“洋人和司令的来头那么大”，不肯贸然参加，取了中立的态度，但绝不反对革命。这一部分人数甚多，大概小资产的一半：“十分之五”即七千五百万。第三部分是每年要亏本的。这一部分人，好些大概原先本是所谓殷实人家，渐渐变的仅仅保守，渐渐的要亏本了。他们每逢年终结账一次，就吃惊一次，说“咳，又亏了！”这种人因为他们从前过着次日子，后来逐年下降，负债渐多，渐次过着凄凉的日子，“瞻念前途，不寒而栗”。这种人，在精神上感觉的痛苦比一切人大，因为他们有一个从前与现在相反的比较。这种人在革命运动中颇要紧，颇有推动革命的力量。其人数占小资产阶级中百分之四十即六千万一个不小的群众，乃小资产阶级的左翼。以上说小资产阶级的三部分对于革命的态度在平时各不相同，但到战时即革命潮流高涨可以看得见胜利的曙光时，不但小资产阶级的左派参加革命，中派亦可以参加革命，即左派分子受了无产阶级及小资产阶级左派的革命大潮所裹挟，也只得附着革命。我们从工业运动和历年来各地农民运动的经验看来，这个鉴定是不错的。\n\n### 第四、半无产阶级。此处所谓半无产阶级，乃包含：\n\n（1）半自耕农（2）半益农（3）贫农（4）手业工工人（5）店员（6）小贩，之六种。半自耕农的数目，在中国农民中大概占五千万，半益农贫农大概各占六千万，三种共计一万万七千万，乃农村中一个颇大群众，所谓农民问题，一大半就是他们的问题。这三种农民有同属半无产阶级，然从经济状况仍有上中下三个细别：在半自耕农其生活苦于自耕农，因其食粮每年有一半不够，须租种别人田地或者作工或营小商以资弥补。春夏之间，青黄不接虽高利向别人借贷，重价向别人籴粮，较之自耕农之不求于人，自然说过要苦，然优于半益农，因半益农无土地，每年耕种只得收获之一半，半自耕农则租于别人的部分虽只收获一半，或且不足一半，然自有的部分都可全获，故半自耕农之革命性优于自耕农而不及半益农。半益农与贫农都是乡村的佃农，同受地主的剥削，然经济地位颇有分别，半益农无土地，然有比较充足之农具及相当数目的流动资本，此种农人，每年劳动结果自己可以得到一半，不足部分，种杂粮，捞鱼虾，饲鸡豕，勉强维持其生活，于艰难竭蹶之中，存聊以卒岁，想，故其生活苦于半自耕农，然较贫农为优，其革命性则优于半自耕农而不及贫农。贫农之无充足的农具，又无流动的资本，肥料不足，田亩歉收，送租之外，所得无几，荒时暴月向亲友乞哀告怜，借得几斗几升敷衍三日五日，债务丛集，如牛负重，乃农民中之极艰苦者，极易接近革命的宣传。手工业工人所以称以半无产阶级，因其自有工具，且系一种自由职业，其经济地位略与农业中半益农相当，因家庭负担之重，工资与生活物价之不相称，时有贫困的压迫或失业的恐慌，与半益农亦大致相当。店员为中小商人的雇员，以微簿的薪资，供事人畜的费用，物价年年增涨，而薪例往往须数年一更，偶与此辈倾谈，便见叫苦不迭，其地位与手工业工人不相上下，对于革命宣传极易接受。小贩不论是肩挑叫卖或于畔摊售，总之本小利微吃着不够，其地位与贫农不相上下，其需要一个变更现代的革命也和贫农相同。手工业工人人数，大概占全人口百分之六即二千四百万人，店员大概有五百万，小贩大概有一百万，合起半自耕农，半益农、佃农人数半无产阶级人数共计约二万万占全国人口之一半。\n\n### 第五、无产阶级。其种类及人数如左，\n\n工业无产阶级约二百万；\n\n都市苦力约三百万；\n\n农业无产阶级约二千万；\n\n共约四千五百万。中国因经济落后，故产业工人（工业无产阶级）不多，二百万产业工人之中，主要为铁路、矿山、海运、纺织、造船五种产业，而大多数在外资产业之下，故工业无产阶级虽不多，却做了民族革命运动的主力。我们看四年以来的罢工运动，如海员罢工、铁路罢工，开源及焦作煤矿罢工，及五四后，上海、香港两处之大罢工所表现的力量，就可知工业无产阶级在民族革命中所处地位的重要。他们所以能如此，第一个原因是集中，无论那种人都不如他们“有组织的集中”，第二个原因，是经济地位低下。他们失去了工具，剩用两只手，绝了发财的望，又受着帝国主义、军阀买办阶级极惨酷的待遇，所以他们特别能奋斗。都市苦力的力量也很可注意，以码头搬运夫以人力车夫占大多数，粪夫清道夫等都属于这一类。他们除了一双手外，别无长物，其经济地位与产业工人相似，惟不及其有组织的集中及在生产力上的重要。中国尚少新式资本主义的农业，所谓农业无产阶级，乃指长工、月工、零工等雇农而言。此等雇农，不仅无土地，无农具，又无丝毫流动资本，故只得营工度日。其劳动时间之长，工资之少，待遇之薄，职业之不安定，超过其他工人，此种人在乡村中乃最感困难者，在农民运动中，与贫农处于同一要紧的地位。游民无产阶级为失了土地的农民与失了工作的机会的手工业工人，其人数在二千万以上，乃国内兵争匪祸的根源。此游民无产阶级中最多者为匪．其次为兵，次为乞丐，次为盗贼与娼妓。他们乃人类生活中最不安定者，他们在各地都有秘密的组织，如闽粤的“三合会”，湘、鄂、黔、蜀的“哥老会”，皖、豫、鲁等省的“大刀会”，直隶及东三省的“在理会”，上海等处的青红帮，都做了他们政治和经济争斗的互助机关。处置这一批人乃中国最大最难的问题，一个是贫乏，又一个是失业，故若解决了失业问题，就算是解决了中国问题的一半。这一批人很能勇敢奋斗，引导得法可以变成一种革命力量。\n\n谁是敌人谁是朋友，我们现在可以答复了，一切勾结帝国主义的军阀官僚，买办阶级，大地主，反动的知识阶级即所谓中国大资产阶级，乃是我们的敌人，乃是我们真正的敌人；一切小资产阶级、半无产阶级、无产阶级乃是我们的朋友，乃是我们真正的朋友；那动摇不定的中产阶级，其右翼应该把他当做我们的敌人，即使时非敌人也去敌人不远，其左翼可以把他们当做我们的朋友，但不是真正的朋友，我们要时常提防他，不要让他乱了我们的阵线，我们的真正敌人有多少？有四百万！让这四百万算做敌人，也不枉妄他们有一个五百万人的团体，依然抵不住三万万九千五百万人的一铺唾沫。三万万九千五百万人团结起来！","slug":"Communis","published":1,"updated":"2024-03-22T06:08:41.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgx90003iou2ejaxh8cc","content":"<h2 id=\"谁是我们的敌人，谁是我们的朋友\"><a href=\"#谁是我们的敌人，谁是我们的朋友\" class=\"headerlink\" title=\"谁是我们的敌人，谁是我们的朋友\"></a>谁是我们的敌人，谁是我们的朋友</h2><p>第一次国内革命战争时期</p>\n<p>​        谁是我们的敌人？谁是我们的朋友？分不清敌人与朋友，必不是个革命分子，要分清敌人与朋友呢，却并不是立场。中国革命且三十年而成效甚少，并不是目的错、完全是策略错。所谓策略错，就是不能团结真正的朋友，以攻击真正的敌人．所以不能如此，乃是未分清谁是敌人谁是朋友。革命党是群众的向导。在军队中，未有他的响导领错了路而可以打胜仗，在革命运动中，未有革命党领错了路而这个革命可以不失败。我们都是革命党，都是给群众领路的人，都是群众的向导。但我们不可不自问一问：我们有这个本领没有？我们不至于领了群众到失败的路上去么？我们可以一定完成功吗？要有：“不错了路”和“一定成功”的把握不可不致谨于一个重要的策略，要决定这个策略，就要分清谁是敌人谁是朋友。国民党第一次全国大会宣言，就是宣告这个策略的决定和敌友的分辨。但这个宣言极其简单。我们要认识这重要的策略，要分辨那真正的敌友，不可不将中国社会各阶级的经济地位，阶级性，人数及其对于革命的态度，作一个大概的分析。</p>\n<p>​        无论那一个国内，大概地说，都有三等人，上等、中等、下等。详细分析则有五等，大资产阶级、中产阶级、小资产阶级、半无产阶级、无产阶级。拿农村说：大地主是大资产阶级，小，地主是中产阶级，自耕农是小资产阶级，半自耕佃农是半无产阶级，雇农是无产阶级。拿都市说：大银行家、大商业家、大工业家是大资产阶级、钱庄主、中等商人、小工厂主是中产阶级，小商人、手工业主是小资产阶级，店员小贩手工业工人是半无产阶级，产业工人苦力是无产阶级。五种人各有不同的经济地位，各有不同的阶级性。因此对于现代的革命，乃发生反革命，半反革命，对革命守中立，参加革命和向革命的主力军种种不同的态度。</p>\n<p>​        小国各阶级对于民族革命的态度，与西欧资本主义国家的各阶级对社会革命的态度，几乎完全一样。看来好似奇怪，实际并不奇怪。因为现代的革命本是一个，其目的与手段均相同，即同以打倒国际资本帝国主义为目的。同以被压迫民族被压迫阶级联合作战为手段。这是现代革命异于历史上一切革命之最大的特点。</p>\n<p>我们试看中国社会各阶级是怎么样。</p>\n<h3 id=\"第一、大资产阶级\"><a href=\"#第一、大资产阶级\" class=\"headerlink\" title=\"第一、大资产阶级\"></a>第一、大资产阶级</h3><p>经济落后半殖民地的中国，大资产阶级完全是国际资产阶级的附庸。其生存和发展的条件，即附属于帝国主义。如买办阶级――与外资有密切关系之银行家（陆宋与东兼伯等）商业家（如唐绍仪何东等），工业瘃（如张寒盛恩照等）。</p>\n<p>大地主（如张作霖陈恭受等）。</p>\n<p>官僚（如孙宝琦颜惠庆等）。</p>\n<p>军阀（如张作霖曹锡等）。</p>\n<p>反动派知识阶级一一上列四种人之附属物，如买办性质的银行工商业高等员司，财阀，政府之高等事务员，政客，一部分在西洋留学生，一部分大学枝专门学校的教授和学生，大律师等都是这一类。</p>\n<p>这一个阶级与民族革命之目的完全不相容，始终站在帝国主义一边，乃极端的反革命派。其人数大概不出一百万即四万万人中四百分之一，乃民族革命运动中之死敌。</p>\n<h3 id=\"第二、中产阶级\"><a href=\"#第二、中产阶级\" class=\"headerlink\" title=\"第二、中产阶级\"></a>第二、中产阶级</h3><p>华资银行工商阶级（因在经济落后的中国，本国资本银行工商业的发展尚限在中产阶级地位．所谓银行业乃指小银行及钱庄，工业乃指小规模工厂，商业乃指国货商。凡是大规模银行工商业无不与外国资本有关系，只能算入买办阶级内。）</p>\n<p>小地主</p>\n<p>​       许多高等知识分子一华商银行工商业之从业员，大部分东西洋留学生，大部分大学校专门学校教授和学生，小律师等都是这一类。这个阶级的欲望为欲达到大资产阶级的地位，然受外资打击军阀压迫不能发展。这个阶级对于民族革命历取了矛盾的态度。即其受外资打击，军阀压迫感受痛苦时，需要革命，赞成反帝国主义反军阀的革命运动。但国内现在的革命运动，在国内有本国无产阶级的勇猛参加，在国外有国际无产阶级的积极援助，对于其欲达到大资产阶级地位的阶级的发展及存在，感觉着威胁又怀疑革命。这个阶级即所谓民族资产阶级，其政治的主张为国家主义一一实现民族资产阶级一阶级统治的国家。有一个戴季陶的，“真实信徒”（其自称如此）在北京晨报上发表议论说：“举起你的左手打倒帝国主义！举起你的右手打倒共产党！”乃活画出这个阶级的矛盾惶遽态度。他们反对以阶级斗争说解释民主主义，反对国民党联俄及容纳共产派分子。但这个阶级的企图一一实现民族资产阶级统治的国家，是完全不行，因为现在世界上局面，乃革命反革命两大势力作最后争斗的局面，这两大势力竖起两面大旗：一面是赤色的革命的大旗，第三国际高举着，号召全世界被压迫民族被压迫阶级集合子其旗帜之下，站在一边；一面是白色的反革命大旗，国际联盟高举着，号召全世界反革命分子都集于其旗帜之下，站在另一边。那些中间阶级，在西洋如所谓第二国际等类，在中国如所谓国家主义派等类，必须赶快的分化，或者向左跑入革命派或者向右跑入反革命派，没有他们“独立”革命思想，仅仅是个幻想。他们现在虽还站在半反革命的地位，他们现在虽然还不是我们正面的敌人，但到他们感觉工农阶级的威胁日甚时，即是为了工农阶级的利益迫他们让步稍多时（如农村中的减租运动，都市中的罢工运动）他们或他们的一部分（中产阶级右翼）一定会站入帝国主义一边，一定变为完全的反革命，一定要成为我们正面的敌人。本来买办阶级与非买办阶级，有一部是未能截然划分清楚的。以商业论，固然许多商人是洋货商土贷商划分得很清楚，但是在有些商店的店门内，是一部分摆设着土货，一部分又摆设着洋货。以知识阶级论，以小地主子弟的资格赴东洋资本主义国家读书的留学生，固然是明显的除了半身土气之外，又带上了半身洋气。即从小地主子弟的资格在国内专门学校大学校读书受着那半土半洋回国留学生的熏陶，仍然不免是些半身土气半身洋气的脚色。在这类人并不是纯民族的资产阶级性质，可以叫他们做“半民族资产阶级”。这种乃是中产阶级右翼，只要国民革命的斗争加深；这种人一定很快地跑入帝国主义军阀的队伍里，和买办阶级做着（资料不清）。中产险级左翼即与帝国主义完全无缘者，此派在某种情况（如抵制外国朝流高潮时）有革命性。及其死持之空虚的“和平”观念极破，而且对于所谓“赤化”时时怀着恐慌。故其对于反革命极为妥协，不能持久，故中国的中产阶级，无论其右翼，及其左翼，也包括许多危险成分，断不能望其勇敢地跑上革命的路，跟着其余的阶级忠实地做革命事业，除开少数历史和环境都有特别情况的人。中产阶级的人，在全国内至多每百个人里有一个（百分之一）即四百万人。</p>\n<h3 id=\"第三小资产阶级\"><a href=\"#第三小资产阶级\" class=\"headerlink\" title=\"第三小资产阶级\"></a>第三小资产阶级</h3><p>如：自耕农、小商、手工业主、小知识阶级――小员司、小事务员、中学学生、及中小学教员、小律师等都属于这类。这一个阶级，在人数上，在阶级性上，都值得大大注意。小资产的人数，单是自耕农就有一万万至一万万二千万，小商人手工业主，知识阶级，大概自二千万至三千万，合计达到一万万三千万，这个阶级虽然同在小资产阶级之经济地位，但实有三个不同的部分。第一部分：是有余钱剩米的，即用其体力或脑力劳动所得，除自给外，每年还有余剩，用以造成所谓资本的初步积累。这种人“发财”观念极重，虽不妄想发大财。却总想爬上那中产阶级地位。他们看只那些受人尊敬的小财东，往往垂着一尺长涎水，对于赵公元帅（俗财神）礼拜最劝。这种人胆子极小，他们怕官，也有点革命．因为他们的经济地位与中产阶级颇接近，故对于中产阶级的宣传颇相信，对于革命取怀疑的态度。但是这一部分人在小资产中占少数，大概不及小资产阶级全数百分之十约一千五百万，乃小一部资产阶级的右翼。第二部分是恰足自给的，每年收支恰足相抵，不多不少，这部分人比较第一部分人大不相同，他们也想发财，但是赵公元帅总不让他们岁财，随着近年帝国主义军阀大中资产阶级的压迫和剥削，使他们感觉现在的世界已经不是从前的世界。他们感觉现在如果只使用从前相等的劳力，就会不能维持生活。必须增加劳动时间，即每天起早晨，对手职业加倍注意，才能维持生活。他们有点骂人了，他们骂人叫“洋鬼子”，骂军阀叫“抢钱司令”，骂土豪劣绅叫“为富不仁”。对于反帝国主义反军阀的运动，仅怀疑其未能成功，理由是“洋人和司令的来头那么大”，不肯贸然参加，取了中立的态度，但绝不反对革命。这一部分人数甚多，大概小资产的一半：“十分之五”即七千五百万。第三部分是每年要亏本的。这一部分人，好些大概原先本是所谓殷实人家，渐渐变的仅仅保守，渐渐的要亏本了。他们每逢年终结账一次，就吃惊一次，说“咳，又亏了！”这种人因为他们从前过着次日子，后来逐年下降，负债渐多，渐次过着凄凉的日子，“瞻念前途，不寒而栗”。这种人，在精神上感觉的痛苦比一切人大，因为他们有一个从前与现在相反的比较。这种人在革命运动中颇要紧，颇有推动革命的力量。其人数占小资产阶级中百分之四十即六千万一个不小的群众，乃小资产阶级的左翼。以上说小资产阶级的三部分对于革命的态度在平时各不相同，但到战时即革命潮流高涨可以看得见胜利的曙光时，不但小资产阶级的左派参加革命，中派亦可以参加革命，即左派分子受了无产阶级及小资产阶级左派的革命大潮所裹挟，也只得附着革命。我们从工业运动和历年来各地农民运动的经验看来，这个鉴定是不错的。</p>\n<h3 id=\"第四、半无产阶级。此处所谓半无产阶级，乃包含：\"><a href=\"#第四、半无产阶级。此处所谓半无产阶级，乃包含：\" class=\"headerlink\" title=\"第四、半无产阶级。此处所谓半无产阶级，乃包含：\"></a>第四、半无产阶级。此处所谓半无产阶级，乃包含：</h3><p>（1）半自耕农（2）半益农（3）贫农（4）手业工工人（5）店员（6）小贩，之六种。半自耕农的数目，在中国农民中大概占五千万，半益农贫农大概各占六千万，三种共计一万万七千万，乃农村中一个颇大群众，所谓农民问题，一大半就是他们的问题。这三种农民有同属半无产阶级，然从经济状况仍有上中下三个细别：在半自耕农其生活苦于自耕农，因其食粮每年有一半不够，须租种别人田地或者作工或营小商以资弥补。春夏之间，青黄不接虽高利向别人借贷，重价向别人籴粮，较之自耕农之不求于人，自然说过要苦，然优于半益农，因半益农无土地，每年耕种只得收获之一半，半自耕农则租于别人的部分虽只收获一半，或且不足一半，然自有的部分都可全获，故半自耕农之革命性优于自耕农而不及半益农。半益农与贫农都是乡村的佃农，同受地主的剥削，然经济地位颇有分别，半益农无土地，然有比较充足之农具及相当数目的流动资本，此种农人，每年劳动结果自己可以得到一半，不足部分，种杂粮，捞鱼虾，饲鸡豕，勉强维持其生活，于艰难竭蹶之中，存聊以卒岁，想，故其生活苦于半自耕农，然较贫农为优，其革命性则优于半自耕农而不及贫农。贫农之无充足的农具，又无流动的资本，肥料不足，田亩歉收，送租之外，所得无几，荒时暴月向亲友乞哀告怜，借得几斗几升敷衍三日五日，债务丛集，如牛负重，乃农民中之极艰苦者，极易接近革命的宣传。手工业工人所以称以半无产阶级，因其自有工具，且系一种自由职业，其经济地位略与农业中半益农相当，因家庭负担之重，工资与生活物价之不相称，时有贫困的压迫或失业的恐慌，与半益农亦大致相当。店员为中小商人的雇员，以微簿的薪资，供事人畜的费用，物价年年增涨，而薪例往往须数年一更，偶与此辈倾谈，便见叫苦不迭，其地位与手工业工人不相上下，对于革命宣传极易接受。小贩不论是肩挑叫卖或于畔摊售，总之本小利微吃着不够，其地位与贫农不相上下，其需要一个变更现代的革命也和贫农相同。手工业工人人数，大概占全人口百分之六即二千四百万人，店员大概有五百万，小贩大概有一百万，合起半自耕农，半益农、佃农人数半无产阶级人数共计约二万万占全国人口之一半。</p>\n<h3 id=\"第五、无产阶级。其种类及人数如左，\"><a href=\"#第五、无产阶级。其种类及人数如左，\" class=\"headerlink\" title=\"第五、无产阶级。其种类及人数如左，\"></a>第五、无产阶级。其种类及人数如左，</h3><p>工业无产阶级约二百万；</p>\n<p>都市苦力约三百万；</p>\n<p>农业无产阶级约二千万；</p>\n<p>共约四千五百万。中国因经济落后，故产业工人（工业无产阶级）不多，二百万产业工人之中，主要为铁路、矿山、海运、纺织、造船五种产业，而大多数在外资产业之下，故工业无产阶级虽不多，却做了民族革命运动的主力。我们看四年以来的罢工运动，如海员罢工、铁路罢工，开源及焦作煤矿罢工，及五四后，上海、香港两处之大罢工所表现的力量，就可知工业无产阶级在民族革命中所处地位的重要。他们所以能如此，第一个原因是集中，无论那种人都不如他们“有组织的集中”，第二个原因，是经济地位低下。他们失去了工具，剩用两只手，绝了发财的望，又受着帝国主义、军阀买办阶级极惨酷的待遇，所以他们特别能奋斗。都市苦力的力量也很可注意，以码头搬运夫以人力车夫占大多数，粪夫清道夫等都属于这一类。他们除了一双手外，别无长物，其经济地位与产业工人相似，惟不及其有组织的集中及在生产力上的重要。中国尚少新式资本主义的农业，所谓农业无产阶级，乃指长工、月工、零工等雇农而言。此等雇农，不仅无土地，无农具，又无丝毫流动资本，故只得营工度日。其劳动时间之长，工资之少，待遇之薄，职业之不安定，超过其他工人，此种人在乡村中乃最感困难者，在农民运动中，与贫农处于同一要紧的地位。游民无产阶级为失了土地的农民与失了工作的机会的手工业工人，其人数在二千万以上，乃国内兵争匪祸的根源。此游民无产阶级中最多者为匪．其次为兵，次为乞丐，次为盗贼与娼妓。他们乃人类生活中最不安定者，他们在各地都有秘密的组织，如闽粤的“三合会”，湘、鄂、黔、蜀的“哥老会”，皖、豫、鲁等省的“大刀会”，直隶及东三省的“在理会”，上海等处的青红帮，都做了他们政治和经济争斗的互助机关。处置这一批人乃中国最大最难的问题，一个是贫乏，又一个是失业，故若解决了失业问题，就算是解决了中国问题的一半。这一批人很能勇敢奋斗，引导得法可以变成一种革命力量。</p>\n<p>谁是敌人谁是朋友，我们现在可以答复了，一切勾结帝国主义的军阀官僚，买办阶级，大地主，反动的知识阶级即所谓中国大资产阶级，乃是我们的敌人，乃是我们真正的敌人；一切小资产阶级、半无产阶级、无产阶级乃是我们的朋友，乃是我们真正的朋友；那动摇不定的中产阶级，其右翼应该把他当做我们的敌人，即使时非敌人也去敌人不远，其左翼可以把他们当做我们的朋友，但不是真正的朋友，我们要时常提防他，不要让他乱了我们的阵线，我们的真正敌人有多少？有四百万！让这四百万算做敌人，也不枉妄他们有一个五百万人的团体，依然抵不住三万万九千五百万人的一铺唾沫。三万万九千五百万人团结起来！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"谁是我们的敌人，谁是我们的朋友\"><a href=\"#谁是我们的敌人，谁是我们的朋友\" class=\"headerlink\" title=\"谁是我们的敌人，谁是我们的朋友\"></a>谁是我们的敌人，谁是我们的朋友</h2><p>第一次国内革命战争时期</p>\n<p>​        谁是我们的敌人？谁是我们的朋友？分不清敌人与朋友，必不是个革命分子，要分清敌人与朋友呢，却并不是立场。中国革命且三十年而成效甚少，并不是目的错、完全是策略错。所谓策略错，就是不能团结真正的朋友，以攻击真正的敌人．所以不能如此，乃是未分清谁是敌人谁是朋友。革命党是群众的向导。在军队中，未有他的响导领错了路而可以打胜仗，在革命运动中，未有革命党领错了路而这个革命可以不失败。我们都是革命党，都是给群众领路的人，都是群众的向导。但我们不可不自问一问：我们有这个本领没有？我们不至于领了群众到失败的路上去么？我们可以一定完成功吗？要有：“不错了路”和“一定成功”的把握不可不致谨于一个重要的策略，要决定这个策略，就要分清谁是敌人谁是朋友。国民党第一次全国大会宣言，就是宣告这个策略的决定和敌友的分辨。但这个宣言极其简单。我们要认识这重要的策略，要分辨那真正的敌友，不可不将中国社会各阶级的经济地位，阶级性，人数及其对于革命的态度，作一个大概的分析。</p>\n<p>​        无论那一个国内，大概地说，都有三等人，上等、中等、下等。详细分析则有五等，大资产阶级、中产阶级、小资产阶级、半无产阶级、无产阶级。拿农村说：大地主是大资产阶级，小，地主是中产阶级，自耕农是小资产阶级，半自耕佃农是半无产阶级，雇农是无产阶级。拿都市说：大银行家、大商业家、大工业家是大资产阶级、钱庄主、中等商人、小工厂主是中产阶级，小商人、手工业主是小资产阶级，店员小贩手工业工人是半无产阶级，产业工人苦力是无产阶级。五种人各有不同的经济地位，各有不同的阶级性。因此对于现代的革命，乃发生反革命，半反革命，对革命守中立，参加革命和向革命的主力军种种不同的态度。</p>\n<p>​        小国各阶级对于民族革命的态度，与西欧资本主义国家的各阶级对社会革命的态度，几乎完全一样。看来好似奇怪，实际并不奇怪。因为现代的革命本是一个，其目的与手段均相同，即同以打倒国际资本帝国主义为目的。同以被压迫民族被压迫阶级联合作战为手段。这是现代革命异于历史上一切革命之最大的特点。</p>\n<p>我们试看中国社会各阶级是怎么样。</p>\n<h3 id=\"第一、大资产阶级\"><a href=\"#第一、大资产阶级\" class=\"headerlink\" title=\"第一、大资产阶级\"></a>第一、大资产阶级</h3><p>经济落后半殖民地的中国，大资产阶级完全是国际资产阶级的附庸。其生存和发展的条件，即附属于帝国主义。如买办阶级――与外资有密切关系之银行家（陆宋与东兼伯等）商业家（如唐绍仪何东等），工业瘃（如张寒盛恩照等）。</p>\n<p>大地主（如张作霖陈恭受等）。</p>\n<p>官僚（如孙宝琦颜惠庆等）。</p>\n<p>军阀（如张作霖曹锡等）。</p>\n<p>反动派知识阶级一一上列四种人之附属物，如买办性质的银行工商业高等员司，财阀，政府之高等事务员，政客，一部分在西洋留学生，一部分大学枝专门学校的教授和学生，大律师等都是这一类。</p>\n<p>这一个阶级与民族革命之目的完全不相容，始终站在帝国主义一边，乃极端的反革命派。其人数大概不出一百万即四万万人中四百分之一，乃民族革命运动中之死敌。</p>\n<h3 id=\"第二、中产阶级\"><a href=\"#第二、中产阶级\" class=\"headerlink\" title=\"第二、中产阶级\"></a>第二、中产阶级</h3><p>华资银行工商阶级（因在经济落后的中国，本国资本银行工商业的发展尚限在中产阶级地位．所谓银行业乃指小银行及钱庄，工业乃指小规模工厂，商业乃指国货商。凡是大规模银行工商业无不与外国资本有关系，只能算入买办阶级内。）</p>\n<p>小地主</p>\n<p>​       许多高等知识分子一华商银行工商业之从业员，大部分东西洋留学生，大部分大学校专门学校教授和学生，小律师等都是这一类。这个阶级的欲望为欲达到大资产阶级的地位，然受外资打击军阀压迫不能发展。这个阶级对于民族革命历取了矛盾的态度。即其受外资打击，军阀压迫感受痛苦时，需要革命，赞成反帝国主义反军阀的革命运动。但国内现在的革命运动，在国内有本国无产阶级的勇猛参加，在国外有国际无产阶级的积极援助，对于其欲达到大资产阶级地位的阶级的发展及存在，感觉着威胁又怀疑革命。这个阶级即所谓民族资产阶级，其政治的主张为国家主义一一实现民族资产阶级一阶级统治的国家。有一个戴季陶的，“真实信徒”（其自称如此）在北京晨报上发表议论说：“举起你的左手打倒帝国主义！举起你的右手打倒共产党！”乃活画出这个阶级的矛盾惶遽态度。他们反对以阶级斗争说解释民主主义，反对国民党联俄及容纳共产派分子。但这个阶级的企图一一实现民族资产阶级统治的国家，是完全不行，因为现在世界上局面，乃革命反革命两大势力作最后争斗的局面，这两大势力竖起两面大旗：一面是赤色的革命的大旗，第三国际高举着，号召全世界被压迫民族被压迫阶级集合子其旗帜之下，站在一边；一面是白色的反革命大旗，国际联盟高举着，号召全世界反革命分子都集于其旗帜之下，站在另一边。那些中间阶级，在西洋如所谓第二国际等类，在中国如所谓国家主义派等类，必须赶快的分化，或者向左跑入革命派或者向右跑入反革命派，没有他们“独立”革命思想，仅仅是个幻想。他们现在虽还站在半反革命的地位，他们现在虽然还不是我们正面的敌人，但到他们感觉工农阶级的威胁日甚时，即是为了工农阶级的利益迫他们让步稍多时（如农村中的减租运动，都市中的罢工运动）他们或他们的一部分（中产阶级右翼）一定会站入帝国主义一边，一定变为完全的反革命，一定要成为我们正面的敌人。本来买办阶级与非买办阶级，有一部是未能截然划分清楚的。以商业论，固然许多商人是洋货商土贷商划分得很清楚，但是在有些商店的店门内，是一部分摆设着土货，一部分又摆设着洋货。以知识阶级论，以小地主子弟的资格赴东洋资本主义国家读书的留学生，固然是明显的除了半身土气之外，又带上了半身洋气。即从小地主子弟的资格在国内专门学校大学校读书受着那半土半洋回国留学生的熏陶，仍然不免是些半身土气半身洋气的脚色。在这类人并不是纯民族的资产阶级性质，可以叫他们做“半民族资产阶级”。这种乃是中产阶级右翼，只要国民革命的斗争加深；这种人一定很快地跑入帝国主义军阀的队伍里，和买办阶级做着（资料不清）。中产险级左翼即与帝国主义完全无缘者，此派在某种情况（如抵制外国朝流高潮时）有革命性。及其死持之空虚的“和平”观念极破，而且对于所谓“赤化”时时怀着恐慌。故其对于反革命极为妥协，不能持久，故中国的中产阶级，无论其右翼，及其左翼，也包括许多危险成分，断不能望其勇敢地跑上革命的路，跟着其余的阶级忠实地做革命事业，除开少数历史和环境都有特别情况的人。中产阶级的人，在全国内至多每百个人里有一个（百分之一）即四百万人。</p>\n<h3 id=\"第三小资产阶级\"><a href=\"#第三小资产阶级\" class=\"headerlink\" title=\"第三小资产阶级\"></a>第三小资产阶级</h3><p>如：自耕农、小商、手工业主、小知识阶级――小员司、小事务员、中学学生、及中小学教员、小律师等都属于这类。这一个阶级，在人数上，在阶级性上，都值得大大注意。小资产的人数，单是自耕农就有一万万至一万万二千万，小商人手工业主，知识阶级，大概自二千万至三千万，合计达到一万万三千万，这个阶级虽然同在小资产阶级之经济地位，但实有三个不同的部分。第一部分：是有余钱剩米的，即用其体力或脑力劳动所得，除自给外，每年还有余剩，用以造成所谓资本的初步积累。这种人“发财”观念极重，虽不妄想发大财。却总想爬上那中产阶级地位。他们看只那些受人尊敬的小财东，往往垂着一尺长涎水，对于赵公元帅（俗财神）礼拜最劝。这种人胆子极小，他们怕官，也有点革命．因为他们的经济地位与中产阶级颇接近，故对于中产阶级的宣传颇相信，对于革命取怀疑的态度。但是这一部分人在小资产中占少数，大概不及小资产阶级全数百分之十约一千五百万，乃小一部资产阶级的右翼。第二部分是恰足自给的，每年收支恰足相抵，不多不少，这部分人比较第一部分人大不相同，他们也想发财，但是赵公元帅总不让他们岁财，随着近年帝国主义军阀大中资产阶级的压迫和剥削，使他们感觉现在的世界已经不是从前的世界。他们感觉现在如果只使用从前相等的劳力，就会不能维持生活。必须增加劳动时间，即每天起早晨，对手职业加倍注意，才能维持生活。他们有点骂人了，他们骂人叫“洋鬼子”，骂军阀叫“抢钱司令”，骂土豪劣绅叫“为富不仁”。对于反帝国主义反军阀的运动，仅怀疑其未能成功，理由是“洋人和司令的来头那么大”，不肯贸然参加，取了中立的态度，但绝不反对革命。这一部分人数甚多，大概小资产的一半：“十分之五”即七千五百万。第三部分是每年要亏本的。这一部分人，好些大概原先本是所谓殷实人家，渐渐变的仅仅保守，渐渐的要亏本了。他们每逢年终结账一次，就吃惊一次，说“咳，又亏了！”这种人因为他们从前过着次日子，后来逐年下降，负债渐多，渐次过着凄凉的日子，“瞻念前途，不寒而栗”。这种人，在精神上感觉的痛苦比一切人大，因为他们有一个从前与现在相反的比较。这种人在革命运动中颇要紧，颇有推动革命的力量。其人数占小资产阶级中百分之四十即六千万一个不小的群众，乃小资产阶级的左翼。以上说小资产阶级的三部分对于革命的态度在平时各不相同，但到战时即革命潮流高涨可以看得见胜利的曙光时，不但小资产阶级的左派参加革命，中派亦可以参加革命，即左派分子受了无产阶级及小资产阶级左派的革命大潮所裹挟，也只得附着革命。我们从工业运动和历年来各地农民运动的经验看来，这个鉴定是不错的。</p>\n<h3 id=\"第四、半无产阶级。此处所谓半无产阶级，乃包含：\"><a href=\"#第四、半无产阶级。此处所谓半无产阶级，乃包含：\" class=\"headerlink\" title=\"第四、半无产阶级。此处所谓半无产阶级，乃包含：\"></a>第四、半无产阶级。此处所谓半无产阶级，乃包含：</h3><p>（1）半自耕农（2）半益农（3）贫农（4）手业工工人（5）店员（6）小贩，之六种。半自耕农的数目，在中国农民中大概占五千万，半益农贫农大概各占六千万，三种共计一万万七千万，乃农村中一个颇大群众，所谓农民问题，一大半就是他们的问题。这三种农民有同属半无产阶级，然从经济状况仍有上中下三个细别：在半自耕农其生活苦于自耕农，因其食粮每年有一半不够，须租种别人田地或者作工或营小商以资弥补。春夏之间，青黄不接虽高利向别人借贷，重价向别人籴粮，较之自耕农之不求于人，自然说过要苦，然优于半益农，因半益农无土地，每年耕种只得收获之一半，半自耕农则租于别人的部分虽只收获一半，或且不足一半，然自有的部分都可全获，故半自耕农之革命性优于自耕农而不及半益农。半益农与贫农都是乡村的佃农，同受地主的剥削，然经济地位颇有分别，半益农无土地，然有比较充足之农具及相当数目的流动资本，此种农人，每年劳动结果自己可以得到一半，不足部分，种杂粮，捞鱼虾，饲鸡豕，勉强维持其生活，于艰难竭蹶之中，存聊以卒岁，想，故其生活苦于半自耕农，然较贫农为优，其革命性则优于半自耕农而不及贫农。贫农之无充足的农具，又无流动的资本，肥料不足，田亩歉收，送租之外，所得无几，荒时暴月向亲友乞哀告怜，借得几斗几升敷衍三日五日，债务丛集，如牛负重，乃农民中之极艰苦者，极易接近革命的宣传。手工业工人所以称以半无产阶级，因其自有工具，且系一种自由职业，其经济地位略与农业中半益农相当，因家庭负担之重，工资与生活物价之不相称，时有贫困的压迫或失业的恐慌，与半益农亦大致相当。店员为中小商人的雇员，以微簿的薪资，供事人畜的费用，物价年年增涨，而薪例往往须数年一更，偶与此辈倾谈，便见叫苦不迭，其地位与手工业工人不相上下，对于革命宣传极易接受。小贩不论是肩挑叫卖或于畔摊售，总之本小利微吃着不够，其地位与贫农不相上下，其需要一个变更现代的革命也和贫农相同。手工业工人人数，大概占全人口百分之六即二千四百万人，店员大概有五百万，小贩大概有一百万，合起半自耕农，半益农、佃农人数半无产阶级人数共计约二万万占全国人口之一半。</p>\n<h3 id=\"第五、无产阶级。其种类及人数如左，\"><a href=\"#第五、无产阶级。其种类及人数如左，\" class=\"headerlink\" title=\"第五、无产阶级。其种类及人数如左，\"></a>第五、无产阶级。其种类及人数如左，</h3><p>工业无产阶级约二百万；</p>\n<p>都市苦力约三百万；</p>\n<p>农业无产阶级约二千万；</p>\n<p>共约四千五百万。中国因经济落后，故产业工人（工业无产阶级）不多，二百万产业工人之中，主要为铁路、矿山、海运、纺织、造船五种产业，而大多数在外资产业之下，故工业无产阶级虽不多，却做了民族革命运动的主力。我们看四年以来的罢工运动，如海员罢工、铁路罢工，开源及焦作煤矿罢工，及五四后，上海、香港两处之大罢工所表现的力量，就可知工业无产阶级在民族革命中所处地位的重要。他们所以能如此，第一个原因是集中，无论那种人都不如他们“有组织的集中”，第二个原因，是经济地位低下。他们失去了工具，剩用两只手，绝了发财的望，又受着帝国主义、军阀买办阶级极惨酷的待遇，所以他们特别能奋斗。都市苦力的力量也很可注意，以码头搬运夫以人力车夫占大多数，粪夫清道夫等都属于这一类。他们除了一双手外，别无长物，其经济地位与产业工人相似，惟不及其有组织的集中及在生产力上的重要。中国尚少新式资本主义的农业，所谓农业无产阶级，乃指长工、月工、零工等雇农而言。此等雇农，不仅无土地，无农具，又无丝毫流动资本，故只得营工度日。其劳动时间之长，工资之少，待遇之薄，职业之不安定，超过其他工人，此种人在乡村中乃最感困难者，在农民运动中，与贫农处于同一要紧的地位。游民无产阶级为失了土地的农民与失了工作的机会的手工业工人，其人数在二千万以上，乃国内兵争匪祸的根源。此游民无产阶级中最多者为匪．其次为兵，次为乞丐，次为盗贼与娼妓。他们乃人类生活中最不安定者，他们在各地都有秘密的组织，如闽粤的“三合会”，湘、鄂、黔、蜀的“哥老会”，皖、豫、鲁等省的“大刀会”，直隶及东三省的“在理会”，上海等处的青红帮，都做了他们政治和经济争斗的互助机关。处置这一批人乃中国最大最难的问题，一个是贫乏，又一个是失业，故若解决了失业问题，就算是解决了中国问题的一半。这一批人很能勇敢奋斗，引导得法可以变成一种革命力量。</p>\n<p>谁是敌人谁是朋友，我们现在可以答复了，一切勾结帝国主义的军阀官僚，买办阶级，大地主，反动的知识阶级即所谓中国大资产阶级，乃是我们的敌人，乃是我们真正的敌人；一切小资产阶级、半无产阶级、无产阶级乃是我们的朋友，乃是我们真正的朋友；那动摇不定的中产阶级，其右翼应该把他当做我们的敌人，即使时非敌人也去敌人不远，其左翼可以把他们当做我们的朋友，但不是真正的朋友，我们要时常提防他，不要让他乱了我们的阵线，我们的真正敌人有多少？有四百万！让这四百万算做敌人，也不枉妄他们有一个五百万人的团体，依然抵不住三万万九千五百万人的一铺唾沫。三万万九千五百万人团结起来！</p>\n"},{"title":"Docker使用详解","date":"2024-03-20T04:07:03.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/60ba051fae5a9ba4024b9043.webp","abstracts":"本文主要介绍Docker的基本概念、安装、常用命令、镜像、容器、仓库等。","_content":"<p><img src=\"https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-03-19_17-56-24.png\" ></p>\n\n# 一.Docker简介\n## 1.Docker是什么\nDocker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n容器是完全使用沙箱机制，相互之间不会有任何接口。\nDocker 直接使用宿主机的内核，它可以运行在任何支持 Docker 的宿主机上。\n## 2.Docker的优势\n- 更高效的利用系统资源\n- 更快速的启动时间\n- 一致的运行环境\n- 持续交付和部署\n- 更轻松的迁移\n- 更轻松的维护和扩展\n\n\n# 二.Docker安装\n","source":"_posts/Docker.md","raw":"---\ntitle: Docker使用详解\ndate: 2024-03-20 12:07:03\ntags:\n  - Docker\ncategories:\n  - 运维\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/60ba051fae5a9ba4024b9043.webp\nabstracts : 本文主要介绍Docker的基本概念、安装、常用命令、镜像、容器、仓库等。\n---\n<p><img src=\"https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-03-19_17-56-24.png\" ></p>\n\n# 一.Docker简介\n## 1.Docker是什么\nDocker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n容器是完全使用沙箱机制，相互之间不会有任何接口。\nDocker 直接使用宿主机的内核，它可以运行在任何支持 Docker 的宿主机上。\n## 2.Docker的优势\n- 更高效的利用系统资源\n- 更快速的启动时间\n- 一致的运行环境\n- 持续交付和部署\n- 更轻松的迁移\n- 更轻松的维护和扩展\n\n\n# 二.Docker安装\n","slug":"Docker","published":1,"updated":"2024-03-22T05:30:16.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxb0005iou22wgr0bvr","content":"<p><img src=\"https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-03-19_17-56-24.png\" ></p>\n\n<h1 id=\"一-Docker简介\"><a href=\"#一-Docker简介\" class=\"headerlink\" title=\"一.Docker简介\"></a>一.Docker简介</h1><h2 id=\"1-Docker是什么\"><a href=\"#1-Docker是什么\" class=\"headerlink\" title=\"1.Docker是什么\"></a>1.Docker是什么</h2><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口。<br>Docker 直接使用宿主机的内核，它可以运行在任何支持 Docker 的宿主机上。</p>\n<h2 id=\"2-Docker的优势\"><a href=\"#2-Docker的优势\" class=\"headerlink\" title=\"2.Docker的优势\"></a>2.Docker的优势</h2><ul>\n<li>更高效的利用系统资源</li>\n<li>更快速的启动时间</li>\n<li>一致的运行环境</li>\n<li>持续交付和部署</li>\n<li>更轻松的迁移</li>\n<li>更轻松的维护和扩展</li>\n</ul>\n<h1 id=\"二-Docker安装\"><a href=\"#二-Docker安装\" class=\"headerlink\" title=\"二.Docker安装\"></a>二.Docker安装</h1>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-03-19_17-56-24.png\" ></p>\n\n<h1 id=\"一-Docker简介\"><a href=\"#一-Docker简介\" class=\"headerlink\" title=\"一.Docker简介\"></a>一.Docker简介</h1><h2 id=\"1-Docker是什么\"><a href=\"#1-Docker是什么\" class=\"headerlink\" title=\"1.Docker是什么\"></a>1.Docker是什么</h2><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口。<br>Docker 直接使用宿主机的内核，它可以运行在任何支持 Docker 的宿主机上。</p>\n<h2 id=\"2-Docker的优势\"><a href=\"#2-Docker的优势\" class=\"headerlink\" title=\"2.Docker的优势\"></a>2.Docker的优势</h2><ul>\n<li>更高效的利用系统资源</li>\n<li>更快速的启动时间</li>\n<li>一致的运行环境</li>\n<li>持续交付和部署</li>\n<li>更轻松的迁移</li>\n<li>更轻松的维护和扩展</li>\n</ul>\n<h1 id=\"二-Docker安装\"><a href=\"#二-Docker安装\" class=\"headerlink\" title=\"二.Docker安装\"></a>二.Docker安装</h1>"},{"title":"EJS 简介","author":{"name":"好名字都是狗起的","link":"https://hexo-git-test-3309446352s-projects.vercel.app/","avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg","description":"古来圣贤皆寂寞，惟有饮者留其名。","socials":{"github":"https://github.com/3309446352"}},"date":"2024-03-22T12:58:59.000Z","cover":null,"description":null,"abstracts":null,"_content":"# {{ title }}\n\n1. {{ description}}","source":"_posts/EJS-简介.md","raw":"---\ntitle: EJS 简介\nauthor:\n  name: 好名字都是狗起的\n  link: https://hexo-git-test-3309446352s-projects.vercel.app/\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\n  description: 古来圣贤皆寂寞，惟有饮者留其名。\n  socials:\n    github: https://github.com/3309446352\ndate: 2024-03-22 20:58:59\ntags:\ncategories:\ncover:\ndescription:\nabstracts:\n---\n# {{ title }}\n\n1. {{ description}}","slug":"EJS-简介","published":1,"updated":"2024-03-22T12:58:59.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxf0009iou2as1zaugx","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>EJS 简介</h1><ol>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>EJS 简介</h1><ol>\n<li></li>\n</ol>\n"},{"Tags":"-Hexo -aurora","abbrlink":"","author":{"avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/pr.png","description":"Think like an artist, code like an artisan.","link":"https://tridiamond.tech","name":"TriDiamond","socials":{"github":"https://github.com/tridiamond"}},"cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/illust_63502560_20210626_204746.jpg","date":"2020-08-15T10:49:36.000Z","title":"Hexo-aurora 文章属性配置详解","updated":"2024-03-23T14:22:41.663Z","_content":"```yaml\n---\ntitle: Article Title #标题\ndate: 2020-08-15 18:49:36 #时间\n\ntags:\n  - 博客搭建\ncategories:\ncover: https://cover.png #文章头像\nauthor:\n  name: TriDiamond # 作者名字\n  link: https://tridiamond.tech #链接\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2024-02-04_23-53-27.png #作者头像\n  description: 'Think like an artist, code like an artisan.' #简介\n  socials:\n    github: https://github.com/tridiamond #联系方式\n---\n```\n\n为博客预先配置作者列表，然后使用文章中预配置的属性。`author key``author`\n\n首先，您需要在主题配置文件中预先配置作者列表，该列表位于 .`_config.aurora.yml`\n\n```yaml\nauthors:\n  author-1:\n    name: TriDiamond\n    link: https://tridiamond.tech\n    avatar: https://avatar.png\n    description: 'Think like an artist, code like an artisan.'\n    socials:\n      github: https://github.com/tridiamond\n  author-2:\n    name: Jerry\n    avatar: https://Jerry.png\n    link: https://github.com/TriDiamond\n    description: 'I am Jerry, how are you?'\n    socials:\n      github: https://github.com/Jerry\n```\n\n- 然后你可以在主题配置中使用作者来设置文章 **Front-Meta** 中的作者。`keys`\n\n```yaml\n---\ntitle: Article Title\ndate: 2020-08-15 18:49:36\ntags:\n  - Tag\ncategories:\n  - Cate\ncover: https://cover.png\nauthor: author-1\n---\n```\n\n> 详情请见官方文档： [Plugins | Hexo Aurora Docs (tridiamond.tech)](https://aurora.tridiamond.tech/en/configs/plugins.html)\n","source":"_posts/Hexo-aurora.md","raw":"---\nTags: -Hexo -aurora\nabbrlink: ''\nauthor:\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/pr.png\n  description: Think like an artist, code like an artisan.\n  link: https://tridiamond.tech\n  name: TriDiamond\n  socials:\n    github: https://github.com/tridiamond\ncategories: []\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/illust_63502560_20210626_204746.jpg\ndate: '2020-08-15T18:49:36+08:00'\ntags: []\ntitle: Hexo-aurora 文章属性配置详解\nupdated: '2024-03-23T22:22:41.663+08:00'\n---\n```yaml\n---\ntitle: Article Title #标题\ndate: 2020-08-15 18:49:36 #时间\n\ntags:\n  - 博客搭建\ncategories:\ncover: https://cover.png #文章头像\nauthor:\n  name: TriDiamond # 作者名字\n  link: https://tridiamond.tech #链接\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2024-02-04_23-53-27.png #作者头像\n  description: 'Think like an artist, code like an artisan.' #简介\n  socials:\n    github: https://github.com/tridiamond #联系方式\n---\n```\n\n为博客预先配置作者列表，然后使用文章中预配置的属性。`author key``author`\n\n首先，您需要在主题配置文件中预先配置作者列表，该列表位于 .`_config.aurora.yml`\n\n```yaml\nauthors:\n  author-1:\n    name: TriDiamond\n    link: https://tridiamond.tech\n    avatar: https://avatar.png\n    description: 'Think like an artist, code like an artisan.'\n    socials:\n      github: https://github.com/tridiamond\n  author-2:\n    name: Jerry\n    avatar: https://Jerry.png\n    link: https://github.com/TriDiamond\n    description: 'I am Jerry, how are you?'\n    socials:\n      github: https://github.com/Jerry\n```\n\n- 然后你可以在主题配置中使用作者来设置文章 **Front-Meta** 中的作者。`keys`\n\n```yaml\n---\ntitle: Article Title\ndate: 2020-08-15 18:49:36\ntags:\n  - Tag\ncategories:\n  - Cate\ncover: https://cover.png\nauthor: author-1\n---\n```\n\n> 详情请见官方文档： [Plugins | Hexo Aurora Docs (tridiamond.tech)](https://aurora.tridiamond.tech/en/configs/plugins.html)\n","slug":"Hexo-aurora","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxg000biou2f93394p6","content":"<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">---\ntitle: Article Title #标题\ndate: 2020-08-15 18:49:36 #时间\n\ntags:\n  - 博客搭建\ncategories:\ncover: https:&#x2F;&#x2F;cover.png #文章头像\nauthor:\n  name: TriDiamond # 作者名字\n  link: https:&#x2F;&#x2F;tridiamond.tech #链接\n  avatar: https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;3309446352&#x2F;Images&#x2F;main&#x2F;img&#x2F;Snipaste_2024-02-04_23-53-27.png #作者头像\n  description: &#39;Think like an artist, code like an artisan.&#39; #简介\n  socials:\n    github: https:&#x2F;&#x2F;github.com&#x2F;tridiamond #联系方式\n---</code></pre>\n\n<p>为博客预先配置作者列表，然后使用文章中预配置的属性。<code>author key``author</code></p>\n<p>首先，您需要在主题配置文件中预先配置作者列表，该列表位于 .<code>_config.aurora.yml</code></p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">authors:\n  author-1:\n    name: TriDiamond\n    link: https:&#x2F;&#x2F;tridiamond.tech\n    avatar: https:&#x2F;&#x2F;avatar.png\n    description: &#39;Think like an artist, code like an artisan.&#39;\n    socials:\n      github: https:&#x2F;&#x2F;github.com&#x2F;tridiamond\n  author-2:\n    name: Jerry\n    avatar: https:&#x2F;&#x2F;Jerry.png\n    link: https:&#x2F;&#x2F;github.com&#x2F;TriDiamond\n    description: &#39;I am Jerry, how are you?&#39;\n    socials:\n      github: https:&#x2F;&#x2F;github.com&#x2F;Jerry</code></pre>\n\n<ul>\n<li>然后你可以在主题配置中使用作者来设置文章 <strong>Front-Meta</strong> 中的作者。<code>keys</code></li>\n</ul>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">---\ntitle: Article Title\ndate: 2020-08-15 18:49:36\ntags:\n  - Tag\ncategories:\n  - Cate\ncover: https:&#x2F;&#x2F;cover.png\nauthor: author-1\n---</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>详情请见官方文档： <a href=\"https://aurora.tridiamond.tech/en/configs/plugins.html\">Plugins | Hexo Aurora Docs (tridiamond.tech)</a></p></blockquote>\n","site":{"data":{}},"excerpt":"","more":"<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">---\ntitle: Article Title #标题\ndate: 2020-08-15 18:49:36 #时间\n\ntags:\n  - 博客搭建\ncategories:\ncover: https:&#x2F;&#x2F;cover.png #文章头像\nauthor:\n  name: TriDiamond # 作者名字\n  link: https:&#x2F;&#x2F;tridiamond.tech #链接\n  avatar: https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;3309446352&#x2F;Images&#x2F;main&#x2F;img&#x2F;Snipaste_2024-02-04_23-53-27.png #作者头像\n  description: &#39;Think like an artist, code like an artisan.&#39; #简介\n  socials:\n    github: https:&#x2F;&#x2F;github.com&#x2F;tridiamond #联系方式\n---</code></pre>\n\n<p>为博客预先配置作者列表，然后使用文章中预配置的属性。<code>author key``author</code></p>\n<p>首先，您需要在主题配置文件中预先配置作者列表，该列表位于 .<code>_config.aurora.yml</code></p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">authors:\n  author-1:\n    name: TriDiamond\n    link: https:&#x2F;&#x2F;tridiamond.tech\n    avatar: https:&#x2F;&#x2F;avatar.png\n    description: &#39;Think like an artist, code like an artisan.&#39;\n    socials:\n      github: https:&#x2F;&#x2F;github.com&#x2F;tridiamond\n  author-2:\n    name: Jerry\n    avatar: https:&#x2F;&#x2F;Jerry.png\n    link: https:&#x2F;&#x2F;github.com&#x2F;TriDiamond\n    description: &#39;I am Jerry, how are you?&#39;\n    socials:\n      github: https:&#x2F;&#x2F;github.com&#x2F;Jerry</code></pre>\n\n<ul>\n<li>然后你可以在主题配置中使用作者来设置文章 <strong>Front-Meta</strong> 中的作者。<code>keys</code></li>\n</ul>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">---\ntitle: Article Title\ndate: 2020-08-15 18:49:36\ntags:\n  - Tag\ncategories:\n  - Cate\ncover: https:&#x2F;&#x2F;cover.png\nauthor: author-1\n---</code></pre>\n\n<blockquote>\n<p>详情请见官方文档： <a href=\"https://aurora.tridiamond.tech/en/configs/plugins.html\">Plugins | Hexo Aurora Docs (tridiamond.tech)</a></p>\n</blockquote>\n"},{"abbrlink":"","abstracts":"","author":{"avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg","description":"古来圣贤皆寂寞，惟有饮者留其名。","link":"https://hexo-git-test-3309446352s-projects.vercel.app/","name":"好名字都是狗起的","socials":{"github":"https://github.com/3309446352"}},"cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/favicon.ico","date":"2024-03-22T23:50:50.000Z","description":"Qexo 是一个快速、强大、美观的在线 静态博客编辑器。使用 GPL3.0 开源协议。支持包括且不限于在 Vercel 等平台部署, 为您的静态博客添加动态的元素","title":"Qexo","updated":"2024-03-23T14:20:46.806Z","_content":"#  {{ title }}\n\n1. {{ description}}\n\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n\t<form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\">\n    </form>\n</div>\n","source":"_posts/Qexo.md","raw":"---\nabbrlink: ''\nabstracts: ''\nauthor:\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\n  description: 古来圣贤皆寂寞，惟有饮者留其名。\n  link: https://hexo-git-test-3309446352s-projects.vercel.app/\n  name: 好名字都是狗起的\n  socials:\n    github: https://github.com/3309446352\ncategories: []\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/favicon.ico\ndate: '2024-03-23T07:50:50+08:00'\ndescription: Qexo 是一个快速、强大、美观的在线 静态博客编辑器。使用 GPL3.0 开源协议。支持包括且不限于在 Vercel 等平台部署, 为您的静态博客添加动态的元素\ntags:\n- 博客搭建\ntitle: Qexo\nupdated: '2024-03-23T22:20:46.806+08:00'\n---\n#  {{ title }}\n\n1. {{ description}}\n\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n\t<form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\">\n    </form>\n</div>\n","slug":"Qexo","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxh000ciou20smscqnk","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>Qexo</h1><ol>\n<li>Qexo 是一个快速、强大、美观的在线 静态博客编辑器。使用 GPL3.0 开源协议。支持包括且不限于在 Vercel 等平台部署, 为您的静态博客添加动态的元素</li>\n</ol>\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n    <form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\">\n    </form>\n</div>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>Qexo</h1><ol>\n<li>Qexo 是一个快速、强大、美观的在线 静态博客编辑器。使用 GPL3.0 开源协议。支持包括且不限于在 Vercel 等平台部署, 为您的静态博客添加动态的元素</li>\n</ol>\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n    <form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\">\n    </form>\n</div>\n"},{"title":"Mysql","date":"2024-03-18T13:22:27.000Z","feature":true,"cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-03-27_21-42-14.png","_content":"\n# 1Mysql\n\n## **1****、数据库的三范式是什么**\n\n第一范式：列不可再分 **原子性**\n\n第二范式：行可以唯一区分，主键约束** 唯一性**\n\n第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束 **独立性**\n\n且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。\n\n## 18.事务的四大特性(ACID)\n\n原子性(Atomicity)： 要么全部成功要么全部失败。\n一致性(Consistency)： 事务执行前和事务执行后，原本和数据库一致的数据仍然一致。\n隔离性(Isolation)： 事务与事务之间互不干扰。\n持久性(Durability)： 事务一旦被提交了，那么对数据库中的数据的改变就是永久的。\n\n## 12.为什么使用B+树不用B树\n\n①B树只适合随机检索，而B+树同时支持随机检索和顺序检索(因为叶子节点相当于链表，保存索引值都是有序的)。\n顺序检索： 按照序列顺序遍历比较找到给定值。\n随机检索： 不断从序列中随机抽取数据进行比较，最终找到结果。\n\n②减少了磁盘IO，提高空间利用率： 因为B+树非叶子节点不会存放数据，只有索引值，所以非叶子节点可以保存更多的索引值，这样B+树就可以更矮，减少IO次数。\n\n③B+树适合范围查找： 这才是关键，因为数据库大部分都是范围查找，B+树的叶子节点是有序链表，直接遍历就行，而B树的范围查找可能两个节点距离很远，只能通过中序遍历去查找，所以使用B+树更合适。\n中序遍历： (根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）\n\n## 21.怎么优化数据库\n\n①SQL优化\n②加缓存\n③分表\n④读写分离\n\n## 22.SQL优化\n\n①不要用select *，要使用具体字段。\n②使用数值代替字符串，比如：0=唱，1=跳，2=rap。\n③避免返回大量数据，采用分页最好。\n④使用索引，提升查询速度，不宜建太多索引，不能建在重复数据比较多的字段上。\n⑤批量插入比单条插入要快，因为事务只需要开启一次，数据量太小体现不了。\n⑥避免子查询，优化为多表连接查询。\n⑦尽量使用union all替代union，因为union会自动去重。\n\n## **2****、数据库引擎有哪些**\n\n如何查看mysql提供的所有存储引擎\n\n`mysql> show engines;`\n\nmysql常用引擎包括：MYISAM、Innodb、Memory、MERGE\n\n- MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对\n- 较小，对事务完整性没有要求，以select、insert为主的应用基本上可以使用这引擎\n- Innodb:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键\n- 约束，并发能力强，占用空间是MYISAM的2.5倍，处理效率相对会差一些\n- Memory:全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在mysql重\n- 启时会丢失，默认使用HASH索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变\n- 化不频繁的代码表\n- MERGE：是一组MYISAM表的组合\n\n## **3****、****InnoDB****与****MyISAM****的区别\n\n1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，\n\n这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；\n\n2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；\n3. InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但\n\n是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，\n\n因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的\n\n是数据文件的指针。主键索引和辅助索引是独立的。\n\n4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一\n\n个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；\n\n5. Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；\n\nmysql> show engines;**如何选择引擎？**\n\n如果没有特别的需求，使用默认的 Innodb 即可。\n\nMyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。\n\nInnodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如\n\nOA自动化办公系统。\n\n**4****、数据库的事务**\n\n## 4****、数据库的事务**\n\n**什么是事务？**\n\n**：** 多条sql语句，要么全部成功，要么全部失败。\n\n**事务的特性：**\n\n**数据库事务特性：原子性****(Atomic)****、一致性****(Consistency)****、隔离性****(Isolation)****、持久性****(Durabiliy)****。**\n\n**简称****ACID****。**\n\n原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功，整个\n\n事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。\n\n一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如A\n\n转账100元给B，不管操作是否成功，A和B的账户总额是不变的。\n\n隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰\n\n持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。\n\n## **5**、索引问题\n\n索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于快速获取信息。\n\n你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，\n\n索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅\n\n速地找到表中的数据，而不必扫描整个数据库。\n\nmysql 有4种不同的索引：\n\n1. 主键索引（PRIMARY）\n2. 数据列不允许重复，不允许为NULL，一个表只能有一个主键。\n3. 唯一索引（UNIQUE）\n4. 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。\n5. 可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引\n6. 可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索\n7. 引\n8. 普通索引（INDEX）\n9. 可以通过 ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引\n10. 可以通过 ALTER TABLE table_name ADD INDEX index_name(column1, column2,\n11. column3); 创建组合索引\n12. 全文索引（FULLTEXT）\n13. 可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引\n\n**索引并非是越多越好，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时**\n\n**要花费较多的时间维护索引**\n\n1. 索引加快数据库的检索速度\n2. 索引降低了插入、删除、修改等维护任务的速度\n3. 唯一索引可以确保每一行数据的唯一性\n4. 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能\n5. 索引需要占物理和数据空间\n\n## 6、SQL优化\n\n1、查询语句中不要使用select *\n\n2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代\n\n3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代\n\n4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union\n\nall会更好)\n\n5、应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。\n\n6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫\n\n描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null\n\n值，然后这样查询： select id from t where num=0\n\n## **7****、简单说一说****drop****、****delete****与****truncate****的区别**\n\nSQL中的drop、delete、truncate都表示删除，但是三者有一些差别\n\ndelete和truncate只删除表的数据不删除表的结构\n\n速度,一般来说: drop> truncate >delete\n\ndelete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;\n\n如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback\n\nsegment中,不能回滚. 操作不触发trigger.\n\n## **8****、什么是视图**\n\n视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一\n\n个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表\n\n查询。\n\n## **9****、 什么是内联接、左外联接、右外联接？**\n\n1. 内联接（Inner Join）：匹配2张表中相关联的记录。\n2. 左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，\n3. 右表中未匹配到的字段用NULL表示。\n4. 右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，\n5. 左表中未匹配到的字段用NULL表示。在判定左表和右表时，要根据表名出现在Outer Join的左右\n6. 位置关系。\n\n## **10****、并发事务带来哪些问题****?****隔离级别**\n\n**脏读**\n\n**不可重复读**\n\n**幻影读**\n\nREAD-UNCOMMITTED\n\n√\n\n√\n\n√\n\nREAD-COMMITTED\n\n×\n\n√\n\n√\n\nREPEATABLE-READ\n\n×\n\n×\n\n√\n\nSERIALIZABLE\n\n×\n\n×\n\n×\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一\n\n数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n\n**脏读（****Dirty read****）****:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到\n\n数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提\n\n交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确\n\n的。\n\n**丢失修改（****Lost to modify****）****:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那\n\n么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结\n\n果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事\n\n务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。\n\n**不可重复读（****Unrepeatableread****）****:** 指在一个事务内多次读同一数据。在这个事务还没有结束\n\n时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改\n\n导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样\n\n的情况，因此称为不可重复读。\n\n**幻读（****Phantom read****）****:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接\n\n着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了\n\n一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n**不可重复读和幻读区别：**\n\n不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者\n\n删除比如多次读取一条记录发现记录增多或减少了。\n\n## **11****、事务隔离级别有哪些****?MySQL****的默认隔离级别是****?**\n\n**SQL** **标准定义了四个隔离级别：**\n\n**READ-UNCOMMITTED(****读取未提交****)****：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会**\n\n**导致脏读、幻读或不可重复读**。\n\n**READ-COMMITTED(****读取已提交****)****：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻**\n\n**读或不可重复读仍有可能发生**。\n\n**REPEATABLE-READ(****可重复读****)****：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务\n\n自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。\n\n**SERIALIZABLE(****可串行化****)****：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执\n\n行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻**\n\n**读**。\n\nMySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ****（可重读）**。我们可以通过\n\nSELECT @@tx_isolation; 命令来查看这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ****（可重读）**\n\n事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如\n\nSQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ****（可重**\n\n**读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 **SERIALIZABLE(****可串行化****)** 隔离级\n\n别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ\u0002**\n\n**COMMITTED(****读取提交内容****)** ，但是你要知道的是InnoDB 存储引擎默认使用 **REPEAaTABLE\u0002**\n\n**READ****（可重读）** 并不会有任何性能损失。\n\nInnoDB 存储引擎在 **分布式事务** 的情况下一般会用到 **SERIALIZABLE(****可串行化****)** 隔离级别。\n\n## **12****、大表如何优化？**\n\n当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：\n\n**1.** **限定数据的范围**\n\n务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以\n\n控制在一个月的范围内；\n\n**2.** **读****/****写分离**\n\n经典的数据库拆分方案，主库负责写，从库负责读；\n\n**3.** **垂直分区**\n\n**根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，\n\n可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。\n\n**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大\n\n家应该就更容易理解了。\n\n**垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂\n\n直分区可以简化表的结构，易于维护。\n\n**垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行\n\nJoin来解决。此外，垂直分区会让事务变得更加复杂；\n\n**4.** **水平分区**\n\nmysql> SELECT @@tx_isolation;\n\n+-----------------+\n\n| @@tx_isolation |\n\n+-----------------+\n\n| REPEATABLE-READ |\n\n+-----------------+**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了**\n\n**分布式的目的。 水平拆分可以支撑非常大的数据量。**\n\n水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成\n\n多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据\n\n量过大对性能造成影响。\n\n水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但\n\n由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好**\n\n**分库** 。\n\n水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨节点Join性能较\n\n差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、**\n\n**部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题\n\n的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。\n\n**下面补充一下数据库分片的两种常见方案：**\n\n**客户端代理： 分片逻辑在应用端，封装在****jar****包中，通过修改或者封装****JDBC****层来实现。** 当当网的\n\n**Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。\n\n**中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在\n\n谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。\n\n详细内容可以参考： MySQL大表优化方案: https://segmentfault.com/a/1190000006158186\n\n## **13****、分库分表之后****,id** **主键如何处理？**\n\n因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来\n\n支持。\n\n生成全局 id 有下面这几种方式：\n\n**UUID**：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的\n\n名字的标示比如文件的名字。\n\n**数据库自增** **id** : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成\n\n的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。\n\n**利用** **redis** **生成** **id :** 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更\n\n加复杂，可用性降低，编码更加复杂，增加了系统成本。\n\n**Twitter****的****snowflake****算法** ：Github 地址：https://github.com/twitter-archive/snowflake。\n\n**美团的****Leaf****分布式****ID****生成系统** ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递\n\n增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、\n\nZookeeper等中间件。感觉还不错。美团技术团队的一篇文章：https://tech.meituan.com/2017/\n\n04/21/mt-leaf.html 。**14****、****mysql****有关权限的表都有哪几个**\n\nMySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由\n\nmysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分\n\n别介绍一下这些表的结构和内容：\n\nuser权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。\n\ndb权限表：记录各个帐号在各个数据库上的操作权限。\n\ntable_priv权限表：记录数据表级的操作权限。\n\ncolumns_priv权限表：记录数据列级的操作权限。\n\nhost权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受\n\nGRANT和REVOKE语句的影响。\n\n## **15****、****mysql****有哪些数据类型**\n\n**1****、整数类型** ，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3\n\n字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整\n\n数。\n\n长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意\n\n义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配\n\n合使用才有意义。\n\n例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数\n\n据库实际存储数据为00012。\n\n**2****、实数类型**，包括FLOAT、DOUBLE、DECIMAL。\n\nDECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。\n\n而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。\n\n计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。\n\n**3****、字符串类型**，包括VARCHAR、CHAR、TEXT、BLOB\n\nVARCHAR用于存储可变长字符串，它比定长类型更节省空间。\n\nVARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2\n\n字节表示。\n\nVARCHAR存储的内容超出设置的长度时，内容会被截断。\n\nCHAR是定长的，根据定义的字符串长度分配足够的空间。\n\nCHAR会根据需要使用空格进行填充方便比较。\n\nCHAR适合存储很短的字符串，或者所有值都接近同一个长度。\n\nCHAR存储的内容超出设置的长度时，内容同样会被截断。\n\n**使用策略：**\n\n对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。\n\n对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。\n\n使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。\n\n尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。\n\n**4****、枚举类型（****ENUM****）**，把不重复的数据存储为一个预定义的集合。\n\n有时可以使用ENUM代替常用的字符串类型。\n\nENUM存储非常紧凑，会把列表值压缩到一个或两个字节。\n\nENUM在内部存储时，其实存的是整数。\n\n尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。\n\n排序是按照内部存储的整数**5****、日期和时间类型**，尽量使用timestamp，空间效率高于datetime，\n\n用整数保存时间戳通常不方便处理。\n\n如果需要存储微妙，可以使用bigint存储。\n\n看到这里，这道真题是不是就比较容易回答了。\n\n## **16****、创建索引的三种方式，删除索引**\n\n第一种方式：在执行CREATE TABLE时创建索引\n\n第二种方式：使用ALTER TABLE命令去增加索引\n\nALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。\n\n其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分\n\n隔。\n\n索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER\n\nTABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。\n\n第三种方式：使用CREATE INDEX命令创建\n\nCREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）\n\n删除索引\n\n根据索引名删除普通索引、唯一索引、全文索引： alter table 表名 drop KEY 索引名\n\n删除主键索引： alter table 表名 drop primary key （因为主键只有一个）。这里值得注意的是，\n\n如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：\n\nCREATE TABLE user_index2 (\n\nid INT auto_increment PRIMARY KEY,\n\nfirst_name VARCHAR (16),\n\nlast_name VARCHAR (16),\n\nid_card VARCHAR (18),\n\ninformation text,\n\nKEY name (first_name, last_name),\n\nFULLTEXT KEY (information),\n\nUNIQUE KEY (id_card)\n\n);\n\nALTER TABLE table_name ADD INDEX index_name (column_list);\n\nCREATE INDEX index_name ON table_name (column_list);\n\nalter table user_index drop KEY name;\n\nalter table user_index drop KEY id_card;\n\nalter table user_index drop KEY information;需要取消自增长再行删除：\n\n但通常不会删除主键，因为设计主键一定与业务逻辑无关。\n\n## 4.索引是什么\n\n是一种高效获取数据的数据结构，相当于目录，更快的找到数据，是一个文件，占用物理空间。\n\n## 5.索引的优点和缺点\n\n优点：\n①提高检索的速度。\n②索引列对数据排序，降低排序成本。\n③mysql 8之后引入了，隐藏索引，当一个索引被隐藏就不会被优化器所使用，就可以看出来索引对数据库的影响，有利于调优。\n缺点：\n①索引也是一个文件，所以会占用空间。\n②降低更新的速度，因为不光要更新数据，还要更新索引。\n\n## 6.索引的类型\n\n①普通索引： 基本索引类型，允许定义索引的字段为空值和重复值。\n②唯一索引： 索引的值必须唯一，允许定义索引的字段为空值。\n③主键索引： 索引的值必须唯一，不可以为空。\n④复合索引： 多个字段加索引，遵守最左匹配规则。\n⑤全局索引： 只有在 MyISAM 引擎上才能使用。\n\n## 7.索引怎么设计(优化)\n\n①选择唯一性索引：值是唯一的，查询的更快。\n②经常作为查询条件的字段加索引。\n③为经常需要排序、分组和联合操作的字段建立索引：order by、group by、union(联合)、distinct(去重)等。\n④限制索引个数：索引数量多，需要的磁盘空间就越多，更新表时，对索引的重构和更新就很费劲。\n⑤表数据少的不建议使用索引(百万级以内)：数据过少，有可能查询的速度，比遍历索引的速度都快。\n⑥删除不常用和不再使用的索引。\n⑦用类型小的类型做索引：比如：int和BIGINT能用int就使用int。因为类型小，查询速度快和索引占用的空间更少。\n⑧使用前缀索引，要是字符串越长，那么索引占的空间越大，并且比较起来就时间就越长。\n\n## 1.char和varchar的区别\n\n①char设置多少长度就是多少长度，varchar可以改变长度，所以char的空间利用率不如varchar的空间利用率高。\n②因为长度固定，所以存取速度要比varchar快。\n③char适用于固定长度的字符串，比如身份证号、手机号等，varchar适用于不固定的字符串。\n","source":"_posts/Mysql.md","raw":"---\ntitle: Mysql\ndate: 2024-03-18 21:22:27\ntags: \n  -Mysql\ncategories:\n  - 数据库\nfeature: true\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-03-27_21-42-14.png\n---\n\n# 1Mysql\n\n## **1****、数据库的三范式是什么**\n\n第一范式：列不可再分 **原子性**\n\n第二范式：行可以唯一区分，主键约束** 唯一性**\n\n第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束 **独立性**\n\n且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。\n\n## 18.事务的四大特性(ACID)\n\n原子性(Atomicity)： 要么全部成功要么全部失败。\n一致性(Consistency)： 事务执行前和事务执行后，原本和数据库一致的数据仍然一致。\n隔离性(Isolation)： 事务与事务之间互不干扰。\n持久性(Durability)： 事务一旦被提交了，那么对数据库中的数据的改变就是永久的。\n\n## 12.为什么使用B+树不用B树\n\n①B树只适合随机检索，而B+树同时支持随机检索和顺序检索(因为叶子节点相当于链表，保存索引值都是有序的)。\n顺序检索： 按照序列顺序遍历比较找到给定值。\n随机检索： 不断从序列中随机抽取数据进行比较，最终找到结果。\n\n②减少了磁盘IO，提高空间利用率： 因为B+树非叶子节点不会存放数据，只有索引值，所以非叶子节点可以保存更多的索引值，这样B+树就可以更矮，减少IO次数。\n\n③B+树适合范围查找： 这才是关键，因为数据库大部分都是范围查找，B+树的叶子节点是有序链表，直接遍历就行，而B树的范围查找可能两个节点距离很远，只能通过中序遍历去查找，所以使用B+树更合适。\n中序遍历： (根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）\n\n## 21.怎么优化数据库\n\n①SQL优化\n②加缓存\n③分表\n④读写分离\n\n## 22.SQL优化\n\n①不要用select *，要使用具体字段。\n②使用数值代替字符串，比如：0=唱，1=跳，2=rap。\n③避免返回大量数据，采用分页最好。\n④使用索引，提升查询速度，不宜建太多索引，不能建在重复数据比较多的字段上。\n⑤批量插入比单条插入要快，因为事务只需要开启一次，数据量太小体现不了。\n⑥避免子查询，优化为多表连接查询。\n⑦尽量使用union all替代union，因为union会自动去重。\n\n## **2****、数据库引擎有哪些**\n\n如何查看mysql提供的所有存储引擎\n\n`mysql> show engines;`\n\nmysql常用引擎包括：MYISAM、Innodb、Memory、MERGE\n\n- MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对\n- 较小，对事务完整性没有要求，以select、insert为主的应用基本上可以使用这引擎\n- Innodb:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键\n- 约束，并发能力强，占用空间是MYISAM的2.5倍，处理效率相对会差一些\n- Memory:全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在mysql重\n- 启时会丢失，默认使用HASH索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变\n- 化不频繁的代码表\n- MERGE：是一组MYISAM表的组合\n\n## **3****、****InnoDB****与****MyISAM****的区别\n\n1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，\n\n这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；\n\n2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；\n3. InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但\n\n是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，\n\n因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的\n\n是数据文件的指针。主键索引和辅助索引是独立的。\n\n4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一\n\n个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；\n\n5. Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；\n\nmysql> show engines;**如何选择引擎？**\n\n如果没有特别的需求，使用默认的 Innodb 即可。\n\nMyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。\n\nInnodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如\n\nOA自动化办公系统。\n\n**4****、数据库的事务**\n\n## 4****、数据库的事务**\n\n**什么是事务？**\n\n**：** 多条sql语句，要么全部成功，要么全部失败。\n\n**事务的特性：**\n\n**数据库事务特性：原子性****(Atomic)****、一致性****(Consistency)****、隔离性****(Isolation)****、持久性****(Durabiliy)****。**\n\n**简称****ACID****。**\n\n原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功，整个\n\n事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。\n\n一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如A\n\n转账100元给B，不管操作是否成功，A和B的账户总额是不变的。\n\n隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰\n\n持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。\n\n## **5**、索引问题\n\n索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于快速获取信息。\n\n你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，\n\n索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅\n\n速地找到表中的数据，而不必扫描整个数据库。\n\nmysql 有4种不同的索引：\n\n1. 主键索引（PRIMARY）\n2. 数据列不允许重复，不允许为NULL，一个表只能有一个主键。\n3. 唯一索引（UNIQUE）\n4. 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。\n5. 可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引\n6. 可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索\n7. 引\n8. 普通索引（INDEX）\n9. 可以通过 ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引\n10. 可以通过 ALTER TABLE table_name ADD INDEX index_name(column1, column2,\n11. column3); 创建组合索引\n12. 全文索引（FULLTEXT）\n13. 可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引\n\n**索引并非是越多越好，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时**\n\n**要花费较多的时间维护索引**\n\n1. 索引加快数据库的检索速度\n2. 索引降低了插入、删除、修改等维护任务的速度\n3. 唯一索引可以确保每一行数据的唯一性\n4. 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能\n5. 索引需要占物理和数据空间\n\n## 6、SQL优化\n\n1、查询语句中不要使用select *\n\n2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代\n\n3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代\n\n4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union\n\nall会更好)\n\n5、应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。\n\n6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫\n\n描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null\n\n值，然后这样查询： select id from t where num=0\n\n## **7****、简单说一说****drop****、****delete****与****truncate****的区别**\n\nSQL中的drop、delete、truncate都表示删除，但是三者有一些差别\n\ndelete和truncate只删除表的数据不删除表的结构\n\n速度,一般来说: drop> truncate >delete\n\ndelete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;\n\n如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback\n\nsegment中,不能回滚. 操作不触发trigger.\n\n## **8****、什么是视图**\n\n视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一\n\n个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表\n\n查询。\n\n## **9****、 什么是内联接、左外联接、右外联接？**\n\n1. 内联接（Inner Join）：匹配2张表中相关联的记录。\n2. 左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，\n3. 右表中未匹配到的字段用NULL表示。\n4. 右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，\n5. 左表中未匹配到的字段用NULL表示。在判定左表和右表时，要根据表名出现在Outer Join的左右\n6. 位置关系。\n\n## **10****、并发事务带来哪些问题****?****隔离级别**\n\n**脏读**\n\n**不可重复读**\n\n**幻影读**\n\nREAD-UNCOMMITTED\n\n√\n\n√\n\n√\n\nREAD-COMMITTED\n\n×\n\n√\n\n√\n\nREPEATABLE-READ\n\n×\n\n×\n\n√\n\nSERIALIZABLE\n\n×\n\n×\n\n×\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一\n\n数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n\n**脏读（****Dirty read****）****:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到\n\n数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提\n\n交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确\n\n的。\n\n**丢失修改（****Lost to modify****）****:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那\n\n么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结\n\n果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事\n\n务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。\n\n**不可重复读（****Unrepeatableread****）****:** 指在一个事务内多次读同一数据。在这个事务还没有结束\n\n时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改\n\n导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样\n\n的情况，因此称为不可重复读。\n\n**幻读（****Phantom read****）****:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接\n\n着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了\n\n一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n**不可重复读和幻读区别：**\n\n不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者\n\n删除比如多次读取一条记录发现记录增多或减少了。\n\n## **11****、事务隔离级别有哪些****?MySQL****的默认隔离级别是****?**\n\n**SQL** **标准定义了四个隔离级别：**\n\n**READ-UNCOMMITTED(****读取未提交****)****：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会**\n\n**导致脏读、幻读或不可重复读**。\n\n**READ-COMMITTED(****读取已提交****)****：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻**\n\n**读或不可重复读仍有可能发生**。\n\n**REPEATABLE-READ(****可重复读****)****：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务\n\n自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。\n\n**SERIALIZABLE(****可串行化****)****：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执\n\n行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻**\n\n**读**。\n\nMySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ****（可重读）**。我们可以通过\n\nSELECT @@tx_isolation; 命令来查看这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ****（可重读）**\n\n事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如\n\nSQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ****（可重**\n\n**读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 **SERIALIZABLE(****可串行化****)** 隔离级\n\n别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ\u0002**\n\n**COMMITTED(****读取提交内容****)** ，但是你要知道的是InnoDB 存储引擎默认使用 **REPEAaTABLE\u0002**\n\n**READ****（可重读）** 并不会有任何性能损失。\n\nInnoDB 存储引擎在 **分布式事务** 的情况下一般会用到 **SERIALIZABLE(****可串行化****)** 隔离级别。\n\n## **12****、大表如何优化？**\n\n当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：\n\n**1.** **限定数据的范围**\n\n务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以\n\n控制在一个月的范围内；\n\n**2.** **读****/****写分离**\n\n经典的数据库拆分方案，主库负责写，从库负责读；\n\n**3.** **垂直分区**\n\n**根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，\n\n可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。\n\n**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大\n\n家应该就更容易理解了。\n\n**垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂\n\n直分区可以简化表的结构，易于维护。\n\n**垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行\n\nJoin来解决。此外，垂直分区会让事务变得更加复杂；\n\n**4.** **水平分区**\n\nmysql> SELECT @@tx_isolation;\n\n+-----------------+\n\n| @@tx_isolation |\n\n+-----------------+\n\n| REPEATABLE-READ |\n\n+-----------------+**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了**\n\n**分布式的目的。 水平拆分可以支撑非常大的数据量。**\n\n水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成\n\n多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据\n\n量过大对性能造成影响。\n\n水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但\n\n由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好**\n\n**分库** 。\n\n水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨节点Join性能较\n\n差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、**\n\n**部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题\n\n的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。\n\n**下面补充一下数据库分片的两种常见方案：**\n\n**客户端代理： 分片逻辑在应用端，封装在****jar****包中，通过修改或者封装****JDBC****层来实现。** 当当网的\n\n**Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。\n\n**中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在\n\n谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。\n\n详细内容可以参考： MySQL大表优化方案: https://segmentfault.com/a/1190000006158186\n\n## **13****、分库分表之后****,id** **主键如何处理？**\n\n因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来\n\n支持。\n\n生成全局 id 有下面这几种方式：\n\n**UUID**：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的\n\n名字的标示比如文件的名字。\n\n**数据库自增** **id** : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成\n\n的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。\n\n**利用** **redis** **生成** **id :** 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更\n\n加复杂，可用性降低，编码更加复杂，增加了系统成本。\n\n**Twitter****的****snowflake****算法** ：Github 地址：https://github.com/twitter-archive/snowflake。\n\n**美团的****Leaf****分布式****ID****生成系统** ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递\n\n增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、\n\nZookeeper等中间件。感觉还不错。美团技术团队的一篇文章：https://tech.meituan.com/2017/\n\n04/21/mt-leaf.html 。**14****、****mysql****有关权限的表都有哪几个**\n\nMySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由\n\nmysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分\n\n别介绍一下这些表的结构和内容：\n\nuser权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。\n\ndb权限表：记录各个帐号在各个数据库上的操作权限。\n\ntable_priv权限表：记录数据表级的操作权限。\n\ncolumns_priv权限表：记录数据列级的操作权限。\n\nhost权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受\n\nGRANT和REVOKE语句的影响。\n\n## **15****、****mysql****有哪些数据类型**\n\n**1****、整数类型** ，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3\n\n字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整\n\n数。\n\n长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意\n\n义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配\n\n合使用才有意义。\n\n例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数\n\n据库实际存储数据为00012。\n\n**2****、实数类型**，包括FLOAT、DOUBLE、DECIMAL。\n\nDECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。\n\n而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。\n\n计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。\n\n**3****、字符串类型**，包括VARCHAR、CHAR、TEXT、BLOB\n\nVARCHAR用于存储可变长字符串，它比定长类型更节省空间。\n\nVARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2\n\n字节表示。\n\nVARCHAR存储的内容超出设置的长度时，内容会被截断。\n\nCHAR是定长的，根据定义的字符串长度分配足够的空间。\n\nCHAR会根据需要使用空格进行填充方便比较。\n\nCHAR适合存储很短的字符串，或者所有值都接近同一个长度。\n\nCHAR存储的内容超出设置的长度时，内容同样会被截断。\n\n**使用策略：**\n\n对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。\n\n对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。\n\n使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。\n\n尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。\n\n**4****、枚举类型（****ENUM****）**，把不重复的数据存储为一个预定义的集合。\n\n有时可以使用ENUM代替常用的字符串类型。\n\nENUM存储非常紧凑，会把列表值压缩到一个或两个字节。\n\nENUM在内部存储时，其实存的是整数。\n\n尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。\n\n排序是按照内部存储的整数**5****、日期和时间类型**，尽量使用timestamp，空间效率高于datetime，\n\n用整数保存时间戳通常不方便处理。\n\n如果需要存储微妙，可以使用bigint存储。\n\n看到这里，这道真题是不是就比较容易回答了。\n\n## **16****、创建索引的三种方式，删除索引**\n\n第一种方式：在执行CREATE TABLE时创建索引\n\n第二种方式：使用ALTER TABLE命令去增加索引\n\nALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。\n\n其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分\n\n隔。\n\n索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER\n\nTABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。\n\n第三种方式：使用CREATE INDEX命令创建\n\nCREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）\n\n删除索引\n\n根据索引名删除普通索引、唯一索引、全文索引： alter table 表名 drop KEY 索引名\n\n删除主键索引： alter table 表名 drop primary key （因为主键只有一个）。这里值得注意的是，\n\n如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：\n\nCREATE TABLE user_index2 (\n\nid INT auto_increment PRIMARY KEY,\n\nfirst_name VARCHAR (16),\n\nlast_name VARCHAR (16),\n\nid_card VARCHAR (18),\n\ninformation text,\n\nKEY name (first_name, last_name),\n\nFULLTEXT KEY (information),\n\nUNIQUE KEY (id_card)\n\n);\n\nALTER TABLE table_name ADD INDEX index_name (column_list);\n\nCREATE INDEX index_name ON table_name (column_list);\n\nalter table user_index drop KEY name;\n\nalter table user_index drop KEY id_card;\n\nalter table user_index drop KEY information;需要取消自增长再行删除：\n\n但通常不会删除主键，因为设计主键一定与业务逻辑无关。\n\n## 4.索引是什么\n\n是一种高效获取数据的数据结构，相当于目录，更快的找到数据，是一个文件，占用物理空间。\n\n## 5.索引的优点和缺点\n\n优点：\n①提高检索的速度。\n②索引列对数据排序，降低排序成本。\n③mysql 8之后引入了，隐藏索引，当一个索引被隐藏就不会被优化器所使用，就可以看出来索引对数据库的影响，有利于调优。\n缺点：\n①索引也是一个文件，所以会占用空间。\n②降低更新的速度，因为不光要更新数据，还要更新索引。\n\n## 6.索引的类型\n\n①普通索引： 基本索引类型，允许定义索引的字段为空值和重复值。\n②唯一索引： 索引的值必须唯一，允许定义索引的字段为空值。\n③主键索引： 索引的值必须唯一，不可以为空。\n④复合索引： 多个字段加索引，遵守最左匹配规则。\n⑤全局索引： 只有在 MyISAM 引擎上才能使用。\n\n## 7.索引怎么设计(优化)\n\n①选择唯一性索引：值是唯一的，查询的更快。\n②经常作为查询条件的字段加索引。\n③为经常需要排序、分组和联合操作的字段建立索引：order by、group by、union(联合)、distinct(去重)等。\n④限制索引个数：索引数量多，需要的磁盘空间就越多，更新表时，对索引的重构和更新就很费劲。\n⑤表数据少的不建议使用索引(百万级以内)：数据过少，有可能查询的速度，比遍历索引的速度都快。\n⑥删除不常用和不再使用的索引。\n⑦用类型小的类型做索引：比如：int和BIGINT能用int就使用int。因为类型小，查询速度快和索引占用的空间更少。\n⑧使用前缀索引，要是字符串越长，那么索引占的空间越大，并且比较起来就时间就越长。\n\n## 1.char和varchar的区别\n\n①char设置多少长度就是多少长度，varchar可以改变长度，所以char的空间利用率不如varchar的空间利用率高。\n②因为长度固定，所以存取速度要比varchar快。\n③char适用于固定长度的字符串，比如身份证号、手机号等，varchar适用于不固定的字符串。\n","slug":"Mysql","published":1,"updated":"2024-03-20T06:24:41.115Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxj000giou2gbv25k8p","content":"<h1 id=\"1Mysql\"><a href=\"#1Mysql\" class=\"headerlink\" title=\"1Mysql\"></a>1Mysql</h1><h2 id=\"1-、数据库的三范式是什么\"><a href=\"#1-、数据库的三范式是什么\" class=\"headerlink\" title=\"1****、数据库的三范式是什么\"></a><strong>1****、数据库的三范式是什么</strong></h2><p>第一范式：列不可再分 <strong>原子性</strong></p>\n<p>第二范式：行可以唯一区分，主键约束** 唯一性**</p>\n<p>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束 <strong>独立性</strong></p>\n<p>且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。</p>\n<h2 id=\"18-事务的四大特性-ACID\"><a href=\"#18-事务的四大特性-ACID\" class=\"headerlink\" title=\"18.事务的四大特性(ACID)\"></a>18.事务的四大特性(ACID)</h2><p>原子性(Atomicity)： 要么全部成功要么全部失败。<br>一致性(Consistency)： 事务执行前和事务执行后，原本和数据库一致的数据仍然一致。<br>隔离性(Isolation)： 事务与事务之间互不干扰。<br>持久性(Durability)： 事务一旦被提交了，那么对数据库中的数据的改变就是永久的。</p>\n<h2 id=\"12-为什么使用B-树不用B树\"><a href=\"#12-为什么使用B-树不用B树\" class=\"headerlink\" title=\"12.为什么使用B+树不用B树\"></a>12.为什么使用B+树不用B树</h2><p>①B树只适合随机检索，而B+树同时支持随机检索和顺序检索(因为叶子节点相当于链表，保存索引值都是有序的)。<br>顺序检索： 按照序列顺序遍历比较找到给定值。<br>随机检索： 不断从序列中随机抽取数据进行比较，最终找到结果。</p>\n<p>②减少了磁盘IO，提高空间利用率： 因为B+树非叶子节点不会存放数据，只有索引值，所以非叶子节点可以保存更多的索引值，这样B+树就可以更矮，减少IO次数。</p>\n<p>③B+树适合范围查找： 这才是关键，因为数据库大部分都是范围查找，B+树的叶子节点是有序链表，直接遍历就行，而B树的范围查找可能两个节点距离很远，只能通过中序遍历去查找，所以使用B+树更合适。<br>中序遍历： (根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）</p>\n<h2 id=\"21-怎么优化数据库\"><a href=\"#21-怎么优化数据库\" class=\"headerlink\" title=\"21.怎么优化数据库\"></a>21.怎么优化数据库</h2><p>①SQL优化<br>②加缓存<br>③分表<br>④读写分离</p>\n<h2 id=\"22-SQL优化\"><a href=\"#22-SQL优化\" class=\"headerlink\" title=\"22.SQL优化\"></a>22.SQL优化</h2><p>①不要用select *，要使用具体字段。<br>②使用数值代替字符串，比如：0&#x3D;唱，1&#x3D;跳，2&#x3D;rap。<br>③避免返回大量数据，采用分页最好。<br>④使用索引，提升查询速度，不宜建太多索引，不能建在重复数据比较多的字段上。<br>⑤批量插入比单条插入要快，因为事务只需要开启一次，数据量太小体现不了。<br>⑥避免子查询，优化为多表连接查询。<br>⑦尽量使用union all替代union，因为union会自动去重。</p>\n<h2 id=\"2-、数据库引擎有哪些\"><a href=\"#2-、数据库引擎有哪些\" class=\"headerlink\" title=\"2****、数据库引擎有哪些\"></a><strong>2****、数据库引擎有哪些</strong></h2><p>如何查看mysql提供的所有存储引擎</p>\n<p><code>mysql&gt; show engines;</code></p>\n<p>mysql常用引擎包括：MYISAM、Innodb、Memory、MERGE</p>\n<ul>\n<li>MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对</li>\n<li>较小，对事务完整性没有要求，以select、insert为主的应用基本上可以使用这引擎</li>\n<li>Innodb:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键</li>\n<li>约束，并发能力强，占用空间是MYISAM的2.5倍，处理效率相对会差一些</li>\n<li>Memory:全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在mysql重</li>\n<li>启时会丢失，默认使用HASH索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变</li>\n<li>化不频繁的代码表</li>\n<li>MERGE：是一组MYISAM表的组合</li>\n</ul>\n<h2 id=\"3、InnoDB与MyISAM-的区别\"><a href=\"#3、InnoDB与MyISAM-的区别\" class=\"headerlink\" title=\"*3、InnoDB与MyISAM***的区别\"></a>*<em>3</em><em><strong>、</strong></em><em>InnoDB</em><em><strong>与</strong></em><em>MyISAM</em>***的区别</h2><ol>\n<li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，</li>\n</ol>\n<p>这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</p>\n<ol start=\"2\">\n<li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li>\n<li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但</li>\n</ol>\n<p>是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，</p>\n<p>因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的</p>\n<p>是数据文件的指针。主键索引和辅助索引是独立的。</p>\n<ol start=\"4\">\n<li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一</li>\n</ol>\n<p>个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p>\n<ol start=\"5\">\n<li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li>\n</ol>\n<p>mysql&gt; show engines;<strong>如何选择引擎？</strong></p>\n<p>如果没有特别的需求，使用默认的 Innodb 即可。</p>\n<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>\n<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如</p>\n<p>OA自动化办公系统。</p>\n<p><strong>4****、数据库的事务</strong></p>\n<h2 id=\"4-、数据库的事务\"><a href=\"#4-、数据库的事务\" class=\"headerlink\" title=\"4**、数据库的事务\"></a>4**<strong>、数据库的事务</strong></h2><p><strong>什么是事务？</strong></p>\n<p><strong>：</strong> 多条sql语句，要么全部成功，要么全部失败。</p>\n<p><strong>事务的特性：</strong></p>\n<p><strong>数据库事务特性：原子性</strong>**(Atomic)<strong><strong>、一致性</strong></strong>(Consistency)<strong><strong>、隔离性</strong></strong>(Isolation)<strong><strong>、持久性</strong></strong>(Durabiliy)**<strong>。</strong></p>\n<p><strong>简称<strong><strong>ACID</strong></strong>。</strong></p>\n<p>原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功，整个</p>\n<p>事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。</p>\n<p>一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如A</p>\n<p>转账100元给B，不管操作是否成功，A和B的账户总额是不变的。</p>\n<p>隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰</p>\n<p>持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。</p>\n<h2 id=\"5、索引问题\"><a href=\"#5、索引问题\" class=\"headerlink\" title=\"5、索引问题\"></a><strong>5</strong>、索引问题</h2><p>索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于快速获取信息。</p>\n<p>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，</p>\n<p>索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅</p>\n<p>速地找到表中的数据，而不必扫描整个数据库。</p>\n<p>mysql 有4种不同的索引：</p>\n<ol>\n<li>主键索引（PRIMARY）</li>\n<li>数据列不允许重复，不允许为NULL，一个表只能有一个主键。</li>\n<li>唯一索引（UNIQUE）</li>\n<li>数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li>\n<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引</li>\n<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索</li>\n<li>引</li>\n<li>普通索引（INDEX）</li>\n<li>可以通过 ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引</li>\n<li>可以通过 ALTER TABLE table_name ADD INDEX index_name(column1, column2,</li>\n<li>column3); 创建组合索引</li>\n<li>全文索引（FULLTEXT）</li>\n<li>可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引</li>\n</ol>\n<p><strong>索引并非是越多越好，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时</strong></p>\n<p><strong>要花费较多的时间维护索引</strong></p>\n<ol>\n<li>索引加快数据库的检索速度</li>\n<li>索引降低了插入、删除、修改等维护任务的速度</li>\n<li>唯一索引可以确保每一行数据的唯一性</li>\n<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li>\n<li>索引需要占物理和数据空间</li>\n</ol>\n<h2 id=\"6、SQL优化\"><a href=\"#6、SQL优化\" class=\"headerlink\" title=\"6、SQL优化\"></a>6、SQL优化</h2><p>1、查询语句中不要使用select *</p>\n<p>2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代</p>\n<p>3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代</p>\n<p>4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union</p>\n<p>all会更好)</p>\n<p>5、应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>\n<p>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫</p>\n<p>描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null</p>\n<p>值，然后这样查询： select id from t where num&#x3D;0</p>\n<h2 id=\"7、简单说一说drop、delete与truncate-的区别\"><a href=\"#7、简单说一说drop、delete与truncate-的区别\" class=\"headerlink\" title=\"7、简单说一说drop、delete与truncate****的区别\"></a><strong>7<strong><strong>、简单说一说</strong></strong>drop<strong><strong>、</strong></strong>delete<strong><strong>与</strong></strong>truncate****的区别</strong></h2><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别</p>\n<p>delete和truncate只删除表的数据不删除表的结构</p>\n<p>速度,一般来说: drop&gt; truncate &gt;delete</p>\n<p>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;</p>\n<p>如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback</p>\n<p>segment中,不能回滚. 操作不触发trigger.</p>\n<h2 id=\"8-、什么是视图\"><a href=\"#8-、什么是视图\" class=\"headerlink\" title=\"8****、什么是视图\"></a><strong>8****、什么是视图</strong></h2><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一</p>\n<p>个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表</p>\n<p>查询。</p>\n<h2 id=\"9-、-什么是内联接、左外联接、右外联接？\"><a href=\"#9-、-什么是内联接、左外联接、右外联接？\" class=\"headerlink\" title=\"9****、 什么是内联接、左外联接、右外联接？\"></a><strong>9****、 什么是内联接、左外联接、右外联接？</strong></h2><ol>\n<li>内联接（Inner Join）：匹配2张表中相关联的记录。</li>\n<li>左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，</li>\n<li>右表中未匹配到的字段用NULL表示。</li>\n<li>右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，</li>\n<li>左表中未匹配到的字段用NULL表示。在判定左表和右表时，要根据表名出现在Outer Join的左右</li>\n<li>位置关系。</li>\n</ol>\n<h2 id=\"10-、并发事务带来哪些问题-隔离级别\"><a href=\"#10-、并发事务带来哪些问题-隔离级别\" class=\"headerlink\" title=\"10**、并发事务带来哪些问题?**隔离级别\"></a><strong>10**<strong>、并发事务带来哪些问题</strong></strong>?**<strong>隔离级别</strong></h2><p><strong>脏读</strong></p>\n<p><strong>不可重复读</strong></p>\n<p><strong>幻影读</strong></p>\n<p>READ-UNCOMMITTED</p>\n<p>√</p>\n<p>√</p>\n<p>√</p>\n<p>READ-COMMITTED</p>\n<p>×</p>\n<p>√</p>\n<p>√</p>\n<p>REPEATABLE-READ</p>\n<p>×</p>\n<p>×</p>\n<p>√</p>\n<p>SERIALIZABLE</p>\n<p>×</p>\n<p>×</p>\n<p>×</p>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一</p>\n<p>数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<p><strong>脏读（<strong><strong>Dirty read</strong></strong>）**</strong>:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到</p>\n<p>数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提</p>\n<p>交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确</p>\n<p>的。</p>\n<p><strong>丢失修改（<strong><strong>Lost to modify</strong></strong>）**</strong>:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那</p>\n<p>么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结</p>\n<p>果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事</p>\n<p>务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</p>\n<p><strong>不可重复读（<strong><strong>Unrepeatableread</strong></strong>）**</strong>:** 指在一个事务内多次读同一数据。在这个事务还没有结束</p>\n<p>时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改</p>\n<p>导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样</p>\n<p>的情况，因此称为不可重复读。</p>\n<p><strong>幻读（<strong><strong>Phantom read</strong></strong>）**</strong>:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接</p>\n<p>着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了</p>\n<p>一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<p><strong>不可重复读和幻读区别：</strong></p>\n<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者</p>\n<p>删除比如多次读取一条记录发现记录增多或减少了。</p>\n<h2 id=\"11-、事务隔离级别有哪些-MySQL的默认隔离级别是\"><a href=\"#11-、事务隔离级别有哪些-MySQL的默认隔离级别是\" class=\"headerlink\" title=\"11**、事务隔离级别有哪些?MySQL的默认隔离级别是?**\"></a><strong>11**<strong>、事务隔离级别有哪些</strong></strong>?MySQL<strong><strong>的默认隔离级别是</strong></strong>?**</h2><p><strong>SQL</strong> <strong>标准定义了四个隔离级别：</strong></p>\n<p><strong>READ-UNCOMMITTED(<strong><strong>读取未提交</strong></strong>)*<em><strong>：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，</em>*可能会</strong></p>\n<p><strong>导致脏读、幻读或不可重复读</strong>。</p>\n<p><strong>READ-COMMITTED(<strong><strong>读取已提交</strong></strong>)*<em><strong>：</strong> 允许读取并发事务已经提交的数据，</em>*可以阻止脏读，但是幻</strong></p>\n<p><strong>读或不可重复读仍有可能发生</strong>。</p>\n<p>**REPEATABLE-READ(<strong><strong>可重复读</strong></strong>)**<strong>：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务</p>\n<p>自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</p>\n<p>**SERIALIZABLE(<strong><strong>可串行化</strong></strong>)**<strong>：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执</p>\n<p>行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻</strong></p>\n<p><strong>读</strong>。</p>\n<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ****（可重读）</strong>。我们可以通过</p>\n<p>SELECT @@tx_isolation; 命令来查看这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ****（可重读）</strong></p>\n<p>事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如</p>\n<p>SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ****（可重</strong></p>\n<p><strong>读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE(<strong><strong>可串行化</strong></strong>)</strong> 隔离级</p>\n<p>别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ\u0002</strong></p>\n<p><strong>COMMITTED(<strong><strong>读取提交内容</strong></strong>)</strong> ，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEAaTABLE\u0002</strong></p>\n<p><strong>READ****（可重读）</strong> 并不会有任何性能损失。</p>\n<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(<strong><strong>可串行化</strong></strong>)</strong> 隔离级别。</p>\n<h2 id=\"12-、大表如何优化？\"><a href=\"#12-、大表如何优化？\" class=\"headerlink\" title=\"12****、大表如何优化？\"></a><strong>12****、大表如何优化？</strong></h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>\n<p><strong>1.</strong> <strong>限定数据的范围</strong></p>\n<p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以</p>\n<p>控制在一个月的范围内；</p>\n<p><strong>2.</strong> <strong>读</strong>**&#x2F;**<strong>写分离</strong></p>\n<p>经典的数据库拆分方案，主库负责写，从库负责读；</p>\n<p><strong>3.</strong> <strong>垂直分区</strong></p>\n<p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，</p>\n<p>可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>\n<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大</p>\n<p>家应该就更容易理解了。</p>\n<p><strong>垂直拆分的优点：</strong> 可以使得列数据变小，在查询时减少读取的Block数，减少I&#x2F;O次数。此外，垂</p>\n<p>直分区可以简化表的结构，易于维护。</p>\n<p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行</p>\n<p>Join来解决。此外，垂直分区会让事务变得更加复杂；</p>\n<p><strong>4.</strong> <strong>水平分区</strong></p>\n<p>mysql&gt; SELECT @@tx_isolation;</p>\n<p>+—————–+</p>\n<p>| @@tx_isolation |</p>\n<p>+—————–+</p>\n<p>| REPEATABLE-READ |</p>\n<p>+—————–+<strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了</strong></p>\n<p><strong>分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>\n<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成</p>\n<p>多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据</p>\n<p>量过大对性能造成影响。</p>\n<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但</p>\n<p>由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好</strong></p>\n<p><strong>分库</strong> 。</p>\n<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨节点Join性能较</p>\n<p>差，逻辑复杂。《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、</strong></p>\n<p><strong>部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题</p>\n<p>的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I&#x2F;O。</p>\n<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>\n<p><strong>客户端代理： 分片逻辑在应用端，封装在<strong><strong>jar</strong></strong>包中，通过修改或者封装<strong><strong>JDBC</strong></strong>层来实现。</strong> 当当网的</p>\n<p><strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</p>\n<p><strong>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在</p>\n<p>谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</p>\n<p>详细内容可以参考： MySQL大表优化方案: <a href=\"https://segmentfault.com/a/1190000006158186\">https://segmentfault.com/a/1190000006158186</a></p>\n<h2 id=\"13-、分库分表之后-id-主键如何处理？\"><a href=\"#13-、分库分表之后-id-主键如何处理？\" class=\"headerlink\" title=\"13**、分库分表之后,id** 主键如何处理？\"></a><strong>13**<strong>、分库分表之后</strong></strong>,id** <strong>主键如何处理？</strong></h2><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来</p>\n<p>支持。</p>\n<p>生成全局 id 有下面这几种方式：</p>\n<p><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的</p>\n<p>名字的标示比如文件的名字。</p>\n<p><strong>数据库自增</strong> <strong>id</strong> : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成</p>\n<p>的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</p>\n<p><strong>利用</strong> <strong>redis</strong> <strong>生成</strong> <strong>id :</strong> 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更</p>\n<p>加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>\n<p><strong>Twitter<strong><strong>的</strong></strong>snowflake****算法</strong> ：Github 地址：<a href=\"https://github.com/twitter-archive/snowflake%E3%80%82\">https://github.com/twitter-archive/snowflake。</a></p>\n<p><strong>美团的<strong><strong>Leaf</strong></strong>分布式<strong><strong>ID</strong></strong>生成系统</strong> ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递</p>\n<p>增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、</p>\n<p>Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章：<a href=\"https://tech.meituan.com/2017/\">https://tech.meituan.com/2017/</a></p>\n<p>04&#x2F;21&#x2F;mt-leaf.html 。<strong>14<strong><strong>、</strong></strong>mysql****有关权限的表都有哪几个</strong></p>\n<p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由</p>\n<p>mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分</p>\n<p>别介绍一下这些表的结构和内容：</p>\n<p>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</p>\n<p>db权限表：记录各个帐号在各个数据库上的操作权限。</p>\n<p>table_priv权限表：记录数据表级的操作权限。</p>\n<p>columns_priv权限表：记录数据列级的操作权限。</p>\n<p>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受</p>\n<p>GRANT和REVOKE语句的影响。</p>\n<h2 id=\"15、mysql-有哪些数据类型\"><a href=\"#15、mysql-有哪些数据类型\" class=\"headerlink\" title=\"15、mysql****有哪些数据类型\"></a><strong>15<strong><strong>、</strong></strong>mysql****有哪些数据类型</strong></h2><p><strong>1****、整数类型</strong> ，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3</p>\n<p>字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整</p>\n<p>数。</p>\n<p>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意</p>\n<p>义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配</p>\n<p>合使用才有意义。</p>\n<p>例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数</p>\n<p>据库实际存储数据为00012。</p>\n<p><strong>2****、实数类型</strong>，包括FLOAT、DOUBLE、DECIMAL。</p>\n<p>DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。</p>\n<p>而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。</p>\n<p>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p>\n<p><strong>3****、字符串类型</strong>，包括VARCHAR、CHAR、TEXT、BLOB</p>\n<p>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。</p>\n<p>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2</p>\n<p>字节表示。</p>\n<p>VARCHAR存储的内容超出设置的长度时，内容会被截断。</p>\n<p>CHAR是定长的，根据定义的字符串长度分配足够的空间。</p>\n<p>CHAR会根据需要使用空格进行填充方便比较。</p>\n<p>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</p>\n<p>CHAR存储的内容超出设置的长度时，内容同样会被截断。</p>\n<p><strong>使用策略：</strong></p>\n<p>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。</p>\n<p>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。</p>\n<p>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。</p>\n<p>尽量避免使用TEXT&#x2F;BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>\n<p><strong>4<strong><strong>、枚举类型（</strong></strong>ENUM****）</strong>，把不重复的数据存储为一个预定义的集合。</p>\n<p>有时可以使用ENUM代替常用的字符串类型。</p>\n<p>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。</p>\n<p>ENUM在内部存储时，其实存的是整数。</p>\n<p>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。</p>\n<p>排序是按照内部存储的整数<strong>5****、日期和时间类型</strong>，尽量使用timestamp，空间效率高于datetime，</p>\n<p>用整数保存时间戳通常不方便处理。</p>\n<p>如果需要存储微妙，可以使用bigint存储。</p>\n<p>看到这里，这道真题是不是就比较容易回答了。</p>\n<h2 id=\"16-、创建索引的三种方式，删除索引\"><a href=\"#16-、创建索引的三种方式，删除索引\" class=\"headerlink\" title=\"16****、创建索引的三种方式，删除索引\"></a><strong>16****、创建索引的三种方式，删除索引</strong></h2><p>第一种方式：在执行CREATE TABLE时创建索引</p>\n<p>第二种方式：使用ALTER TABLE命令去增加索引</p>\n<p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p>\n<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分</p>\n<p>隔。</p>\n<p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER</p>\n<p>TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>\n<p>第三种方式：使用CREATE INDEX命令创建</p>\n<p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p>\n<p>删除索引</p>\n<p>根据索引名删除普通索引、唯一索引、全文索引： alter table 表名 drop KEY 索引名</p>\n<p>删除主键索引： alter table 表名 drop primary key （因为主键只有一个）。这里值得注意的是，</p>\n<p>如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>\n<p>CREATE TABLE user_index2 (</p>\n<p>id INT auto_increment PRIMARY KEY,</p>\n<p>first_name VARCHAR (16),</p>\n<p>last_name VARCHAR (16),</p>\n<p>id_card VARCHAR (18),</p>\n<p>information text,</p>\n<p>KEY name (first_name, last_name),</p>\n<p>FULLTEXT KEY (information),</p>\n<p>UNIQUE KEY (id_card)</p>\n<p>);</p>\n<p>ALTER TABLE table_name ADD INDEX index_name (column_list);</p>\n<p>CREATE INDEX index_name ON table_name (column_list);</p>\n<p>alter table user_index drop KEY name;</p>\n<p>alter table user_index drop KEY id_card;</p>\n<p>alter table user_index drop KEY information;需要取消自增长再行删除：</p>\n<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>\n<h2 id=\"4-索引是什么\"><a href=\"#4-索引是什么\" class=\"headerlink\" title=\"4.索引是什么\"></a>4.索引是什么</h2><p>是一种高效获取数据的数据结构，相当于目录，更快的找到数据，是一个文件，占用物理空间。</p>\n<h2 id=\"5-索引的优点和缺点\"><a href=\"#5-索引的优点和缺点\" class=\"headerlink\" title=\"5.索引的优点和缺点\"></a>5.索引的优点和缺点</h2><p>优点：<br>①提高检索的速度。<br>②索引列对数据排序，降低排序成本。<br>③mysql 8之后引入了，隐藏索引，当一个索引被隐藏就不会被优化器所使用，就可以看出来索引对数据库的影响，有利于调优。<br>缺点：<br>①索引也是一个文件，所以会占用空间。<br>②降低更新的速度，因为不光要更新数据，还要更新索引。</p>\n<h2 id=\"6-索引的类型\"><a href=\"#6-索引的类型\" class=\"headerlink\" title=\"6.索引的类型\"></a>6.索引的类型</h2><p>①普通索引： 基本索引类型，允许定义索引的字段为空值和重复值。<br>②唯一索引： 索引的值必须唯一，允许定义索引的字段为空值。<br>③主键索引： 索引的值必须唯一，不可以为空。<br>④复合索引： 多个字段加索引，遵守最左匹配规则。<br>⑤全局索引： 只有在 MyISAM 引擎上才能使用。</p>\n<h2 id=\"7-索引怎么设计-优化\"><a href=\"#7-索引怎么设计-优化\" class=\"headerlink\" title=\"7.索引怎么设计(优化)\"></a>7.索引怎么设计(优化)</h2><p>①选择唯一性索引：值是唯一的，查询的更快。<br>②经常作为查询条件的字段加索引。<br>③为经常需要排序、分组和联合操作的字段建立索引：order by、group by、union(联合)、distinct(去重)等。<br>④限制索引个数：索引数量多，需要的磁盘空间就越多，更新表时，对索引的重构和更新就很费劲。<br>⑤表数据少的不建议使用索引(百万级以内)：数据过少，有可能查询的速度，比遍历索引的速度都快。<br>⑥删除不常用和不再使用的索引。<br>⑦用类型小的类型做索引：比如：int和BIGINT能用int就使用int。因为类型小，查询速度快和索引占用的空间更少。<br>⑧使用前缀索引，要是字符串越长，那么索引占的空间越大，并且比较起来就时间就越长。</p>\n<h2 id=\"1-char和varchar的区别\"><a href=\"#1-char和varchar的区别\" class=\"headerlink\" title=\"1.char和varchar的区别\"></a>1.char和varchar的区别</h2><p>①char设置多少长度就是多少长度，varchar可以改变长度，所以char的空间利用率不如varchar的空间利用率高。<br>②因为长度固定，所以存取速度要比varchar快。<br>③char适用于固定长度的字符串，比如身份证号、手机号等，varchar适用于不固定的字符串。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1Mysql\"><a href=\"#1Mysql\" class=\"headerlink\" title=\"1Mysql\"></a>1Mysql</h1><h2 id=\"1-、数据库的三范式是什么\"><a href=\"#1-、数据库的三范式是什么\" class=\"headerlink\" title=\"1****、数据库的三范式是什么\"></a><strong>1****、数据库的三范式是什么</strong></h2><p>第一范式：列不可再分 <strong>原子性</strong></p>\n<p>第二范式：行可以唯一区分，主键约束** 唯一性**</p>\n<p>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束 <strong>独立性</strong></p>\n<p>且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。</p>\n<h2 id=\"18-事务的四大特性-ACID\"><a href=\"#18-事务的四大特性-ACID\" class=\"headerlink\" title=\"18.事务的四大特性(ACID)\"></a>18.事务的四大特性(ACID)</h2><p>原子性(Atomicity)： 要么全部成功要么全部失败。<br>一致性(Consistency)： 事务执行前和事务执行后，原本和数据库一致的数据仍然一致。<br>隔离性(Isolation)： 事务与事务之间互不干扰。<br>持久性(Durability)： 事务一旦被提交了，那么对数据库中的数据的改变就是永久的。</p>\n<h2 id=\"12-为什么使用B-树不用B树\"><a href=\"#12-为什么使用B-树不用B树\" class=\"headerlink\" title=\"12.为什么使用B+树不用B树\"></a>12.为什么使用B+树不用B树</h2><p>①B树只适合随机检索，而B+树同时支持随机检索和顺序检索(因为叶子节点相当于链表，保存索引值都是有序的)。<br>顺序检索： 按照序列顺序遍历比较找到给定值。<br>随机检索： 不断从序列中随机抽取数据进行比较，最终找到结果。</p>\n<p>②减少了磁盘IO，提高空间利用率： 因为B+树非叶子节点不会存放数据，只有索引值，所以非叶子节点可以保存更多的索引值，这样B+树就可以更矮，减少IO次数。</p>\n<p>③B+树适合范围查找： 这才是关键，因为数据库大部分都是范围查找，B+树的叶子节点是有序链表，直接遍历就行，而B树的范围查找可能两个节点距离很远，只能通过中序遍历去查找，所以使用B+树更合适。<br>中序遍历： (根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）</p>\n<h2 id=\"21-怎么优化数据库\"><a href=\"#21-怎么优化数据库\" class=\"headerlink\" title=\"21.怎么优化数据库\"></a>21.怎么优化数据库</h2><p>①SQL优化<br>②加缓存<br>③分表<br>④读写分离</p>\n<h2 id=\"22-SQL优化\"><a href=\"#22-SQL优化\" class=\"headerlink\" title=\"22.SQL优化\"></a>22.SQL优化</h2><p>①不要用select *，要使用具体字段。<br>②使用数值代替字符串，比如：0&#x3D;唱，1&#x3D;跳，2&#x3D;rap。<br>③避免返回大量数据，采用分页最好。<br>④使用索引，提升查询速度，不宜建太多索引，不能建在重复数据比较多的字段上。<br>⑤批量插入比单条插入要快，因为事务只需要开启一次，数据量太小体现不了。<br>⑥避免子查询，优化为多表连接查询。<br>⑦尽量使用union all替代union，因为union会自动去重。</p>\n<h2 id=\"2-、数据库引擎有哪些\"><a href=\"#2-、数据库引擎有哪些\" class=\"headerlink\" title=\"2****、数据库引擎有哪些\"></a><strong>2****、数据库引擎有哪些</strong></h2><p>如何查看mysql提供的所有存储引擎</p>\n<p><code>mysql&gt; show engines;</code></p>\n<p>mysql常用引擎包括：MYISAM、Innodb、Memory、MERGE</p>\n<ul>\n<li>MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对</li>\n<li>较小，对事务完整性没有要求，以select、insert为主的应用基本上可以使用这引擎</li>\n<li>Innodb:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键</li>\n<li>约束，并发能力强，占用空间是MYISAM的2.5倍，处理效率相对会差一些</li>\n<li>Memory:全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在mysql重</li>\n<li>启时会丢失，默认使用HASH索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变</li>\n<li>化不频繁的代码表</li>\n<li>MERGE：是一组MYISAM表的组合</li>\n</ul>\n<h2 id=\"3、InnoDB与MyISAM-的区别\"><a href=\"#3、InnoDB与MyISAM-的区别\" class=\"headerlink\" title=\"*3、InnoDB与MyISAM***的区别\"></a>*<em>3</em><em><strong>、</strong></em><em>InnoDB</em><em><strong>与</strong></em><em>MyISAM</em>***的区别</h2><ol>\n<li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，</li>\n</ol>\n<p>这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</p>\n<ol start=\"2\">\n<li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li>\n<li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但</li>\n</ol>\n<p>是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，</p>\n<p>因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的</p>\n<p>是数据文件的指针。主键索引和辅助索引是独立的。</p>\n<ol start=\"4\">\n<li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一</li>\n</ol>\n<p>个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p>\n<ol start=\"5\">\n<li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li>\n</ol>\n<p>mysql&gt; show engines;<strong>如何选择引擎？</strong></p>\n<p>如果没有特别的需求，使用默认的 Innodb 即可。</p>\n<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>\n<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如</p>\n<p>OA自动化办公系统。</p>\n<p><strong>4****、数据库的事务</strong></p>\n<h2 id=\"4-、数据库的事务\"><a href=\"#4-、数据库的事务\" class=\"headerlink\" title=\"4**、数据库的事务\"></a>4**<strong>、数据库的事务</strong></h2><p><strong>什么是事务？</strong></p>\n<p><strong>：</strong> 多条sql语句，要么全部成功，要么全部失败。</p>\n<p><strong>事务的特性：</strong></p>\n<p><strong>数据库事务特性：原子性</strong>**(Atomic)<strong><strong>、一致性</strong></strong>(Consistency)<strong><strong>、隔离性</strong></strong>(Isolation)<strong><strong>、持久性</strong></strong>(Durabiliy)**<strong>。</strong></p>\n<p><strong>简称<strong><strong>ACID</strong></strong>。</strong></p>\n<p>原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功，整个</p>\n<p>事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。</p>\n<p>一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如A</p>\n<p>转账100元给B，不管操作是否成功，A和B的账户总额是不变的。</p>\n<p>隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰</p>\n<p>持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。</p>\n<h2 id=\"5、索引问题\"><a href=\"#5、索引问题\" class=\"headerlink\" title=\"5、索引问题\"></a><strong>5</strong>、索引问题</h2><p>索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于快速获取信息。</p>\n<p>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，</p>\n<p>索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅</p>\n<p>速地找到表中的数据，而不必扫描整个数据库。</p>\n<p>mysql 有4种不同的索引：</p>\n<ol>\n<li>主键索引（PRIMARY）</li>\n<li>数据列不允许重复，不允许为NULL，一个表只能有一个主键。</li>\n<li>唯一索引（UNIQUE）</li>\n<li>数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li>\n<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引</li>\n<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索</li>\n<li>引</li>\n<li>普通索引（INDEX）</li>\n<li>可以通过 ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引</li>\n<li>可以通过 ALTER TABLE table_name ADD INDEX index_name(column1, column2,</li>\n<li>column3); 创建组合索引</li>\n<li>全文索引（FULLTEXT）</li>\n<li>可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引</li>\n</ol>\n<p><strong>索引并非是越多越好，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时</strong></p>\n<p><strong>要花费较多的时间维护索引</strong></p>\n<ol>\n<li>索引加快数据库的检索速度</li>\n<li>索引降低了插入、删除、修改等维护任务的速度</li>\n<li>唯一索引可以确保每一行数据的唯一性</li>\n<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li>\n<li>索引需要占物理和数据空间</li>\n</ol>\n<h2 id=\"6、SQL优化\"><a href=\"#6、SQL优化\" class=\"headerlink\" title=\"6、SQL优化\"></a>6、SQL优化</h2><p>1、查询语句中不要使用select *</p>\n<p>2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代</p>\n<p>3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代</p>\n<p>4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union</p>\n<p>all会更好)</p>\n<p>5、应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>\n<p>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫</p>\n<p>描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null</p>\n<p>值，然后这样查询： select id from t where num&#x3D;0</p>\n<h2 id=\"7、简单说一说drop、delete与truncate-的区别\"><a href=\"#7、简单说一说drop、delete与truncate-的区别\" class=\"headerlink\" title=\"7、简单说一说drop、delete与truncate****的区别\"></a><strong>7<strong><strong>、简单说一说</strong></strong>drop<strong><strong>、</strong></strong>delete<strong><strong>与</strong></strong>truncate****的区别</strong></h2><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别</p>\n<p>delete和truncate只删除表的数据不删除表的结构</p>\n<p>速度,一般来说: drop&gt; truncate &gt;delete</p>\n<p>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;</p>\n<p>如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback</p>\n<p>segment中,不能回滚. 操作不触发trigger.</p>\n<h2 id=\"8-、什么是视图\"><a href=\"#8-、什么是视图\" class=\"headerlink\" title=\"8****、什么是视图\"></a><strong>8****、什么是视图</strong></h2><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一</p>\n<p>个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表</p>\n<p>查询。</p>\n<h2 id=\"9-、-什么是内联接、左外联接、右外联接？\"><a href=\"#9-、-什么是内联接、左外联接、右外联接？\" class=\"headerlink\" title=\"9****、 什么是内联接、左外联接、右外联接？\"></a><strong>9****、 什么是内联接、左外联接、右外联接？</strong></h2><ol>\n<li>内联接（Inner Join）：匹配2张表中相关联的记录。</li>\n<li>左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，</li>\n<li>右表中未匹配到的字段用NULL表示。</li>\n<li>右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，</li>\n<li>左表中未匹配到的字段用NULL表示。在判定左表和右表时，要根据表名出现在Outer Join的左右</li>\n<li>位置关系。</li>\n</ol>\n<h2 id=\"10-、并发事务带来哪些问题-隔离级别\"><a href=\"#10-、并发事务带来哪些问题-隔离级别\" class=\"headerlink\" title=\"10**、并发事务带来哪些问题?**隔离级别\"></a><strong>10**<strong>、并发事务带来哪些问题</strong></strong>?**<strong>隔离级别</strong></h2><p><strong>脏读</strong></p>\n<p><strong>不可重复读</strong></p>\n<p><strong>幻影读</strong></p>\n<p>READ-UNCOMMITTED</p>\n<p>√</p>\n<p>√</p>\n<p>√</p>\n<p>READ-COMMITTED</p>\n<p>×</p>\n<p>√</p>\n<p>√</p>\n<p>REPEATABLE-READ</p>\n<p>×</p>\n<p>×</p>\n<p>√</p>\n<p>SERIALIZABLE</p>\n<p>×</p>\n<p>×</p>\n<p>×</p>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一</p>\n<p>数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<p><strong>脏读（<strong><strong>Dirty read</strong></strong>）**</strong>:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到</p>\n<p>数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提</p>\n<p>交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确</p>\n<p>的。</p>\n<p><strong>丢失修改（<strong><strong>Lost to modify</strong></strong>）**</strong>:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那</p>\n<p>么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结</p>\n<p>果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事</p>\n<p>务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</p>\n<p><strong>不可重复读（<strong><strong>Unrepeatableread</strong></strong>）**</strong>:** 指在一个事务内多次读同一数据。在这个事务还没有结束</p>\n<p>时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改</p>\n<p>导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样</p>\n<p>的情况，因此称为不可重复读。</p>\n<p><strong>幻读（<strong><strong>Phantom read</strong></strong>）**</strong>:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接</p>\n<p>着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了</p>\n<p>一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<p><strong>不可重复读和幻读区别：</strong></p>\n<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者</p>\n<p>删除比如多次读取一条记录发现记录增多或减少了。</p>\n<h2 id=\"11-、事务隔离级别有哪些-MySQL的默认隔离级别是\"><a href=\"#11-、事务隔离级别有哪些-MySQL的默认隔离级别是\" class=\"headerlink\" title=\"11**、事务隔离级别有哪些?MySQL的默认隔离级别是?**\"></a><strong>11**<strong>、事务隔离级别有哪些</strong></strong>?MySQL<strong><strong>的默认隔离级别是</strong></strong>?**</h2><p><strong>SQL</strong> <strong>标准定义了四个隔离级别：</strong></p>\n<p><strong>READ-UNCOMMITTED(<strong><strong>读取未提交</strong></strong>)*<em><strong>：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，</em>*可能会</strong></p>\n<p><strong>导致脏读、幻读或不可重复读</strong>。</p>\n<p><strong>READ-COMMITTED(<strong><strong>读取已提交</strong></strong>)*<em><strong>：</strong> 允许读取并发事务已经提交的数据，</em>*可以阻止脏读，但是幻</strong></p>\n<p><strong>读或不可重复读仍有可能发生</strong>。</p>\n<p>**REPEATABLE-READ(<strong><strong>可重复读</strong></strong>)**<strong>：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务</p>\n<p>自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</p>\n<p>**SERIALIZABLE(<strong><strong>可串行化</strong></strong>)**<strong>：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执</p>\n<p>行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻</strong></p>\n<p><strong>读</strong>。</p>\n<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ****（可重读）</strong>。我们可以通过</p>\n<p>SELECT @@tx_isolation; 命令来查看这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ****（可重读）</strong></p>\n<p>事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如</p>\n<p>SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ****（可重</strong></p>\n<p><strong>读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE(<strong><strong>可串行化</strong></strong>)</strong> 隔离级</p>\n<p>别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ\u0002</strong></p>\n<p><strong>COMMITTED(<strong><strong>读取提交内容</strong></strong>)</strong> ，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEAaTABLE\u0002</strong></p>\n<p><strong>READ****（可重读）</strong> 并不会有任何性能损失。</p>\n<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(<strong><strong>可串行化</strong></strong>)</strong> 隔离级别。</p>\n<h2 id=\"12-、大表如何优化？\"><a href=\"#12-、大表如何优化？\" class=\"headerlink\" title=\"12****、大表如何优化？\"></a><strong>12****、大表如何优化？</strong></h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>\n<p><strong>1.</strong> <strong>限定数据的范围</strong></p>\n<p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以</p>\n<p>控制在一个月的范围内；</p>\n<p><strong>2.</strong> <strong>读</strong>**&#x2F;**<strong>写分离</strong></p>\n<p>经典的数据库拆分方案，主库负责写，从库负责读；</p>\n<p><strong>3.</strong> <strong>垂直分区</strong></p>\n<p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，</p>\n<p>可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>\n<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大</p>\n<p>家应该就更容易理解了。</p>\n<p><strong>垂直拆分的优点：</strong> 可以使得列数据变小，在查询时减少读取的Block数，减少I&#x2F;O次数。此外，垂</p>\n<p>直分区可以简化表的结构，易于维护。</p>\n<p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行</p>\n<p>Join来解决。此外，垂直分区会让事务变得更加复杂；</p>\n<p><strong>4.</strong> <strong>水平分区</strong></p>\n<p>mysql&gt; SELECT @@tx_isolation;</p>\n<p>+—————–+</p>\n<p>| @@tx_isolation |</p>\n<p>+—————–+</p>\n<p>| REPEATABLE-READ |</p>\n<p>+—————–+<strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了</strong></p>\n<p><strong>分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>\n<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成</p>\n<p>多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据</p>\n<p>量过大对性能造成影响。</p>\n<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但</p>\n<p>由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好</strong></p>\n<p><strong>分库</strong> 。</p>\n<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨节点Join性能较</p>\n<p>差，逻辑复杂。《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、</strong></p>\n<p><strong>部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题</p>\n<p>的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I&#x2F;O。</p>\n<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>\n<p><strong>客户端代理： 分片逻辑在应用端，封装在<strong><strong>jar</strong></strong>包中，通过修改或者封装<strong><strong>JDBC</strong></strong>层来实现。</strong> 当当网的</p>\n<p><strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</p>\n<p><strong>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在</p>\n<p>谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</p>\n<p>详细内容可以参考： MySQL大表优化方案: <a href=\"https://segmentfault.com/a/1190000006158186\">https://segmentfault.com/a/1190000006158186</a></p>\n<h2 id=\"13-、分库分表之后-id-主键如何处理？\"><a href=\"#13-、分库分表之后-id-主键如何处理？\" class=\"headerlink\" title=\"13**、分库分表之后,id** 主键如何处理？\"></a><strong>13**<strong>、分库分表之后</strong></strong>,id** <strong>主键如何处理？</strong></h2><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来</p>\n<p>支持。</p>\n<p>生成全局 id 有下面这几种方式：</p>\n<p><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的</p>\n<p>名字的标示比如文件的名字。</p>\n<p><strong>数据库自增</strong> <strong>id</strong> : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成</p>\n<p>的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</p>\n<p><strong>利用</strong> <strong>redis</strong> <strong>生成</strong> <strong>id :</strong> 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更</p>\n<p>加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>\n<p><strong>Twitter<strong><strong>的</strong></strong>snowflake****算法</strong> ：Github 地址：<a href=\"https://github.com/twitter-archive/snowflake%E3%80%82\">https://github.com/twitter-archive/snowflake。</a></p>\n<p><strong>美团的<strong><strong>Leaf</strong></strong>分布式<strong><strong>ID</strong></strong>生成系统</strong> ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递</p>\n<p>增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、</p>\n<p>Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章：<a href=\"https://tech.meituan.com/2017/\">https://tech.meituan.com/2017/</a></p>\n<p>04&#x2F;21&#x2F;mt-leaf.html 。<strong>14<strong><strong>、</strong></strong>mysql****有关权限的表都有哪几个</strong></p>\n<p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由</p>\n<p>mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分</p>\n<p>别介绍一下这些表的结构和内容：</p>\n<p>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</p>\n<p>db权限表：记录各个帐号在各个数据库上的操作权限。</p>\n<p>table_priv权限表：记录数据表级的操作权限。</p>\n<p>columns_priv权限表：记录数据列级的操作权限。</p>\n<p>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受</p>\n<p>GRANT和REVOKE语句的影响。</p>\n<h2 id=\"15、mysql-有哪些数据类型\"><a href=\"#15、mysql-有哪些数据类型\" class=\"headerlink\" title=\"15、mysql****有哪些数据类型\"></a><strong>15<strong><strong>、</strong></strong>mysql****有哪些数据类型</strong></h2><p><strong>1****、整数类型</strong> ，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3</p>\n<p>字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整</p>\n<p>数。</p>\n<p>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意</p>\n<p>义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配</p>\n<p>合使用才有意义。</p>\n<p>例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数</p>\n<p>据库实际存储数据为00012。</p>\n<p><strong>2****、实数类型</strong>，包括FLOAT、DOUBLE、DECIMAL。</p>\n<p>DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。</p>\n<p>而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。</p>\n<p>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p>\n<p><strong>3****、字符串类型</strong>，包括VARCHAR、CHAR、TEXT、BLOB</p>\n<p>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。</p>\n<p>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2</p>\n<p>字节表示。</p>\n<p>VARCHAR存储的内容超出设置的长度时，内容会被截断。</p>\n<p>CHAR是定长的，根据定义的字符串长度分配足够的空间。</p>\n<p>CHAR会根据需要使用空格进行填充方便比较。</p>\n<p>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</p>\n<p>CHAR存储的内容超出设置的长度时，内容同样会被截断。</p>\n<p><strong>使用策略：</strong></p>\n<p>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。</p>\n<p>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。</p>\n<p>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。</p>\n<p>尽量避免使用TEXT&#x2F;BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>\n<p><strong>4<strong><strong>、枚举类型（</strong></strong>ENUM****）</strong>，把不重复的数据存储为一个预定义的集合。</p>\n<p>有时可以使用ENUM代替常用的字符串类型。</p>\n<p>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。</p>\n<p>ENUM在内部存储时，其实存的是整数。</p>\n<p>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。</p>\n<p>排序是按照内部存储的整数<strong>5****、日期和时间类型</strong>，尽量使用timestamp，空间效率高于datetime，</p>\n<p>用整数保存时间戳通常不方便处理。</p>\n<p>如果需要存储微妙，可以使用bigint存储。</p>\n<p>看到这里，这道真题是不是就比较容易回答了。</p>\n<h2 id=\"16-、创建索引的三种方式，删除索引\"><a href=\"#16-、创建索引的三种方式，删除索引\" class=\"headerlink\" title=\"16****、创建索引的三种方式，删除索引\"></a><strong>16****、创建索引的三种方式，删除索引</strong></h2><p>第一种方式：在执行CREATE TABLE时创建索引</p>\n<p>第二种方式：使用ALTER TABLE命令去增加索引</p>\n<p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p>\n<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分</p>\n<p>隔。</p>\n<p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER</p>\n<p>TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>\n<p>第三种方式：使用CREATE INDEX命令创建</p>\n<p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p>\n<p>删除索引</p>\n<p>根据索引名删除普通索引、唯一索引、全文索引： alter table 表名 drop KEY 索引名</p>\n<p>删除主键索引： alter table 表名 drop primary key （因为主键只有一个）。这里值得注意的是，</p>\n<p>如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>\n<p>CREATE TABLE user_index2 (</p>\n<p>id INT auto_increment PRIMARY KEY,</p>\n<p>first_name VARCHAR (16),</p>\n<p>last_name VARCHAR (16),</p>\n<p>id_card VARCHAR (18),</p>\n<p>information text,</p>\n<p>KEY name (first_name, last_name),</p>\n<p>FULLTEXT KEY (information),</p>\n<p>UNIQUE KEY (id_card)</p>\n<p>);</p>\n<p>ALTER TABLE table_name ADD INDEX index_name (column_list);</p>\n<p>CREATE INDEX index_name ON table_name (column_list);</p>\n<p>alter table user_index drop KEY name;</p>\n<p>alter table user_index drop KEY id_card;</p>\n<p>alter table user_index drop KEY information;需要取消自增长再行删除：</p>\n<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>\n<h2 id=\"4-索引是什么\"><a href=\"#4-索引是什么\" class=\"headerlink\" title=\"4.索引是什么\"></a>4.索引是什么</h2><p>是一种高效获取数据的数据结构，相当于目录，更快的找到数据，是一个文件，占用物理空间。</p>\n<h2 id=\"5-索引的优点和缺点\"><a href=\"#5-索引的优点和缺点\" class=\"headerlink\" title=\"5.索引的优点和缺点\"></a>5.索引的优点和缺点</h2><p>优点：<br>①提高检索的速度。<br>②索引列对数据排序，降低排序成本。<br>③mysql 8之后引入了，隐藏索引，当一个索引被隐藏就不会被优化器所使用，就可以看出来索引对数据库的影响，有利于调优。<br>缺点：<br>①索引也是一个文件，所以会占用空间。<br>②降低更新的速度，因为不光要更新数据，还要更新索引。</p>\n<h2 id=\"6-索引的类型\"><a href=\"#6-索引的类型\" class=\"headerlink\" title=\"6.索引的类型\"></a>6.索引的类型</h2><p>①普通索引： 基本索引类型，允许定义索引的字段为空值和重复值。<br>②唯一索引： 索引的值必须唯一，允许定义索引的字段为空值。<br>③主键索引： 索引的值必须唯一，不可以为空。<br>④复合索引： 多个字段加索引，遵守最左匹配规则。<br>⑤全局索引： 只有在 MyISAM 引擎上才能使用。</p>\n<h2 id=\"7-索引怎么设计-优化\"><a href=\"#7-索引怎么设计-优化\" class=\"headerlink\" title=\"7.索引怎么设计(优化)\"></a>7.索引怎么设计(优化)</h2><p>①选择唯一性索引：值是唯一的，查询的更快。<br>②经常作为查询条件的字段加索引。<br>③为经常需要排序、分组和联合操作的字段建立索引：order by、group by、union(联合)、distinct(去重)等。<br>④限制索引个数：索引数量多，需要的磁盘空间就越多，更新表时，对索引的重构和更新就很费劲。<br>⑤表数据少的不建议使用索引(百万级以内)：数据过少，有可能查询的速度，比遍历索引的速度都快。<br>⑥删除不常用和不再使用的索引。<br>⑦用类型小的类型做索引：比如：int和BIGINT能用int就使用int。因为类型小，查询速度快和索引占用的空间更少。<br>⑧使用前缀索引，要是字符串越长，那么索引占的空间越大，并且比较起来就时间就越长。</p>\n<h2 id=\"1-char和varchar的区别\"><a href=\"#1-char和varchar的区别\" class=\"headerlink\" title=\"1.char和varchar的区别\"></a>1.char和varchar的区别</h2><p>①char设置多少长度就是多少长度，varchar可以改变长度，所以char的空间利用率不如varchar的空间利用率高。<br>②因为长度固定，所以存取速度要比varchar快。<br>③char适用于固定长度的字符串，比如身份证号、手机号等，varchar适用于不固定的字符串。</p>\n"},{"title":"RabbitMQ的使用详解","author":"author-2","date":"2024-03-25T13:55:59.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/y.jpg","description":"RabbitMQ是一个开源的消息代理,它通过消息队列提供了一种异步通信机制. RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统. 它遵循Mozilla Public License开源协议. RabbitMQ是使用Erlang编写的，并且RabbitMQ是基于AMQP协议的. RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统. RabbitMQ是使用Erlang编写的，并且RabbitMQ是基于AMQP协议的.","abstracts":"RabbitMQ是一个开源的消息代理,它通过消息队列提供了一种异步通信机制","_content":"# {{ title }}\n\n ## 简介 :\n - {{ description}}\n\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n\t<form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\"></form>\n</div>","source":"_posts/RabbitMQ的使用详解.md","raw":"---\ntitle: RabbitMQ的使用详解\nauthor: author-2\ndate: 2024-03-25 21:55:59\ntags:\n  - 后端\n  - RabbitMQ\ncategories:\n  - 后端\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/y.jpg\ndescription: RabbitMQ是一个开源的消息代理,它通过消息队列提供了一种异步通信机制. RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统. 它遵循Mozilla Public License开源协议. RabbitMQ是使用Erlang编写的，并且RabbitMQ是基于AMQP协议的. RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统. RabbitMQ是使用Erlang编写的，并且RabbitMQ是基于AMQP协议的. \n\nabstracts: RabbitMQ是一个开源的消息代理,它通过消息队列提供了一种异步通信机制\n---\n# {{ title }}\n\n ## 简介 :\n - {{ description}}\n\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n\t<form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\"></form>\n</div>","slug":"RabbitMQ的使用详解","published":1,"updated":"2024-03-25T15:11:09.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxk000hiou27rtu9b89","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>RabbitMQ的使用详解</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介 :\"></a>简介 :</h2><ul>\n<li>RabbitMQ是一个开源的消息代理,它通过消息队列提供了一种异步通信机制. RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统. 它遵循Mozilla Public License开源协议. RabbitMQ是使用Erlang编写的，并且RabbitMQ是基于AMQP协议的. RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统. RabbitMQ是使用Erlang编写的，并且RabbitMQ是基于AMQP协议的.</li>\n</ul>\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n    <form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\"></form>\n</div>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>RabbitMQ的使用详解</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介 :\"></a>简介 :</h2><ul>\n<li>RabbitMQ是一个开源的消息代理,它通过消息队列提供了一种异步通信机制. RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统. 它遵循Mozilla Public License开源协议. RabbitMQ是使用Erlang编写的，并且RabbitMQ是基于AMQP协议的. RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统. RabbitMQ是使用Erlang编写的，并且RabbitMQ是基于AMQP协议的.</li>\n</ul>\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n    <form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\"></form>\n</div>"},{"title":"SSM","date":"2024-03-18T14:14:10.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2024-02-04_23-53-27.png","_content":"# 一 SSM框架简介\n","source":"_posts/SSM.md","raw":"---\ntitle: SSM\ndate: 2024-03-18 22:14:10\ntags: SSM\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2024-02-04_23-53-27.png\n---\n# 一 SSM框架简介\n","slug":"SSM","published":1,"updated":"2024-03-20T04:18:28.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxl000liou2c1jb2rzh","content":"<h1 id=\"一-SSM框架简介\"><a href=\"#一-SSM框架简介\" class=\"headerlink\" title=\"一 SSM框架简介\"></a>一 SSM框架简介</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一-SSM框架简介\"><a href=\"#一-SSM框架简介\" class=\"headerlink\" title=\"一 SSM框架简介\"></a>一 SSM框架简介</h1>"},{"title":"Springboot+Mybatis-plus+Vue项目","author":{"name":"好名字都是狗起的","link":"https://hexo-git-test-3309446352s-projects.vercel.app/","avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg","description":"古来圣贤皆寂寞，惟有饮者留其名。","socials":{"github":"https://github.com/3309446352"}},"date":"2024-03-22T14:17:58.000Z","cover":"/svg/OIP.jpg","description":null,"abstracts":null,"_content":"# {{ title }}\n\n1. {{ description}}\n\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n\t<form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\">\n        <iframe style=\"height: 500px;width: 100%;\" src=\"//player.bilibili.com/player.html?aid=257068652&bvid=BV1NY411g7cf&cid=734545984&p=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n    </form>\n</div>\n\n<a href=\"/links\"><img src=\"/svg/OIP.jpg\" alt=\"OIP\" style=\"zoom: 67%;\" /></a>","source":"_posts/Springboot-Mybatis-plus-Vue项目.md","raw":"---\ntitle: Springboot+Mybatis-plus+Vue项目\nauthor:\n  name: 好名字都是狗起的\n  link: https://hexo-git-test-3309446352s-projects.vercel.app/\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\n  description: 古来圣贤皆寂寞，惟有饮者留其名。\n  socials:\n    github: https://github.com/3309446352\ndate: 2024-03-22 22:17:58\ntags:\n  -springboot\ncategories: [\"后端\"]\ncover: /svg/OIP.jpg\ndescription:\nabstracts:\n---\n# {{ title }}\n\n1. {{ description}}\n\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n\t<form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\">\n        <iframe style=\"height: 500px;width: 100%;\" src=\"//player.bilibili.com/player.html?aid=257068652&bvid=BV1NY411g7cf&cid=734545984&p=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n    </form>\n</div>\n\n<a href=\"/links\"><img src=\"/svg/OIP.jpg\" alt=\"OIP\" style=\"zoom: 67%;\" /></a>","slug":"Springboot-Mybatis-plus-Vue项目","published":1,"updated":"2024-03-24T16:58:28.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxm000niou22wogc1ec","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>Springboot+Mybatis-plus+Vue项目</h1><ol>\n<li></li>\n</ol>\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n    <form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\">\n        <iframe style=\"height: 500px;width: 100%;\" src=\"//player.bilibili.com/player.html?aid=257068652&bvid=BV1NY411g7cf&cid=734545984&p=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n    </form>\n</div>\n\n<p><a href=\"/links\"><img src=\"/svg/OIP.jpg\" alt=\"OIP\" style=\"zoom: 67%;\" /></a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>Springboot+Mybatis-plus+Vue项目</h1><ol>\n<li></li>\n</ol>\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n    <form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\">\n        <iframe style=\"height: 500px;width: 100%;\" src=\"//player.bilibili.com/player.html?aid=257068652&bvid=BV1NY411g7cf&cid=734545984&p=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n    </form>\n</div>\n\n<p><a href=\"/links\"><img src=\"/svg/OIP.jpg\" alt=\"OIP\" style=\"zoom: 67%;\" /></a></p>\n"},{"abbrlink":"爬取小说章节","abstracts":"Redis是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。","author":{"avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg","description":"古来圣贤皆寂寞，惟有饮者留其名。","link":"https://hexo-git-test-3309446352s-projects.vercel.app/","name":"好名字都是狗起的","socials":{"github":"https://github.com/3309446352"}},"cover":"https://redis.io/","date":"2024-03-24T15:13:16.329Z","description":"REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。  Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。","title":"Redis使用方法","updated":"2024-03-24T16:53:40.934Z","_content":"# 简介：\n\n{{ description}}\n\n# redis\n\n## 引入\n\n```yaml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-redis</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-pool2</artifactId> \n        </dependency>\n\n```\n\n## 配置\n\n```yaml\nspring:\n  redis:\n    # Redis服务器地址\n    host: 19.1.5.11\n    # Redis服务器端口号\n    port: 6379\n    # 使用的数据库索引，默认是0\n    database: 0\n    # 连接超时时间\n    timeout: 1800000\n     # 设置密码\n    password: \"123456\"\n    lettuce:\n      pool:\n        # 最大阻塞等待时间，负数表示没有限制\n        max-wait: -1\n        # 连接池中的最大空闲连接\n        max-idle: 5\n        # 连接池中的最小空闲连接\n        min-idle: 0\n        # 连接池中最大连接数，负数表示没有限制\n        max-active: 20\n\n```\n\n## 序列化防止乱码\n\n```java\n@Bean\npubtic RedisTemptate<String, Object> redisTemptate(RedisConnectionFactory redisConnectionFactory) { \n   \n    RedisTemptate<String, 0bject> redisTemptate = new RedisTempLate<>() ;\n    //Redis连接工厂\n    redisTemptate.setConnectionFactory(redisConnectionFactory);\n    redisTemptate . setKeySeriaLizer(new StringRedisSeriaLizer());\n    // 役 置 vatue 的 序列 化 策略 \n    redisTemptate.setVatueSeriatizer(new Jackson2JsonRedisSeriatizer<>(0bject.ctass));\n    return redisTemptate;\n}\n```\n\n或\n\n```java\n@Configuration\npublic class RedisConfig {\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)\n            throws UnknownHostException {\n        // 创建模板\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\n        // 设置连接工厂\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n        // 设置序列化工具\n        GenericJackson2JsonRedisSerializer jsonRedisSerializer =\n                new GenericJackson2JsonRedisSerializer();\n        // key和 hashKey采用 string序列化\n        redisTemplate.setKeySerializer(RedisSerializer.string());\n        redisTemplate.setHashKeySerializer(RedisSerializer.string());\n        // value和 hashValue采用 JSON序列化\n        redisTemplate.setValueSerializer(jsonRedisSerializer);\n        redisTemplate.setHashValueSerializer(jsonRedisSerializer);\n        return redisTemplate;\n    }\n}\n\n```\n\n## 增删改查\n\n[增删改查](https://img-blog.csdnimg.cn/20190412005015660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n,size_16,color_FFFFFF,t_70)\n\n#### String-字符串类型\n\n```java\npackage com.tensquare.article;\n\nimport com.tensquare.article.pojo.User;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport java.util.concurrent.TimeUnit;\n\n@SpringBootTest\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class RedisTemTest {\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    /*\n     * String类型的数据增删改查\n     * */\n    @Test\n    public void StringDataTest() {\n        // 创建User对象 ,要存入String类型的对象,需要实现 Serializable 接口\n        User user = new User(\"1\", \"Tom\", \"打棒球\", 15);\n\n        // 添加数据\n        redisTemplate.opsForValue().set(\"user\", user);\n\n        // 添加数据并设置有效时间为30s, (30, TimeUnit.SECONDS) 分别代表数字,计量单位\n        redisTemplate.opsForValue().set(\"user1\", \"Rose\", 30, TimeUnit.SECONDS);\n\n        //查找数据 根据key获取value\n        User value = (User) redisTemplate.opsForValue().get(\"user\");\n\n        //查找数据 长度\n        Long size = redisTemplate.opsForValue().size(\"user1\");\n\n        // 删除数据\n        redisTemplate.delete(\"user1\");\n    }\n}\n\n```\n\n#### Set-集合类型\n\n```java\n /*\n     * Set 集合类型CURD\n     * */\n    @Test\n    public void SetDataTest() {\n        User user = new User(\"1\", \"Tom\", \"打棒球\", 15);\n        User user1 = new User(\"2\", \"Jack\", \"打网球\", 17);\n        User user2 = new User(\"3\", \"Rose\", \"打篮球\", 18);\n        User user3 = new User(\"4\", \"Jerry\", \"踢足球\", 19);\n\n        // 添加 key为user_1的user对象\n        redisTemplate.opsForSet().add(\"user_1\", user);\n        redisTemplate.opsForSet().add(\"user_1\", user1);\n\n\t\t// 定时 设置 user_1 数据的存活时间为5秒 测试时注释\n        redisTemplate.expire(\"user_1\", 5, TimeUnit.SECONDS);\n\n        // 查询 user_1 集合中的所有 value\n        Set user1_list = redisTemplate.opsForSet().members(\"user_1\");\n        // 查询 user_1 集合中是否有 user 对象\n        Boolean result = redisTemplate.opsForSet().isMember(\"user_1\", user);\n\n        // 删除 user_1 集合中的 user对象 ,并返回移除成功数量\n        Long success_count = redisTemplate.opsForSet().remove(\"user_1\", user);\n        // 删除 user_1 集合中的栈顶元素\n        Object user_1 = redisTemplate.opsForSet().pop(\"user_1\");\n\n        // 测试 交集 并集 差集的数据\n        redisTemplate.opsForSet().add(\"names1\", user, user1, user2);\n        redisTemplate.opsForSet().add(\"names2\", user, user1, user3);\n        //取交集\n        Set<User> intersect = redisTemplate.opsForSet().intersect(\"names1\", \"names2\");\n        for (User u1 : intersect) {\n            System.out.println(\"交集: \" + u1);\n        }\n        //取并集\n        Set<User> union = redisTemplate.opsForSet().union(\"names1\", \"names2\");\n        for (User u2 : union) {\n            System.out.println(\"并集: \" + u2);\n        }\n        //取差集[第一个集合中存在，但第二个集合中不存在的元素]\n        Set<User> difference = redisTemplate.opsForSet().difference(\"names1\", \"names2\");\n        for (User u3 : difference) {\n            System.out.println(\"差集: \" + u3);\n        }\n    }\n\n```\n\n#### List-链表类型\n\n```java\n /*\n     * List 数据类型的CRUD\n     * */\n    @Test\n    public void ListDataTest() {\n        User user = new User(\"1\", \"Tom\", \"打棒球\", 15);\n        User user1 = new User(\"2\", \"Jack\", \"打网球\", 17);\n\n        //从左边添加一个元素\n        redisTemplate.opsForList().rightPush(\"user1\", user);\n        //从左边添加多个元素\n        redisTemplate.opsForList().leftPushAll(\"user2\", user, user1);\n\n        //从右边添加一个元素\n        redisTemplate.opsForList().rightPush(\"user3\", user1);\n        //从右边添加多个元素\n        redisTemplate.opsForList().rightPushAll(\"user4\", user, user1);\n\n\t\t// 定时 设置 user2 数据的存活时间为5秒 测试时注释\n        redisTemplate.expire(\"user2\", 5, TimeUnit.SECONDS);\n\n        /* 根据key和元素索引进行查询\n         *  0和正数代表从左边开始\n         *  负数代表从右边开始\n         * */\n        // 查询 user3 链表中所有的元素\n        List user3 = redisTemplate.opsForList().range(\"user3\", 0, -1);\n        // 查询 user3 链表中第一个元素\n        User data = (User) redisTemplate.opsForList().index(\"user3\", 0);\n        System.out.println(data);\n\n        // 修改 user3 链表中第一个的元素为 user1 对象\n        redisTemplate.opsForList().set(\"user3\", 0, user);\n  \t  \n  \t    // 删除链表左侧第二个 user 对象\n        redisTemplate.opsForList().remove(\"user3\", 2, user);\n        //删除 user3 链表中左侧的第一个元素\n        redisTemplate.opsForList().leftPop(\"user3\");\n        //删除 user3 链表中右侧的第一个元素\n        redisTemplate.opsForList().rightPop(\"user3\");\n    }\n\n```\n\n#### Hash-[散列](https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97&spm=1001.2101.3001.7020)类型\n\n```java\n    /*\n     * Hash集合CRUD\n     * */\n    @Test\n    public void HashDataTest() {\n        User user = new User(\"1\", \"Tom\", \"打棒球\", 15);\n        User user1 = new User(\"2\", \"Jack\", \"打网球\", 17);\n\n        // 添加 user 到 hash集合\n        redisTemplate.opsForHash().put(\"hash\", \"1\", user);\n        redisTemplate.opsForHash().put(\"hash\", \"2\", user1);\n\n\t\t// 定时 设置 hash 的数据存活时间为5秒 测试时注释\n        redisTemplate.expire(\"hash\", 5, TimeUnit.SECONDS);\n  \n        // 查询 hash中hashKey 为1的值\n        User hash = (User) redisTemplate.opsForHash().get(\"hash\", \"1\");\n        // 查询 hash中 所有hashKey 对应的的值\n        List<User> userList = redisTemplate.opsForHash().values(\"hash\");\n        // 查询 hash中 所有hashKey 对应的键值对\n        Map<String, User> hashKeyMap = redisTemplate.opsForHash().entries(\"hash\");\n        // 查询 hash中所有的hashKey\n        Set hashKeyList = redisTemplate.opsForHash().keys(\"hash\");\n        // 查询 hash 中 是否有 hashKey 为1\n        Boolean result = redisTemplate.opsForHash().hasKey(\"hash\", \"1\");\n\n        // 删除hash 中 HashKey为的1 的值(如需要删除多个,只需要用 \",\" 隔开\n        Long removeSize = redisTemplate.opsForHash().delete(\"hash\", \"1\");\n    }\n\n```\n\n#### [Zset]-有序集合类型\n\n```java\n/*\n     * zSet集合CRUD\n     * */\n    @Test\n    public void zSetDataTest() {\n        // 添加值\n        redisTemplate.opsForZSet().add(\"student\", \"wangwu\", 60);\n        redisTemplate.opsForZSet().add(\"student\", \"lishi\", 100);\n        redisTemplate.opsForZSet().add(\"student\", \"zhangshan\", 90);\n\n\t\t// 定时 设置 student 的数据存活时间为5秒 测试时注释\n        redisTemplate.expire(\"student\", 5, TimeUnit.SECONDS);\n\n        // 增加分数\n        redisTemplate.opsForZSet().incrementScore(\"student\", \"wangwu\", 30);\n        // 减少分数\n        redisTemplate.opsForZSet().incrementScore(\"student\", \"wangwu\", -50);\n\n        //查询 student 下 wangwu 的分数\n        Double score = redisTemplate.opsForZSet().score(\"student\", \"wangwu\");\n        //查询 一个元素在集合中的排名  排名从0开始\n        Long rank = redisTemplate.opsForZSet().rank(\"student\", \"zhangshan\");\n        // 查询前三个元素\n        Set<String> students = redisTemplate.opsForZSet().range(\"student\", 0, 2);\n        // 查询  前三个元素的键值对\n        Set<ZSetOperations.TypedTuple<String>> student = redisTemplate.opsForZSet().rangeWithScores(\"student\", 0, 2);\n        // 查询 根据值的区间查询 key\n        Set<String> students1 = redisTemplate.opsForZSet().rangeByScore(\"student\", 50, 100);\n        // 查询 根据值区间查询 Set集合\n        Set<ZSetOperations.TypedTuple<String>> student1 = redisTemplate.opsForZSet().rangeByScoreWithScores(\"student\", 50, 100);\n        //查询 student 中有几个 key\n        Long result = redisTemplate.opsForZSet().zCard(\"student\");\n\n        //根据key-value删除 value允许传入多个\n        redisTemplate.opsForZSet().remove(\"student\",\"zhangsan\",\"lisi\");\n        //根据排名区间删除\n        redisTemplate.opsForZSet().removeRange(\"student\",0,1);\n        //根据分数区间删除\n        redisTemplate.opsForZSet().removeRangeByScore(\"student\",70,90);\n    }\n\n```\n\n### 增删改查工具类\n\n```java\npackage com.lsqingfeng.springboot.utils; \nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\n \nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n \n/**\n * @className: RedisUtil\n * @description:\n * @author: sh.Liu\n * @date: 2022-03-09 14:07\n */\n@Component\npublic class RedisUtil {\n \n    @Autowired\n    private RedisTemplate redisTemplate;\n    /**\n     * 给一个指定的 key 值附加过期时间\n     *\n     * @param key\n     * @param time\n     * @return\n     */\n    public boolean expire(String key, long time) {\n        return redisTemplate.expire(key, time, TimeUnit.SECONDS);\n    }\n    /**\n     * 根据key 获取过期时间\n     *\n     * @param key\n     * @return\n     */\n    public long getTime(String key) {\n        return redisTemplate.getExpire(key, TimeUnit.SECONDS);\n    }\n    /**\n     * 根据key 获取过期时间\n     *\n     * @param key\n     * @return\n     */\n    public boolean hasKey(String key) {\n        return redisTemplate.hasKey(key);\n    }\n    /**\n     * 移除指定key 的过期时间\n     *\n     * @param key\n     * @return\n     */\n    public boolean persist(String key) {\n        return redisTemplate.boundValueOps(key).persist();\n    }\n \n    //- - - - - - - - - - - - - - - - - - - - -  String类型 - - - - - - - - - - - - - - - - - - - -\n \n    /**\n     * 根据key获取值\n     *\n     * @param key 键\n     * @return 值\n     */\n    public Object get(String key) {\n        return key == null ? null : redisTemplate.opsForValue().get(key);\n    }\n \n    /**\n     * 将值放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     * @return true成功 false 失败\n     */\n    public void set(String key, String value) {\n        redisTemplate.opsForValue().set(key, value);\n    }\n \n    /**\n     * 将值放入缓存并设置时间\n     *\n     * @param key   键\n     * @param value 值\n     * @param time  时间(秒) -1为无期限\n     * @return true成功 false 失败\n     */\n    public void set(String key, String value, long time) {\n        if (time > 0) {\n            redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\n        } else {\n            redisTemplate.opsForValue().set(key, value);\n        }\n    }\n \n    /**\n     * 批量添加 key (重复的键会覆盖)\n     *\n     * @param keyAndValue\n     */\n    public void batchSet(Map<String, String> keyAndValue) {\n        redisTemplate.opsForValue().multiSet(keyAndValue);\n    }\n \n    /**\n     * 批量添加 key-value 只有在键不存在时,才添加\n     * map 中只要有一个key存在,则全部不添加\n     *\n     * @param keyAndValue\n     */\n    public void batchSetIfAbsent(Map<String, String> keyAndValue) {\n        redisTemplate.opsForValue().multiSetIfAbsent(keyAndValue);\n    }\n \n    /**\n     * 对一个 key-value 的值进行加减操作,\n     * 如果该 key 不存在 将创建一个key 并赋值该 number\n     * 如果 key 存在,但 value 不是长整型 ,将报错\n     *\n     * @param key\n     * @param number\n     */\n    public Long increment(String key, long number) {\n        return redisTemplate.opsForValue().increment(key, number);\n    }\n \n    /**\n     * 对一个 key-value 的值进行加减操作,\n     * 如果该 key 不存在 将创建一个key 并赋值该 number\n     * 如果 key 存在,但 value 不是 纯数字 ,将报错\n     *\n     * @param key\n     * @param number\n     */\n    public Double increment(String key, double number) {\n        return redisTemplate.opsForValue().increment(key, number);\n    }\n \n    //- - - - - - - - - - - - - - - - - - - - -  set类型 - - - - - - - - - - - - - - - - - - - -\n \n    /**\n     * 将数据放入set缓存\n     *\n     * @param key 键\n     * @return\n     */\n    public void sSet(String key, String value) {\n        redisTemplate.opsForSet().add(key, value);\n    }\n \n    /**\n     * 获取变量中的值\n     *\n     * @param key 键\n     * @return\n     */\n    public Set<Object> members(String key) {\n        return redisTemplate.opsForSet().members(key);\n    }\n \n    /**\n     * 随机获取变量中指定个数的元素\n     *\n     * @param key   键\n     * @param count 值\n     * @return\n     */\n    public void randomMembers(String key, long count) {\n        redisTemplate.opsForSet().randomMembers(key, count);\n    }\n \n    /**\n     * 随机获取变量中的元素\n     *\n     * @param key 键\n     * @return\n     */\n    public Object randomMember(String key) {\n        return redisTemplate.opsForSet().randomMember(key);\n    }\n \n    /**\n     * 弹出变量中的元素\n     *\n     * @param key 键\n     * @return\n     */\n    public Object pop(String key) {\n        return redisTemplate.opsForSet().pop(\"setValue\");\n    }\n \n    /**\n     * 获取变量中值的长度\n     *\n     * @param key 键\n     * @return\n     */\n    public long size(String key) {\n        return redisTemplate.opsForSet().size(key);\n    }\n \n    /**\n     * 根据value从一个set中查询,是否存在\n     *\n     * @param key   键\n     * @param value 值\n     * @return true 存在 false不存在\n     */\n    public boolean sHasKey(String key, Object value) {\n        return redisTemplate.opsForSet().isMember(key, value);\n    }\n \n    /**\n     * 检查给定的元素是否在变量中。\n     *\n     * @param key 键\n     * @param obj 元素对象\n     * @return\n     */\n    public boolean isMember(String key, Object obj) {\n        return redisTemplate.opsForSet().isMember(key, obj);\n    }\n \n    /**\n     * 转移变量的元素值到目的变量。\n     *\n     * @param key     键\n     * @param value   元素对象\n     * @param destKey 元素对象\n     * @return\n     */\n    public boolean move(String key, String value, String destKey) {\n        return redisTemplate.opsForSet().move(key, value, destKey);\n    }\n \n    /**\n     * 批量移除set缓存中元素\n     *\n     * @param key    键\n     * @param values 值\n     * @return\n     */\n    public void remove(String key, Object... values) {\n        redisTemplate.opsForSet().remove(key, values);\n    }\n \n    /**\n     * 通过给定的key求2个set变量的差值\n     *\n     * @param key     键\n     * @param destKey 键\n     * @return\n     */\n    public Set<Set> difference(String key, String destKey) {\n        return redisTemplate.opsForSet().difference(key, destKey);\n    }\n \n \n    //- - - - - - - - - - - - - - - - - - - - -  hash类型 - - - - - - - - - - - - - - - - - - - -\n \n    /**\n     * 加入缓存\n     *\n     * @param key 键\n     * @param map 键\n     * @return\n     */\n    public void add(String key, Map<String, String> map) {\n        redisTemplate.opsForHash().putAll(key, map);\n    }\n \n    /**\n     * 获取 key 下的 所有  hashkey 和 value\n     *\n     * @param key 键\n     * @return\n     */\n    public Map<Object, Object> getHashEntries(String key) {\n        return redisTemplate.opsForHash().entries(key);\n    }\n \n    /**\n     * 验证指定 key 下 有没有指定的 hashkey\n     *\n     * @param key\n     * @param hashKey\n     * @return\n     */\n    public boolean hashKey(String key, String hashKey) {\n        return redisTemplate.opsForHash().hasKey(key, hashKey);\n    }\n \n    /**\n     * 获取指定key的值string\n     *\n     * @param key  键\n     * @param key2 键\n     * @return\n     */\n    public String getMapString(String key, String key2) {\n        return redisTemplate.opsForHash().get(\"map1\", \"key1\").toString();\n    }\n \n    /**\n     * 获取指定的值Int\n     *\n     * @param key  键\n     * @param key2 键\n     * @return\n     */\n    public Integer getMapInt(String key, String key2) {\n        return (Integer) redisTemplate.opsForHash().get(\"map1\", \"key1\");\n    }\n \n    /**\n     * 弹出元素并删除\n     *\n     * @param key 键\n     * @return\n     */\n    public String popValue(String key) {\n        return redisTemplate.opsForSet().pop(key).toString();\n    }\n \n    /**\n     * 删除指定 hash 的 HashKey\n     *\n     * @param key\n     * @param hashKeys\n     * @return 删除成功的 数量\n     */\n    public Long delete(String key, String... hashKeys) {\n        return redisTemplate.opsForHash().delete(key, hashKeys);\n    }\n \n    /**\n     * 给指定 hash 的 hashkey 做增减操作\n     *\n     * @param key\n     * @param hashKey\n     * @param number\n     * @return\n     */\n    public Long increment(String key, String hashKey, long number) {\n        return redisTemplate.opsForHash().increment(key, hashKey, number);\n    }\n \n    /**\n     * 给指定 hash 的 hashkey 做增减操作\n     *\n     * @param key\n     * @param hashKey\n     * @param number\n     * @return\n     */\n    public Double increment(String key, String hashKey, Double number) {\n        return redisTemplate.opsForHash().increment(key, hashKey, number);\n    }\n \n    /**\n     * 获取 key 下的 所有 hashkey 字段\n     *\n     * @param key\n     * @return\n     */\n    public Set<Object> hashKeys(String key) {\n        return redisTemplate.opsForHash().keys(key);\n    }\n \n    /**\n     * 获取指定 hash 下面的 键值对 数量\n     *\n     * @param key\n     * @return\n     */\n    public Long hashSize(String key) {\n        return redisTemplate.opsForHash().size(key);\n    }\n \n    //- - - - - - - - - - - - - - - - - - - - -  list类型 - - - - - - - - - - - - - - - - - - - -\n \n    /**\n     * 在变量左边添加元素值\n     *\n     * @param key\n     * @param value\n     * @return\n     */\n    public void leftPush(String key, Object value) {\n        redisTemplate.opsForList().leftPush(key, value);\n    }\n \n    /**\n     * 获取集合指定位置的值。\n     *\n     * @param key\n     * @param index\n     * @return\n     */\n    public Object index(String key, long index) {\n        return redisTemplate.opsForList().index(\"list\", 1);\n    }\n \n    /**\n     * 获取指定区间的值。\n     *\n     * @param key\n     * @param start\n     * @param end\n     * @return\n     */\n    public List<Object> range(String key, long start, long end) {\n        return redisTemplate.opsForList().range(key, start, end);\n    }\n \n    /**\n     * 把最后一个参数值放到指定集合的第一个出现中间参数的前面，\n     * 如果中间参数值存在的话。\n     *\n     * @param key\n     * @param pivot\n     * @param value\n     * @return\n     */\n    public void leftPush(String key, String pivot, String value) {\n        redisTemplate.opsForList().leftPush(key, pivot, value);\n    }\n \n    /**\n     * 向左边批量添加参数元素。\n     *\n     * @param key\n     * @param values\n     * @return\n     */\n    public void leftPushAll(String key, String... values) {\n//        redisTemplate.opsForList().leftPushAll(key,\"w\",\"x\",\"y\");\n        redisTemplate.opsForList().leftPushAll(key, values);\n    }\n \n    /**\n     * 向集合最右边添加元素。\n     *\n     * @param key\n     * @param value\n     * @return\n     */\n    public void leftPushAll(String key, String value) {\n        redisTemplate.opsForList().rightPush(key, value);\n    }\n \n    /**\n     * 向左边批量添加参数元素。\n     *\n     * @param key\n     * @param values\n     * @return\n     */\n    public void rightPushAll(String key, String... values) {\n        //redisTemplate.opsForList().leftPushAll(key,\"w\",\"x\",\"y\");\n        redisTemplate.opsForList().rightPushAll(key, values);\n    }\n \n    /**\n     * 向已存在的集合中添加元素。\n     *\n     * @param key\n     * @param value\n     * @return\n     */\n    public void rightPushIfPresent(String key, Object value) {\n        redisTemplate.opsForList().rightPushIfPresent(key, value);\n    }\n \n    /**\n     * 向已存在的集合中添加元素。\n     *\n     * @param key\n     * @return\n     */\n    public long listLength(String key) {\n        return redisTemplate.opsForList().size(key);\n    }\n \n    /**\n     * 移除集合中的左边第一个元素。\n     *\n     * @param key\n     * @return\n     */\n    public void leftPop(String key) {\n        redisTemplate.opsForList().leftPop(key);\n    }\n \n    /**\n     * 移除集合中左边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。\n     *\n     * @param key\n     * @return\n     */\n    public void leftPop(String key, long timeout, TimeUnit unit) {\n        redisTemplate.opsForList().leftPop(key, timeout, unit);\n    }\n \n    /**\n     * 移除集合中右边的元素。\n     *\n     * @param key\n     * @return\n     */\n    public void rightPop(String key) {\n        redisTemplate.opsForList().rightPop(key);\n    }\n \n    /**\n     * 移除集合中右边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。\n     *\n     * @param key\n     * @return\n     */\n    public void rightPop(String key, long timeout, TimeUnit unit) {\n        redisTemplate.opsForList().rightPop(key, timeout, unit);\n    }\n}\n\n```\n\n## 缓存穿透\n\n[穿透](https://img-blog.csdnimg.cn/37bd6dbb88c045ce84deb3fed774b59c.png)\n\n## 缓存雪崩\n\n[雪崩](https://img-blog.csdnimg.cn/9c38ab494d4b4d13930ea14d8f3f0db7.png)\n\n## 缓存击穿\n\n[击穿](https://img-blog.csdnimg.cn/3d01ccb55bde4a2d96aad731d98f4ef3.png)\n\n## 主从集群-复制\n\n## 哨兵\n","source":"_posts/Redis使用方法.md","raw":"---\nabbrlink: 爬取小说章节\nabstracts: Redis是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。\nauthor:\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\n  description: 古来圣贤皆寂寞，惟有饮者留其名。\n  link: https://hexo-git-test-3309446352s-projects.vercel.app/\n  name: 好名字都是狗起的\n  socials:\n    github: https://github.com/3309446352\ncategories: [\"后端\"]\ncover: https://redis.io/\ndate: '2024-03-24T23:13:16.329363+08:00'\ndescription: REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。  Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。\ntags:\n- 后端\ntitle: Redis使用方法\nupdated: '2024-03-25T00:53:40.934+08:00'\n---\n# 简介：\n\n{{ description}}\n\n# redis\n\n## 引入\n\n```yaml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-redis</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-pool2</artifactId> \n        </dependency>\n\n```\n\n## 配置\n\n```yaml\nspring:\n  redis:\n    # Redis服务器地址\n    host: 19.1.5.11\n    # Redis服务器端口号\n    port: 6379\n    # 使用的数据库索引，默认是0\n    database: 0\n    # 连接超时时间\n    timeout: 1800000\n     # 设置密码\n    password: \"123456\"\n    lettuce:\n      pool:\n        # 最大阻塞等待时间，负数表示没有限制\n        max-wait: -1\n        # 连接池中的最大空闲连接\n        max-idle: 5\n        # 连接池中的最小空闲连接\n        min-idle: 0\n        # 连接池中最大连接数，负数表示没有限制\n        max-active: 20\n\n```\n\n## 序列化防止乱码\n\n```java\n@Bean\npubtic RedisTemptate<String, Object> redisTemptate(RedisConnectionFactory redisConnectionFactory) { \n   \n    RedisTemptate<String, 0bject> redisTemptate = new RedisTempLate<>() ;\n    //Redis连接工厂\n    redisTemptate.setConnectionFactory(redisConnectionFactory);\n    redisTemptate . setKeySeriaLizer(new StringRedisSeriaLizer());\n    // 役 置 vatue 的 序列 化 策略 \n    redisTemptate.setVatueSeriatizer(new Jackson2JsonRedisSeriatizer<>(0bject.ctass));\n    return redisTemptate;\n}\n```\n\n或\n\n```java\n@Configuration\npublic class RedisConfig {\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)\n            throws UnknownHostException {\n        // 创建模板\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\n        // 设置连接工厂\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n        // 设置序列化工具\n        GenericJackson2JsonRedisSerializer jsonRedisSerializer =\n                new GenericJackson2JsonRedisSerializer();\n        // key和 hashKey采用 string序列化\n        redisTemplate.setKeySerializer(RedisSerializer.string());\n        redisTemplate.setHashKeySerializer(RedisSerializer.string());\n        // value和 hashValue采用 JSON序列化\n        redisTemplate.setValueSerializer(jsonRedisSerializer);\n        redisTemplate.setHashValueSerializer(jsonRedisSerializer);\n        return redisTemplate;\n    }\n}\n\n```\n\n## 增删改查\n\n[增删改查](https://img-blog.csdnimg.cn/20190412005015660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n,size_16,color_FFFFFF,t_70)\n\n#### String-字符串类型\n\n```java\npackage com.tensquare.article;\n\nimport com.tensquare.article.pojo.User;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport java.util.concurrent.TimeUnit;\n\n@SpringBootTest\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class RedisTemTest {\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    /*\n     * String类型的数据增删改查\n     * */\n    @Test\n    public void StringDataTest() {\n        // 创建User对象 ,要存入String类型的对象,需要实现 Serializable 接口\n        User user = new User(\"1\", \"Tom\", \"打棒球\", 15);\n\n        // 添加数据\n        redisTemplate.opsForValue().set(\"user\", user);\n\n        // 添加数据并设置有效时间为30s, (30, TimeUnit.SECONDS) 分别代表数字,计量单位\n        redisTemplate.opsForValue().set(\"user1\", \"Rose\", 30, TimeUnit.SECONDS);\n\n        //查找数据 根据key获取value\n        User value = (User) redisTemplate.opsForValue().get(\"user\");\n\n        //查找数据 长度\n        Long size = redisTemplate.opsForValue().size(\"user1\");\n\n        // 删除数据\n        redisTemplate.delete(\"user1\");\n    }\n}\n\n```\n\n#### Set-集合类型\n\n```java\n /*\n     * Set 集合类型CURD\n     * */\n    @Test\n    public void SetDataTest() {\n        User user = new User(\"1\", \"Tom\", \"打棒球\", 15);\n        User user1 = new User(\"2\", \"Jack\", \"打网球\", 17);\n        User user2 = new User(\"3\", \"Rose\", \"打篮球\", 18);\n        User user3 = new User(\"4\", \"Jerry\", \"踢足球\", 19);\n\n        // 添加 key为user_1的user对象\n        redisTemplate.opsForSet().add(\"user_1\", user);\n        redisTemplate.opsForSet().add(\"user_1\", user1);\n\n\t\t// 定时 设置 user_1 数据的存活时间为5秒 测试时注释\n        redisTemplate.expire(\"user_1\", 5, TimeUnit.SECONDS);\n\n        // 查询 user_1 集合中的所有 value\n        Set user1_list = redisTemplate.opsForSet().members(\"user_1\");\n        // 查询 user_1 集合中是否有 user 对象\n        Boolean result = redisTemplate.opsForSet().isMember(\"user_1\", user);\n\n        // 删除 user_1 集合中的 user对象 ,并返回移除成功数量\n        Long success_count = redisTemplate.opsForSet().remove(\"user_1\", user);\n        // 删除 user_1 集合中的栈顶元素\n        Object user_1 = redisTemplate.opsForSet().pop(\"user_1\");\n\n        // 测试 交集 并集 差集的数据\n        redisTemplate.opsForSet().add(\"names1\", user, user1, user2);\n        redisTemplate.opsForSet().add(\"names2\", user, user1, user3);\n        //取交集\n        Set<User> intersect = redisTemplate.opsForSet().intersect(\"names1\", \"names2\");\n        for (User u1 : intersect) {\n            System.out.println(\"交集: \" + u1);\n        }\n        //取并集\n        Set<User> union = redisTemplate.opsForSet().union(\"names1\", \"names2\");\n        for (User u2 : union) {\n            System.out.println(\"并集: \" + u2);\n        }\n        //取差集[第一个集合中存在，但第二个集合中不存在的元素]\n        Set<User> difference = redisTemplate.opsForSet().difference(\"names1\", \"names2\");\n        for (User u3 : difference) {\n            System.out.println(\"差集: \" + u3);\n        }\n    }\n\n```\n\n#### List-链表类型\n\n```java\n /*\n     * List 数据类型的CRUD\n     * */\n    @Test\n    public void ListDataTest() {\n        User user = new User(\"1\", \"Tom\", \"打棒球\", 15);\n        User user1 = new User(\"2\", \"Jack\", \"打网球\", 17);\n\n        //从左边添加一个元素\n        redisTemplate.opsForList().rightPush(\"user1\", user);\n        //从左边添加多个元素\n        redisTemplate.opsForList().leftPushAll(\"user2\", user, user1);\n\n        //从右边添加一个元素\n        redisTemplate.opsForList().rightPush(\"user3\", user1);\n        //从右边添加多个元素\n        redisTemplate.opsForList().rightPushAll(\"user4\", user, user1);\n\n\t\t// 定时 设置 user2 数据的存活时间为5秒 测试时注释\n        redisTemplate.expire(\"user2\", 5, TimeUnit.SECONDS);\n\n        /* 根据key和元素索引进行查询\n         *  0和正数代表从左边开始\n         *  负数代表从右边开始\n         * */\n        // 查询 user3 链表中所有的元素\n        List user3 = redisTemplate.opsForList().range(\"user3\", 0, -1);\n        // 查询 user3 链表中第一个元素\n        User data = (User) redisTemplate.opsForList().index(\"user3\", 0);\n        System.out.println(data);\n\n        // 修改 user3 链表中第一个的元素为 user1 对象\n        redisTemplate.opsForList().set(\"user3\", 0, user);\n  \t  \n  \t    // 删除链表左侧第二个 user 对象\n        redisTemplate.opsForList().remove(\"user3\", 2, user);\n        //删除 user3 链表中左侧的第一个元素\n        redisTemplate.opsForList().leftPop(\"user3\");\n        //删除 user3 链表中右侧的第一个元素\n        redisTemplate.opsForList().rightPop(\"user3\");\n    }\n\n```\n\n#### Hash-[散列](https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97&spm=1001.2101.3001.7020)类型\n\n```java\n    /*\n     * Hash集合CRUD\n     * */\n    @Test\n    public void HashDataTest() {\n        User user = new User(\"1\", \"Tom\", \"打棒球\", 15);\n        User user1 = new User(\"2\", \"Jack\", \"打网球\", 17);\n\n        // 添加 user 到 hash集合\n        redisTemplate.opsForHash().put(\"hash\", \"1\", user);\n        redisTemplate.opsForHash().put(\"hash\", \"2\", user1);\n\n\t\t// 定时 设置 hash 的数据存活时间为5秒 测试时注释\n        redisTemplate.expire(\"hash\", 5, TimeUnit.SECONDS);\n  \n        // 查询 hash中hashKey 为1的值\n        User hash = (User) redisTemplate.opsForHash().get(\"hash\", \"1\");\n        // 查询 hash中 所有hashKey 对应的的值\n        List<User> userList = redisTemplate.opsForHash().values(\"hash\");\n        // 查询 hash中 所有hashKey 对应的键值对\n        Map<String, User> hashKeyMap = redisTemplate.opsForHash().entries(\"hash\");\n        // 查询 hash中所有的hashKey\n        Set hashKeyList = redisTemplate.opsForHash().keys(\"hash\");\n        // 查询 hash 中 是否有 hashKey 为1\n        Boolean result = redisTemplate.opsForHash().hasKey(\"hash\", \"1\");\n\n        // 删除hash 中 HashKey为的1 的值(如需要删除多个,只需要用 \",\" 隔开\n        Long removeSize = redisTemplate.opsForHash().delete(\"hash\", \"1\");\n    }\n\n```\n\n#### [Zset]-有序集合类型\n\n```java\n/*\n     * zSet集合CRUD\n     * */\n    @Test\n    public void zSetDataTest() {\n        // 添加值\n        redisTemplate.opsForZSet().add(\"student\", \"wangwu\", 60);\n        redisTemplate.opsForZSet().add(\"student\", \"lishi\", 100);\n        redisTemplate.opsForZSet().add(\"student\", \"zhangshan\", 90);\n\n\t\t// 定时 设置 student 的数据存活时间为5秒 测试时注释\n        redisTemplate.expire(\"student\", 5, TimeUnit.SECONDS);\n\n        // 增加分数\n        redisTemplate.opsForZSet().incrementScore(\"student\", \"wangwu\", 30);\n        // 减少分数\n        redisTemplate.opsForZSet().incrementScore(\"student\", \"wangwu\", -50);\n\n        //查询 student 下 wangwu 的分数\n        Double score = redisTemplate.opsForZSet().score(\"student\", \"wangwu\");\n        //查询 一个元素在集合中的排名  排名从0开始\n        Long rank = redisTemplate.opsForZSet().rank(\"student\", \"zhangshan\");\n        // 查询前三个元素\n        Set<String> students = redisTemplate.opsForZSet().range(\"student\", 0, 2);\n        // 查询  前三个元素的键值对\n        Set<ZSetOperations.TypedTuple<String>> student = redisTemplate.opsForZSet().rangeWithScores(\"student\", 0, 2);\n        // 查询 根据值的区间查询 key\n        Set<String> students1 = redisTemplate.opsForZSet().rangeByScore(\"student\", 50, 100);\n        // 查询 根据值区间查询 Set集合\n        Set<ZSetOperations.TypedTuple<String>> student1 = redisTemplate.opsForZSet().rangeByScoreWithScores(\"student\", 50, 100);\n        //查询 student 中有几个 key\n        Long result = redisTemplate.opsForZSet().zCard(\"student\");\n\n        //根据key-value删除 value允许传入多个\n        redisTemplate.opsForZSet().remove(\"student\",\"zhangsan\",\"lisi\");\n        //根据排名区间删除\n        redisTemplate.opsForZSet().removeRange(\"student\",0,1);\n        //根据分数区间删除\n        redisTemplate.opsForZSet().removeRangeByScore(\"student\",70,90);\n    }\n\n```\n\n### 增删改查工具类\n\n```java\npackage com.lsqingfeng.springboot.utils; \nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\n \nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n \n/**\n * @className: RedisUtil\n * @description:\n * @author: sh.Liu\n * @date: 2022-03-09 14:07\n */\n@Component\npublic class RedisUtil {\n \n    @Autowired\n    private RedisTemplate redisTemplate;\n    /**\n     * 给一个指定的 key 值附加过期时间\n     *\n     * @param key\n     * @param time\n     * @return\n     */\n    public boolean expire(String key, long time) {\n        return redisTemplate.expire(key, time, TimeUnit.SECONDS);\n    }\n    /**\n     * 根据key 获取过期时间\n     *\n     * @param key\n     * @return\n     */\n    public long getTime(String key) {\n        return redisTemplate.getExpire(key, TimeUnit.SECONDS);\n    }\n    /**\n     * 根据key 获取过期时间\n     *\n     * @param key\n     * @return\n     */\n    public boolean hasKey(String key) {\n        return redisTemplate.hasKey(key);\n    }\n    /**\n     * 移除指定key 的过期时间\n     *\n     * @param key\n     * @return\n     */\n    public boolean persist(String key) {\n        return redisTemplate.boundValueOps(key).persist();\n    }\n \n    //- - - - - - - - - - - - - - - - - - - - -  String类型 - - - - - - - - - - - - - - - - - - - -\n \n    /**\n     * 根据key获取值\n     *\n     * @param key 键\n     * @return 值\n     */\n    public Object get(String key) {\n        return key == null ? null : redisTemplate.opsForValue().get(key);\n    }\n \n    /**\n     * 将值放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     * @return true成功 false 失败\n     */\n    public void set(String key, String value) {\n        redisTemplate.opsForValue().set(key, value);\n    }\n \n    /**\n     * 将值放入缓存并设置时间\n     *\n     * @param key   键\n     * @param value 值\n     * @param time  时间(秒) -1为无期限\n     * @return true成功 false 失败\n     */\n    public void set(String key, String value, long time) {\n        if (time > 0) {\n            redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\n        } else {\n            redisTemplate.opsForValue().set(key, value);\n        }\n    }\n \n    /**\n     * 批量添加 key (重复的键会覆盖)\n     *\n     * @param keyAndValue\n     */\n    public void batchSet(Map<String, String> keyAndValue) {\n        redisTemplate.opsForValue().multiSet(keyAndValue);\n    }\n \n    /**\n     * 批量添加 key-value 只有在键不存在时,才添加\n     * map 中只要有一个key存在,则全部不添加\n     *\n     * @param keyAndValue\n     */\n    public void batchSetIfAbsent(Map<String, String> keyAndValue) {\n        redisTemplate.opsForValue().multiSetIfAbsent(keyAndValue);\n    }\n \n    /**\n     * 对一个 key-value 的值进行加减操作,\n     * 如果该 key 不存在 将创建一个key 并赋值该 number\n     * 如果 key 存在,但 value 不是长整型 ,将报错\n     *\n     * @param key\n     * @param number\n     */\n    public Long increment(String key, long number) {\n        return redisTemplate.opsForValue().increment(key, number);\n    }\n \n    /**\n     * 对一个 key-value 的值进行加减操作,\n     * 如果该 key 不存在 将创建一个key 并赋值该 number\n     * 如果 key 存在,但 value 不是 纯数字 ,将报错\n     *\n     * @param key\n     * @param number\n     */\n    public Double increment(String key, double number) {\n        return redisTemplate.opsForValue().increment(key, number);\n    }\n \n    //- - - - - - - - - - - - - - - - - - - - -  set类型 - - - - - - - - - - - - - - - - - - - -\n \n    /**\n     * 将数据放入set缓存\n     *\n     * @param key 键\n     * @return\n     */\n    public void sSet(String key, String value) {\n        redisTemplate.opsForSet().add(key, value);\n    }\n \n    /**\n     * 获取变量中的值\n     *\n     * @param key 键\n     * @return\n     */\n    public Set<Object> members(String key) {\n        return redisTemplate.opsForSet().members(key);\n    }\n \n    /**\n     * 随机获取变量中指定个数的元素\n     *\n     * @param key   键\n     * @param count 值\n     * @return\n     */\n    public void randomMembers(String key, long count) {\n        redisTemplate.opsForSet().randomMembers(key, count);\n    }\n \n    /**\n     * 随机获取变量中的元素\n     *\n     * @param key 键\n     * @return\n     */\n    public Object randomMember(String key) {\n        return redisTemplate.opsForSet().randomMember(key);\n    }\n \n    /**\n     * 弹出变量中的元素\n     *\n     * @param key 键\n     * @return\n     */\n    public Object pop(String key) {\n        return redisTemplate.opsForSet().pop(\"setValue\");\n    }\n \n    /**\n     * 获取变量中值的长度\n     *\n     * @param key 键\n     * @return\n     */\n    public long size(String key) {\n        return redisTemplate.opsForSet().size(key);\n    }\n \n    /**\n     * 根据value从一个set中查询,是否存在\n     *\n     * @param key   键\n     * @param value 值\n     * @return true 存在 false不存在\n     */\n    public boolean sHasKey(String key, Object value) {\n        return redisTemplate.opsForSet().isMember(key, value);\n    }\n \n    /**\n     * 检查给定的元素是否在变量中。\n     *\n     * @param key 键\n     * @param obj 元素对象\n     * @return\n     */\n    public boolean isMember(String key, Object obj) {\n        return redisTemplate.opsForSet().isMember(key, obj);\n    }\n \n    /**\n     * 转移变量的元素值到目的变量。\n     *\n     * @param key     键\n     * @param value   元素对象\n     * @param destKey 元素对象\n     * @return\n     */\n    public boolean move(String key, String value, String destKey) {\n        return redisTemplate.opsForSet().move(key, value, destKey);\n    }\n \n    /**\n     * 批量移除set缓存中元素\n     *\n     * @param key    键\n     * @param values 值\n     * @return\n     */\n    public void remove(String key, Object... values) {\n        redisTemplate.opsForSet().remove(key, values);\n    }\n \n    /**\n     * 通过给定的key求2个set变量的差值\n     *\n     * @param key     键\n     * @param destKey 键\n     * @return\n     */\n    public Set<Set> difference(String key, String destKey) {\n        return redisTemplate.opsForSet().difference(key, destKey);\n    }\n \n \n    //- - - - - - - - - - - - - - - - - - - - -  hash类型 - - - - - - - - - - - - - - - - - - - -\n \n    /**\n     * 加入缓存\n     *\n     * @param key 键\n     * @param map 键\n     * @return\n     */\n    public void add(String key, Map<String, String> map) {\n        redisTemplate.opsForHash().putAll(key, map);\n    }\n \n    /**\n     * 获取 key 下的 所有  hashkey 和 value\n     *\n     * @param key 键\n     * @return\n     */\n    public Map<Object, Object> getHashEntries(String key) {\n        return redisTemplate.opsForHash().entries(key);\n    }\n \n    /**\n     * 验证指定 key 下 有没有指定的 hashkey\n     *\n     * @param key\n     * @param hashKey\n     * @return\n     */\n    public boolean hashKey(String key, String hashKey) {\n        return redisTemplate.opsForHash().hasKey(key, hashKey);\n    }\n \n    /**\n     * 获取指定key的值string\n     *\n     * @param key  键\n     * @param key2 键\n     * @return\n     */\n    public String getMapString(String key, String key2) {\n        return redisTemplate.opsForHash().get(\"map1\", \"key1\").toString();\n    }\n \n    /**\n     * 获取指定的值Int\n     *\n     * @param key  键\n     * @param key2 键\n     * @return\n     */\n    public Integer getMapInt(String key, String key2) {\n        return (Integer) redisTemplate.opsForHash().get(\"map1\", \"key1\");\n    }\n \n    /**\n     * 弹出元素并删除\n     *\n     * @param key 键\n     * @return\n     */\n    public String popValue(String key) {\n        return redisTemplate.opsForSet().pop(key).toString();\n    }\n \n    /**\n     * 删除指定 hash 的 HashKey\n     *\n     * @param key\n     * @param hashKeys\n     * @return 删除成功的 数量\n     */\n    public Long delete(String key, String... hashKeys) {\n        return redisTemplate.opsForHash().delete(key, hashKeys);\n    }\n \n    /**\n     * 给指定 hash 的 hashkey 做增减操作\n     *\n     * @param key\n     * @param hashKey\n     * @param number\n     * @return\n     */\n    public Long increment(String key, String hashKey, long number) {\n        return redisTemplate.opsForHash().increment(key, hashKey, number);\n    }\n \n    /**\n     * 给指定 hash 的 hashkey 做增减操作\n     *\n     * @param key\n     * @param hashKey\n     * @param number\n     * @return\n     */\n    public Double increment(String key, String hashKey, Double number) {\n        return redisTemplate.opsForHash().increment(key, hashKey, number);\n    }\n \n    /**\n     * 获取 key 下的 所有 hashkey 字段\n     *\n     * @param key\n     * @return\n     */\n    public Set<Object> hashKeys(String key) {\n        return redisTemplate.opsForHash().keys(key);\n    }\n \n    /**\n     * 获取指定 hash 下面的 键值对 数量\n     *\n     * @param key\n     * @return\n     */\n    public Long hashSize(String key) {\n        return redisTemplate.opsForHash().size(key);\n    }\n \n    //- - - - - - - - - - - - - - - - - - - - -  list类型 - - - - - - - - - - - - - - - - - - - -\n \n    /**\n     * 在变量左边添加元素值\n     *\n     * @param key\n     * @param value\n     * @return\n     */\n    public void leftPush(String key, Object value) {\n        redisTemplate.opsForList().leftPush(key, value);\n    }\n \n    /**\n     * 获取集合指定位置的值。\n     *\n     * @param key\n     * @param index\n     * @return\n     */\n    public Object index(String key, long index) {\n        return redisTemplate.opsForList().index(\"list\", 1);\n    }\n \n    /**\n     * 获取指定区间的值。\n     *\n     * @param key\n     * @param start\n     * @param end\n     * @return\n     */\n    public List<Object> range(String key, long start, long end) {\n        return redisTemplate.opsForList().range(key, start, end);\n    }\n \n    /**\n     * 把最后一个参数值放到指定集合的第一个出现中间参数的前面，\n     * 如果中间参数值存在的话。\n     *\n     * @param key\n     * @param pivot\n     * @param value\n     * @return\n     */\n    public void leftPush(String key, String pivot, String value) {\n        redisTemplate.opsForList().leftPush(key, pivot, value);\n    }\n \n    /**\n     * 向左边批量添加参数元素。\n     *\n     * @param key\n     * @param values\n     * @return\n     */\n    public void leftPushAll(String key, String... values) {\n//        redisTemplate.opsForList().leftPushAll(key,\"w\",\"x\",\"y\");\n        redisTemplate.opsForList().leftPushAll(key, values);\n    }\n \n    /**\n     * 向集合最右边添加元素。\n     *\n     * @param key\n     * @param value\n     * @return\n     */\n    public void leftPushAll(String key, String value) {\n        redisTemplate.opsForList().rightPush(key, value);\n    }\n \n    /**\n     * 向左边批量添加参数元素。\n     *\n     * @param key\n     * @param values\n     * @return\n     */\n    public void rightPushAll(String key, String... values) {\n        //redisTemplate.opsForList().leftPushAll(key,\"w\",\"x\",\"y\");\n        redisTemplate.opsForList().rightPushAll(key, values);\n    }\n \n    /**\n     * 向已存在的集合中添加元素。\n     *\n     * @param key\n     * @param value\n     * @return\n     */\n    public void rightPushIfPresent(String key, Object value) {\n        redisTemplate.opsForList().rightPushIfPresent(key, value);\n    }\n \n    /**\n     * 向已存在的集合中添加元素。\n     *\n     * @param key\n     * @return\n     */\n    public long listLength(String key) {\n        return redisTemplate.opsForList().size(key);\n    }\n \n    /**\n     * 移除集合中的左边第一个元素。\n     *\n     * @param key\n     * @return\n     */\n    public void leftPop(String key) {\n        redisTemplate.opsForList().leftPop(key);\n    }\n \n    /**\n     * 移除集合中左边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。\n     *\n     * @param key\n     * @return\n     */\n    public void leftPop(String key, long timeout, TimeUnit unit) {\n        redisTemplate.opsForList().leftPop(key, timeout, unit);\n    }\n \n    /**\n     * 移除集合中右边的元素。\n     *\n     * @param key\n     * @return\n     */\n    public void rightPop(String key) {\n        redisTemplate.opsForList().rightPop(key);\n    }\n \n    /**\n     * 移除集合中右边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。\n     *\n     * @param key\n     * @return\n     */\n    public void rightPop(String key, long timeout, TimeUnit unit) {\n        redisTemplate.opsForList().rightPop(key, timeout, unit);\n    }\n}\n\n```\n\n## 缓存穿透\n\n[穿透](https://img-blog.csdnimg.cn/37bd6dbb88c045ce84deb3fed774b59c.png)\n\n## 缓存雪崩\n\n[雪崩](https://img-blog.csdnimg.cn/9c38ab494d4b4d13930ea14d8f3f0db7.png)\n\n## 缓存击穿\n\n[击穿](https://img-blog.csdnimg.cn/3d01ccb55bde4a2d96aad731d98f4ef3.png)\n\n## 主从集群-复制\n\n## 哨兵\n","slug":"Redis使用方法","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxn000qiou2goq8bymc","content":"<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。  Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。\n\n<h1 id=\"redis\"><a href=\"#redis\" class=\"headerlink\" title=\"redis\"></a>redis</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt; \n&lt;&#x2F;dependency&gt;\n</code></pre>\n\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  redis:\n    # Redis服务器地址\n    host: 19.1.5.11\n    # Redis服务器端口号\n    port: 6379\n    # 使用的数据库索引，默认是0\n    database: 0\n    # 连接超时时间\n    timeout: 1800000\n     # 设置密码\n    password: &quot;123456&quot;\n    lettuce:\n      pool:\n        # 最大阻塞等待时间，负数表示没有限制\n        max-wait: -1\n        # 连接池中的最大空闲连接\n        max-idle: 5\n        # 连接池中的最小空闲连接\n        min-idle: 0\n        # 连接池中最大连接数，负数表示没有限制\n        max-active: 20\n</code></pre>\n\n<h2 id=\"序列化防止乱码\"><a href=\"#序列化防止乱码\" class=\"headerlink\" title=\"序列化防止乱码\"></a>序列化防止乱码</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Bean\npubtic RedisTemptate&lt;String, Object&gt; redisTemptate(RedisConnectionFactory redisConnectionFactory) &#123; \n   \n    RedisTemptate&lt;String, 0bject&gt; redisTemptate &#x3D; new RedisTempLate&lt;&gt;() ;\n    &#x2F;&#x2F;Redis连接工厂\n    redisTemptate.setConnectionFactory(redisConnectionFactory);\n    redisTemptate . setKeySeriaLizer(new StringRedisSeriaLizer());\n    &#x2F;&#x2F; 役 置 vatue 的 序列 化 策略 \n    redisTemptate.setVatueSeriatizer(new Jackson2JsonRedisSeriatizer&lt;&gt;(0bject.ctass));\n    return redisTemptate;\n&#125;</code></pre>\n\n<p>或</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class RedisConfig &#123;\n    @Bean\n    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)\n            throws UnknownHostException &#123;\n        &#x2F;&#x2F; 创建模板\n        RedisTemplate&lt;String, Object&gt; redisTemplate &#x3D; new RedisTemplate&lt;&gt;();\n        &#x2F;&#x2F; 设置连接工厂\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n        &#x2F;&#x2F; 设置序列化工具\n        GenericJackson2JsonRedisSerializer jsonRedisSerializer &#x3D;\n                new GenericJackson2JsonRedisSerializer();\n        &#x2F;&#x2F; key和 hashKey采用 string序列化\n        redisTemplate.setKeySerializer(RedisSerializer.string());\n        redisTemplate.setHashKeySerializer(RedisSerializer.string());\n        &#x2F;&#x2F; value和 hashValue采用 JSON序列化\n        redisTemplate.setValueSerializer(jsonRedisSerializer);\n        redisTemplate.setHashValueSerializer(jsonRedisSerializer);\n        return redisTemplate;\n    &#125;\n&#125;\n</code></pre>\n\n<h2 id=\"增删改查\"><a href=\"#增删改查\" class=\"headerlink\" title=\"增删改查\"></a>增删改查</h2><p><a href=\"https://img-blog.csdnimg.cn/20190412005015660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n,size_16,color_FFFFFF,t_70\">增删改查</a></p>\n<h4 id=\"String-字符串类型\"><a href=\"#String-字符串类型\" class=\"headerlink\" title=\"String-字符串类型\"></a>String-字符串类型</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.tensquare.article;\n\nimport com.tensquare.article.pojo.User;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport java.util.concurrent.TimeUnit;\n\n@SpringBootTest\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class RedisTemTest &#123;\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    &#x2F;*\n     * String类型的数据增删改查\n     * *&#x2F;\n    @Test\n    public void StringDataTest() &#123;\n        &#x2F;&#x2F; 创建User对象 ,要存入String类型的对象,需要实现 Serializable 接口\n        User user &#x3D; new User(&quot;1&quot;, &quot;Tom&quot;, &quot;打棒球&quot;, 15);\n\n        &#x2F;&#x2F; 添加数据\n        redisTemplate.opsForValue().set(&quot;user&quot;, user);\n\n        &#x2F;&#x2F; 添加数据并设置有效时间为30s, (30, TimeUnit.SECONDS) 分别代表数字,计量单位\n        redisTemplate.opsForValue().set(&quot;user1&quot;, &quot;Rose&quot;, 30, TimeUnit.SECONDS);\n\n        &#x2F;&#x2F;查找数据 根据key获取value\n        User value &#x3D; (User) redisTemplate.opsForValue().get(&quot;user&quot;);\n\n        &#x2F;&#x2F;查找数据 长度\n        Long size &#x3D; redisTemplate.opsForValue().size(&quot;user1&quot;);\n\n        &#x2F;&#x2F; 删除数据\n        redisTemplate.delete(&quot;user1&quot;);\n    &#125;\n&#125;\n</code></pre>\n\n<h4 id=\"Set-集合类型\"><a href=\"#Set-集合类型\" class=\"headerlink\" title=\"Set-集合类型\"></a>Set-集合类型</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n    * Set 集合类型CURD\n    * *&#x2F;\n   @Test\n   public void SetDataTest() &#123;\n       User user &#x3D; new User(&quot;1&quot;, &quot;Tom&quot;, &quot;打棒球&quot;, 15);\n       User user1 &#x3D; new User(&quot;2&quot;, &quot;Jack&quot;, &quot;打网球&quot;, 17);\n       User user2 &#x3D; new User(&quot;3&quot;, &quot;Rose&quot;, &quot;打篮球&quot;, 18);\n       User user3 &#x3D; new User(&quot;4&quot;, &quot;Jerry&quot;, &quot;踢足球&quot;, 19);\n\n       &#x2F;&#x2F; 添加 key为user_1的user对象\n       redisTemplate.opsForSet().add(&quot;user_1&quot;, user);\n       redisTemplate.opsForSet().add(&quot;user_1&quot;, user1);\n\n\t&#x2F;&#x2F; 定时 设置 user_1 数据的存活时间为5秒 测试时注释\n       redisTemplate.expire(&quot;user_1&quot;, 5, TimeUnit.SECONDS);\n\n       &#x2F;&#x2F; 查询 user_1 集合中的所有 value\n       Set user1_list &#x3D; redisTemplate.opsForSet().members(&quot;user_1&quot;);\n       &#x2F;&#x2F; 查询 user_1 集合中是否有 user 对象\n       Boolean result &#x3D; redisTemplate.opsForSet().isMember(&quot;user_1&quot;, user);\n\n       &#x2F;&#x2F; 删除 user_1 集合中的 user对象 ,并返回移除成功数量\n       Long success_count &#x3D; redisTemplate.opsForSet().remove(&quot;user_1&quot;, user);\n       &#x2F;&#x2F; 删除 user_1 集合中的栈顶元素\n       Object user_1 &#x3D; redisTemplate.opsForSet().pop(&quot;user_1&quot;);\n\n       &#x2F;&#x2F; 测试 交集 并集 差集的数据\n       redisTemplate.opsForSet().add(&quot;names1&quot;, user, user1, user2);\n       redisTemplate.opsForSet().add(&quot;names2&quot;, user, user1, user3);\n       &#x2F;&#x2F;取交集\n       Set&lt;User&gt; intersect &#x3D; redisTemplate.opsForSet().intersect(&quot;names1&quot;, &quot;names2&quot;);\n       for (User u1 : intersect) &#123;\n           System.out.println(&quot;交集: &quot; + u1);\n       &#125;\n       &#x2F;&#x2F;取并集\n       Set&lt;User&gt; union &#x3D; redisTemplate.opsForSet().union(&quot;names1&quot;, &quot;names2&quot;);\n       for (User u2 : union) &#123;\n           System.out.println(&quot;并集: &quot; + u2);\n       &#125;\n       &#x2F;&#x2F;取差集[第一个集合中存在，但第二个集合中不存在的元素]\n       Set&lt;User&gt; difference &#x3D; redisTemplate.opsForSet().difference(&quot;names1&quot;, &quot;names2&quot;);\n       for (User u3 : difference) &#123;\n           System.out.println(&quot;差集: &quot; + u3);\n       &#125;\n   &#125;\n</code></pre>\n\n<h4 id=\"List-链表类型\"><a href=\"#List-链表类型\" class=\"headerlink\" title=\"List-链表类型\"></a>List-链表类型</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n    * List 数据类型的CRUD\n    * *&#x2F;\n   @Test\n   public void ListDataTest() &#123;\n       User user &#x3D; new User(&quot;1&quot;, &quot;Tom&quot;, &quot;打棒球&quot;, 15);\n       User user1 &#x3D; new User(&quot;2&quot;, &quot;Jack&quot;, &quot;打网球&quot;, 17);\n\n       &#x2F;&#x2F;从左边添加一个元素\n       redisTemplate.opsForList().rightPush(&quot;user1&quot;, user);\n       &#x2F;&#x2F;从左边添加多个元素\n       redisTemplate.opsForList().leftPushAll(&quot;user2&quot;, user, user1);\n\n       &#x2F;&#x2F;从右边添加一个元素\n       redisTemplate.opsForList().rightPush(&quot;user3&quot;, user1);\n       &#x2F;&#x2F;从右边添加多个元素\n       redisTemplate.opsForList().rightPushAll(&quot;user4&quot;, user, user1);\n\n\t&#x2F;&#x2F; 定时 设置 user2 数据的存活时间为5秒 测试时注释\n       redisTemplate.expire(&quot;user2&quot;, 5, TimeUnit.SECONDS);\n\n       &#x2F;* 根据key和元素索引进行查询\n        *  0和正数代表从左边开始\n        *  负数代表从右边开始\n        * *&#x2F;\n       &#x2F;&#x2F; 查询 user3 链表中所有的元素\n       List user3 &#x3D; redisTemplate.opsForList().range(&quot;user3&quot;, 0, -1);\n       &#x2F;&#x2F; 查询 user3 链表中第一个元素\n       User data &#x3D; (User) redisTemplate.opsForList().index(&quot;user3&quot;, 0);\n       System.out.println(data);\n\n       &#x2F;&#x2F; 修改 user3 链表中第一个的元素为 user1 对象\n       redisTemplate.opsForList().set(&quot;user3&quot;, 0, user);\n \t  \n \t    &#x2F;&#x2F; 删除链表左侧第二个 user 对象\n       redisTemplate.opsForList().remove(&quot;user3&quot;, 2, user);\n       &#x2F;&#x2F;删除 user3 链表中左侧的第一个元素\n       redisTemplate.opsForList().leftPop(&quot;user3&quot;);\n       &#x2F;&#x2F;删除 user3 链表中右侧的第一个元素\n       redisTemplate.opsForList().rightPop(&quot;user3&quot;);\n   &#125;\n</code></pre>\n\n<h4 id=\"Hash-散列类型\"><a href=\"#Hash-散列类型\" class=\"headerlink\" title=\"Hash-散列类型\"></a>Hash-<a href=\"https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97&spm=1001.2101.3001.7020\">散列</a>类型</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">  &#x2F;*\n   * Hash集合CRUD\n   * *&#x2F;\n  @Test\n  public void HashDataTest() &#123;\n      User user &#x3D; new User(&quot;1&quot;, &quot;Tom&quot;, &quot;打棒球&quot;, 15);\n      User user1 &#x3D; new User(&quot;2&quot;, &quot;Jack&quot;, &quot;打网球&quot;, 17);\n\n      &#x2F;&#x2F; 添加 user 到 hash集合\n      redisTemplate.opsForHash().put(&quot;hash&quot;, &quot;1&quot;, user);\n      redisTemplate.opsForHash().put(&quot;hash&quot;, &quot;2&quot;, user1);\n\n&#x2F;&#x2F; 定时 设置 hash 的数据存活时间为5秒 测试时注释\n      redisTemplate.expire(&quot;hash&quot;, 5, TimeUnit.SECONDS);\n\n      &#x2F;&#x2F; 查询 hash中hashKey 为1的值\n      User hash &#x3D; (User) redisTemplate.opsForHash().get(&quot;hash&quot;, &quot;1&quot;);\n      &#x2F;&#x2F; 查询 hash中 所有hashKey 对应的的值\n      List&lt;User&gt; userList &#x3D; redisTemplate.opsForHash().values(&quot;hash&quot;);\n      &#x2F;&#x2F; 查询 hash中 所有hashKey 对应的键值对\n      Map&lt;String, User&gt; hashKeyMap &#x3D; redisTemplate.opsForHash().entries(&quot;hash&quot;);\n      &#x2F;&#x2F; 查询 hash中所有的hashKey\n      Set hashKeyList &#x3D; redisTemplate.opsForHash().keys(&quot;hash&quot;);\n      &#x2F;&#x2F; 查询 hash 中 是否有 hashKey 为1\n      Boolean result &#x3D; redisTemplate.opsForHash().hasKey(&quot;hash&quot;, &quot;1&quot;);\n\n      &#x2F;&#x2F; 删除hash 中 HashKey为的1 的值(如需要删除多个,只需要用 &quot;,&quot; 隔开\n      Long removeSize &#x3D; redisTemplate.opsForHash().delete(&quot;hash&quot;, &quot;1&quot;);\n  &#125;\n</code></pre>\n\n<h4 id=\"Zset-有序集合类型\"><a href=\"#Zset-有序集合类型\" class=\"headerlink\" title=\"[Zset]-有序集合类型\"></a>[Zset]-有序集合类型</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n     * zSet集合CRUD\n     * *&#x2F;\n    @Test\n    public void zSetDataTest() &#123;\n        &#x2F;&#x2F; 添加值\n        redisTemplate.opsForZSet().add(&quot;student&quot;, &quot;wangwu&quot;, 60);\n        redisTemplate.opsForZSet().add(&quot;student&quot;, &quot;lishi&quot;, 100);\n        redisTemplate.opsForZSet().add(&quot;student&quot;, &quot;zhangshan&quot;, 90);\n\n\t\t&#x2F;&#x2F; 定时 设置 student 的数据存活时间为5秒 测试时注释\n        redisTemplate.expire(&quot;student&quot;, 5, TimeUnit.SECONDS);\n\n        &#x2F;&#x2F; 增加分数\n        redisTemplate.opsForZSet().incrementScore(&quot;student&quot;, &quot;wangwu&quot;, 30);\n        &#x2F;&#x2F; 减少分数\n        redisTemplate.opsForZSet().incrementScore(&quot;student&quot;, &quot;wangwu&quot;, -50);\n\n        &#x2F;&#x2F;查询 student 下 wangwu 的分数\n        Double score &#x3D; redisTemplate.opsForZSet().score(&quot;student&quot;, &quot;wangwu&quot;);\n        &#x2F;&#x2F;查询 一个元素在集合中的排名  排名从0开始\n        Long rank &#x3D; redisTemplate.opsForZSet().rank(&quot;student&quot;, &quot;zhangshan&quot;);\n        &#x2F;&#x2F; 查询前三个元素\n        Set&lt;String&gt; students &#x3D; redisTemplate.opsForZSet().range(&quot;student&quot;, 0, 2);\n        &#x2F;&#x2F; 查询  前三个元素的键值对\n        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; student &#x3D; redisTemplate.opsForZSet().rangeWithScores(&quot;student&quot;, 0, 2);\n        &#x2F;&#x2F; 查询 根据值的区间查询 key\n        Set&lt;String&gt; students1 &#x3D; redisTemplate.opsForZSet().rangeByScore(&quot;student&quot;, 50, 100);\n        &#x2F;&#x2F; 查询 根据值区间查询 Set集合\n        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; student1 &#x3D; redisTemplate.opsForZSet().rangeByScoreWithScores(&quot;student&quot;, 50, 100);\n        &#x2F;&#x2F;查询 student 中有几个 key\n        Long result &#x3D; redisTemplate.opsForZSet().zCard(&quot;student&quot;);\n\n        &#x2F;&#x2F;根据key-value删除 value允许传入多个\n        redisTemplate.opsForZSet().remove(&quot;student&quot;,&quot;zhangsan&quot;,&quot;lisi&quot;);\n        &#x2F;&#x2F;根据排名区间删除\n        redisTemplate.opsForZSet().removeRange(&quot;student&quot;,0,1);\n        &#x2F;&#x2F;根据分数区间删除\n        redisTemplate.opsForZSet().removeRangeByScore(&quot;student&quot;,70,90);\n    &#125;\n</code></pre>\n\n<h3 id=\"增删改查工具类\"><a href=\"#增删改查工具类\" class=\"headerlink\" title=\"增删改查工具类\"></a>增删改查工具类</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lsqingfeng.springboot.utils; \nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\n \nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n \n&#x2F;**\n * @className: RedisUtil\n * @description:\n * @author: sh.Liu\n * @date: 2022-03-09 14:07\n *&#x2F;\n@Component\npublic class RedisUtil &#123;\n \n    @Autowired\n    private RedisTemplate redisTemplate;\n    &#x2F;**\n     * 给一个指定的 key 值附加过期时间\n     *\n     * @param key\n     * @param time\n     * @return\n     *&#x2F;\n    public boolean expire(String key, long time) &#123;\n        return redisTemplate.expire(key, time, TimeUnit.SECONDS);\n    &#125;\n    &#x2F;**\n     * 根据key 获取过期时间\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public long getTime(String key) &#123;\n        return redisTemplate.getExpire(key, TimeUnit.SECONDS);\n    &#125;\n    &#x2F;**\n     * 根据key 获取过期时间\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public boolean hasKey(String key) &#123;\n        return redisTemplate.hasKey(key);\n    &#125;\n    &#x2F;**\n     * 移除指定key 的过期时间\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public boolean persist(String key) &#123;\n        return redisTemplate.boundValueOps(key).persist();\n    &#125;\n \n    &#x2F;&#x2F;- - - - - - - - - - - - - - - - - - - - -  String类型 - - - - - - - - - - - - - - - - - - - -\n \n    &#x2F;**\n     * 根据key获取值\n     *\n     * @param key 键\n     * @return 值\n     *&#x2F;\n    public Object get(String key) &#123;\n        return key &#x3D;&#x3D; null ? null : redisTemplate.opsForValue().get(key);\n    &#125;\n \n    &#x2F;**\n     * 将值放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     * @return true成功 false 失败\n     *&#x2F;\n    public void set(String key, String value) &#123;\n        redisTemplate.opsForValue().set(key, value);\n    &#125;\n \n    &#x2F;**\n     * 将值放入缓存并设置时间\n     *\n     * @param key   键\n     * @param value 值\n     * @param time  时间(秒) -1为无期限\n     * @return true成功 false 失败\n     *&#x2F;\n    public void set(String key, String value, long time) &#123;\n        if (time &gt; 0) &#123;\n            redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\n        &#125; else &#123;\n            redisTemplate.opsForValue().set(key, value);\n        &#125;\n    &#125;\n \n    &#x2F;**\n     * 批量添加 key (重复的键会覆盖)\n     *\n     * @param keyAndValue\n     *&#x2F;\n    public void batchSet(Map&lt;String, String&gt; keyAndValue) &#123;\n        redisTemplate.opsForValue().multiSet(keyAndValue);\n    &#125;\n \n    &#x2F;**\n     * 批量添加 key-value 只有在键不存在时,才添加\n     * map 中只要有一个key存在,则全部不添加\n     *\n     * @param keyAndValue\n     *&#x2F;\n    public void batchSetIfAbsent(Map&lt;String, String&gt; keyAndValue) &#123;\n        redisTemplate.opsForValue().multiSetIfAbsent(keyAndValue);\n    &#125;\n \n    &#x2F;**\n     * 对一个 key-value 的值进行加减操作,\n     * 如果该 key 不存在 将创建一个key 并赋值该 number\n     * 如果 key 存在,但 value 不是长整型 ,将报错\n     *\n     * @param key\n     * @param number\n     *&#x2F;\n    public Long increment(String key, long number) &#123;\n        return redisTemplate.opsForValue().increment(key, number);\n    &#125;\n \n    &#x2F;**\n     * 对一个 key-value 的值进行加减操作,\n     * 如果该 key 不存在 将创建一个key 并赋值该 number\n     * 如果 key 存在,但 value 不是 纯数字 ,将报错\n     *\n     * @param key\n     * @param number\n     *&#x2F;\n    public Double increment(String key, double number) &#123;\n        return redisTemplate.opsForValue().increment(key, number);\n    &#125;\n \n    &#x2F;&#x2F;- - - - - - - - - - - - - - - - - - - - -  set类型 - - - - - - - - - - - - - - - - - - - -\n \n    &#x2F;**\n     * 将数据放入set缓存\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public void sSet(String key, String value) &#123;\n        redisTemplate.opsForSet().add(key, value);\n    &#125;\n \n    &#x2F;**\n     * 获取变量中的值\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public Set&lt;Object&gt; members(String key) &#123;\n        return redisTemplate.opsForSet().members(key);\n    &#125;\n \n    &#x2F;**\n     * 随机获取变量中指定个数的元素\n     *\n     * @param key   键\n     * @param count 值\n     * @return\n     *&#x2F;\n    public void randomMembers(String key, long count) &#123;\n        redisTemplate.opsForSet().randomMembers(key, count);\n    &#125;\n \n    &#x2F;**\n     * 随机获取变量中的元素\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public Object randomMember(String key) &#123;\n        return redisTemplate.opsForSet().randomMember(key);\n    &#125;\n \n    &#x2F;**\n     * 弹出变量中的元素\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public Object pop(String key) &#123;\n        return redisTemplate.opsForSet().pop(&quot;setValue&quot;);\n    &#125;\n \n    &#x2F;**\n     * 获取变量中值的长度\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public long size(String key) &#123;\n        return redisTemplate.opsForSet().size(key);\n    &#125;\n \n    &#x2F;**\n     * 根据value从一个set中查询,是否存在\n     *\n     * @param key   键\n     * @param value 值\n     * @return true 存在 false不存在\n     *&#x2F;\n    public boolean sHasKey(String key, Object value) &#123;\n        return redisTemplate.opsForSet().isMember(key, value);\n    &#125;\n \n    &#x2F;**\n     * 检查给定的元素是否在变量中。\n     *\n     * @param key 键\n     * @param obj 元素对象\n     * @return\n     *&#x2F;\n    public boolean isMember(String key, Object obj) &#123;\n        return redisTemplate.opsForSet().isMember(key, obj);\n    &#125;\n \n    &#x2F;**\n     * 转移变量的元素值到目的变量。\n     *\n     * @param key     键\n     * @param value   元素对象\n     * @param destKey 元素对象\n     * @return\n     *&#x2F;\n    public boolean move(String key, String value, String destKey) &#123;\n        return redisTemplate.opsForSet().move(key, value, destKey);\n    &#125;\n \n    &#x2F;**\n     * 批量移除set缓存中元素\n     *\n     * @param key    键\n     * @param values 值\n     * @return\n     *&#x2F;\n    public void remove(String key, Object... values) &#123;\n        redisTemplate.opsForSet().remove(key, values);\n    &#125;\n \n    &#x2F;**\n     * 通过给定的key求2个set变量的差值\n     *\n     * @param key     键\n     * @param destKey 键\n     * @return\n     *&#x2F;\n    public Set&lt;Set&gt; difference(String key, String destKey) &#123;\n        return redisTemplate.opsForSet().difference(key, destKey);\n    &#125;\n \n \n    &#x2F;&#x2F;- - - - - - - - - - - - - - - - - - - - -  hash类型 - - - - - - - - - - - - - - - - - - - -\n \n    &#x2F;**\n     * 加入缓存\n     *\n     * @param key 键\n     * @param map 键\n     * @return\n     *&#x2F;\n    public void add(String key, Map&lt;String, String&gt; map) &#123;\n        redisTemplate.opsForHash().putAll(key, map);\n    &#125;\n \n    &#x2F;**\n     * 获取 key 下的 所有  hashkey 和 value\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public Map&lt;Object, Object&gt; getHashEntries(String key) &#123;\n        return redisTemplate.opsForHash().entries(key);\n    &#125;\n \n    &#x2F;**\n     * 验证指定 key 下 有没有指定的 hashkey\n     *\n     * @param key\n     * @param hashKey\n     * @return\n     *&#x2F;\n    public boolean hashKey(String key, String hashKey) &#123;\n        return redisTemplate.opsForHash().hasKey(key, hashKey);\n    &#125;\n \n    &#x2F;**\n     * 获取指定key的值string\n     *\n     * @param key  键\n     * @param key2 键\n     * @return\n     *&#x2F;\n    public String getMapString(String key, String key2) &#123;\n        return redisTemplate.opsForHash().get(&quot;map1&quot;, &quot;key1&quot;).toString();\n    &#125;\n \n    &#x2F;**\n     * 获取指定的值Int\n     *\n     * @param key  键\n     * @param key2 键\n     * @return\n     *&#x2F;\n    public Integer getMapInt(String key, String key2) &#123;\n        return (Integer) redisTemplate.opsForHash().get(&quot;map1&quot;, &quot;key1&quot;);\n    &#125;\n \n    &#x2F;**\n     * 弹出元素并删除\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public String popValue(String key) &#123;\n        return redisTemplate.opsForSet().pop(key).toString();\n    &#125;\n \n    &#x2F;**\n     * 删除指定 hash 的 HashKey\n     *\n     * @param key\n     * @param hashKeys\n     * @return 删除成功的 数量\n     *&#x2F;\n    public Long delete(String key, String... hashKeys) &#123;\n        return redisTemplate.opsForHash().delete(key, hashKeys);\n    &#125;\n \n    &#x2F;**\n     * 给指定 hash 的 hashkey 做增减操作\n     *\n     * @param key\n     * @param hashKey\n     * @param number\n     * @return\n     *&#x2F;\n    public Long increment(String key, String hashKey, long number) &#123;\n        return redisTemplate.opsForHash().increment(key, hashKey, number);\n    &#125;\n \n    &#x2F;**\n     * 给指定 hash 的 hashkey 做增减操作\n     *\n     * @param key\n     * @param hashKey\n     * @param number\n     * @return\n     *&#x2F;\n    public Double increment(String key, String hashKey, Double number) &#123;\n        return redisTemplate.opsForHash().increment(key, hashKey, number);\n    &#125;\n \n    &#x2F;**\n     * 获取 key 下的 所有 hashkey 字段\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public Set&lt;Object&gt; hashKeys(String key) &#123;\n        return redisTemplate.opsForHash().keys(key);\n    &#125;\n \n    &#x2F;**\n     * 获取指定 hash 下面的 键值对 数量\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public Long hashSize(String key) &#123;\n        return redisTemplate.opsForHash().size(key);\n    &#125;\n \n    &#x2F;&#x2F;- - - - - - - - - - - - - - - - - - - - -  list类型 - - - - - - - - - - - - - - - - - - - -\n \n    &#x2F;**\n     * 在变量左边添加元素值\n     *\n     * @param key\n     * @param value\n     * @return\n     *&#x2F;\n    public void leftPush(String key, Object value) &#123;\n        redisTemplate.opsForList().leftPush(key, value);\n    &#125;\n \n    &#x2F;**\n     * 获取集合指定位置的值。\n     *\n     * @param key\n     * @param index\n     * @return\n     *&#x2F;\n    public Object index(String key, long index) &#123;\n        return redisTemplate.opsForList().index(&quot;list&quot;, 1);\n    &#125;\n \n    &#x2F;**\n     * 获取指定区间的值。\n     *\n     * @param key\n     * @param start\n     * @param end\n     * @return\n     *&#x2F;\n    public List&lt;Object&gt; range(String key, long start, long end) &#123;\n        return redisTemplate.opsForList().range(key, start, end);\n    &#125;\n \n    &#x2F;**\n     * 把最后一个参数值放到指定集合的第一个出现中间参数的前面，\n     * 如果中间参数值存在的话。\n     *\n     * @param key\n     * @param pivot\n     * @param value\n     * @return\n     *&#x2F;\n    public void leftPush(String key, String pivot, String value) &#123;\n        redisTemplate.opsForList().leftPush(key, pivot, value);\n    &#125;\n \n    &#x2F;**\n     * 向左边批量添加参数元素。\n     *\n     * @param key\n     * @param values\n     * @return\n     *&#x2F;\n    public void leftPushAll(String key, String... values) &#123;\n&#x2F;&#x2F;        redisTemplate.opsForList().leftPushAll(key,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;);\n        redisTemplate.opsForList().leftPushAll(key, values);\n    &#125;\n \n    &#x2F;**\n     * 向集合最右边添加元素。\n     *\n     * @param key\n     * @param value\n     * @return\n     *&#x2F;\n    public void leftPushAll(String key, String value) &#123;\n        redisTemplate.opsForList().rightPush(key, value);\n    &#125;\n \n    &#x2F;**\n     * 向左边批量添加参数元素。\n     *\n     * @param key\n     * @param values\n     * @return\n     *&#x2F;\n    public void rightPushAll(String key, String... values) &#123;\n        &#x2F;&#x2F;redisTemplate.opsForList().leftPushAll(key,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;);\n        redisTemplate.opsForList().rightPushAll(key, values);\n    &#125;\n \n    &#x2F;**\n     * 向已存在的集合中添加元素。\n     *\n     * @param key\n     * @param value\n     * @return\n     *&#x2F;\n    public void rightPushIfPresent(String key, Object value) &#123;\n        redisTemplate.opsForList().rightPushIfPresent(key, value);\n    &#125;\n \n    &#x2F;**\n     * 向已存在的集合中添加元素。\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public long listLength(String key) &#123;\n        return redisTemplate.opsForList().size(key);\n    &#125;\n \n    &#x2F;**\n     * 移除集合中的左边第一个元素。\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public void leftPop(String key) &#123;\n        redisTemplate.opsForList().leftPop(key);\n    &#125;\n \n    &#x2F;**\n     * 移除集合中左边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public void leftPop(String key, long timeout, TimeUnit unit) &#123;\n        redisTemplate.opsForList().leftPop(key, timeout, unit);\n    &#125;\n \n    &#x2F;**\n     * 移除集合中右边的元素。\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public void rightPop(String key) &#123;\n        redisTemplate.opsForList().rightPop(key);\n    &#125;\n \n    &#x2F;**\n     * 移除集合中右边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public void rightPop(String key, long timeout, TimeUnit unit) &#123;\n        redisTemplate.opsForList().rightPop(key, timeout, unit);\n    &#125;\n&#125;\n</code></pre>\n\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><p><a href=\"https://img-blog.csdnimg.cn/37bd6dbb88c045ce84deb3fed774b59c.png\">穿透</a></p>\n<h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h2><p><a href=\"https://img-blog.csdnimg.cn/9c38ab494d4b4d13930ea14d8f3f0db7.png\">雪崩</a></p>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><p><a href=\"https://img-blog.csdnimg.cn/3d01ccb55bde4a2d96aad731d98f4ef3.png\">击穿</a></p>\n<h2 id=\"主从集群-复制\"><a href=\"#主从集群-复制\" class=\"headerlink\" title=\"主从集群-复制\"></a>主从集群-复制</h2><h2 id=\"哨兵\"><a href=\"#哨兵\" class=\"headerlink\" title=\"哨兵\"></a>哨兵</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。  Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。\n\n<h1 id=\"redis\"><a href=\"#redis\" class=\"headerlink\" title=\"redis\"></a>redis</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt; \n&lt;&#x2F;dependency&gt;\n</code></pre>\n\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  redis:\n    # Redis服务器地址\n    host: 19.1.5.11\n    # Redis服务器端口号\n    port: 6379\n    # 使用的数据库索引，默认是0\n    database: 0\n    # 连接超时时间\n    timeout: 1800000\n     # 设置密码\n    password: &quot;123456&quot;\n    lettuce:\n      pool:\n        # 最大阻塞等待时间，负数表示没有限制\n        max-wait: -1\n        # 连接池中的最大空闲连接\n        max-idle: 5\n        # 连接池中的最小空闲连接\n        min-idle: 0\n        # 连接池中最大连接数，负数表示没有限制\n        max-active: 20\n</code></pre>\n\n<h2 id=\"序列化防止乱码\"><a href=\"#序列化防止乱码\" class=\"headerlink\" title=\"序列化防止乱码\"></a>序列化防止乱码</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Bean\npubtic RedisTemptate&lt;String, Object&gt; redisTemptate(RedisConnectionFactory redisConnectionFactory) &#123; \n   \n    RedisTemptate&lt;String, 0bject&gt; redisTemptate &#x3D; new RedisTempLate&lt;&gt;() ;\n    &#x2F;&#x2F;Redis连接工厂\n    redisTemptate.setConnectionFactory(redisConnectionFactory);\n    redisTemptate . setKeySeriaLizer(new StringRedisSeriaLizer());\n    &#x2F;&#x2F; 役 置 vatue 的 序列 化 策略 \n    redisTemptate.setVatueSeriatizer(new Jackson2JsonRedisSeriatizer&lt;&gt;(0bject.ctass));\n    return redisTemptate;\n&#125;</code></pre>\n\n<p>或</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class RedisConfig &#123;\n    @Bean\n    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)\n            throws UnknownHostException &#123;\n        &#x2F;&#x2F; 创建模板\n        RedisTemplate&lt;String, Object&gt; redisTemplate &#x3D; new RedisTemplate&lt;&gt;();\n        &#x2F;&#x2F; 设置连接工厂\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n        &#x2F;&#x2F; 设置序列化工具\n        GenericJackson2JsonRedisSerializer jsonRedisSerializer &#x3D;\n                new GenericJackson2JsonRedisSerializer();\n        &#x2F;&#x2F; key和 hashKey采用 string序列化\n        redisTemplate.setKeySerializer(RedisSerializer.string());\n        redisTemplate.setHashKeySerializer(RedisSerializer.string());\n        &#x2F;&#x2F; value和 hashValue采用 JSON序列化\n        redisTemplate.setValueSerializer(jsonRedisSerializer);\n        redisTemplate.setHashValueSerializer(jsonRedisSerializer);\n        return redisTemplate;\n    &#125;\n&#125;\n</code></pre>\n\n<h2 id=\"增删改查\"><a href=\"#增删改查\" class=\"headerlink\" title=\"增删改查\"></a>增删改查</h2><p><a href=\"https://img-blog.csdnimg.cn/20190412005015660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n,size_16,color_FFFFFF,t_70\">增删改查</a></p>\n<h4 id=\"String-字符串类型\"><a href=\"#String-字符串类型\" class=\"headerlink\" title=\"String-字符串类型\"></a>String-字符串类型</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.tensquare.article;\n\nimport com.tensquare.article.pojo.User;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport java.util.concurrent.TimeUnit;\n\n@SpringBootTest\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class RedisTemTest &#123;\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    &#x2F;*\n     * String类型的数据增删改查\n     * *&#x2F;\n    @Test\n    public void StringDataTest() &#123;\n        &#x2F;&#x2F; 创建User对象 ,要存入String类型的对象,需要实现 Serializable 接口\n        User user &#x3D; new User(&quot;1&quot;, &quot;Tom&quot;, &quot;打棒球&quot;, 15);\n\n        &#x2F;&#x2F; 添加数据\n        redisTemplate.opsForValue().set(&quot;user&quot;, user);\n\n        &#x2F;&#x2F; 添加数据并设置有效时间为30s, (30, TimeUnit.SECONDS) 分别代表数字,计量单位\n        redisTemplate.opsForValue().set(&quot;user1&quot;, &quot;Rose&quot;, 30, TimeUnit.SECONDS);\n\n        &#x2F;&#x2F;查找数据 根据key获取value\n        User value &#x3D; (User) redisTemplate.opsForValue().get(&quot;user&quot;);\n\n        &#x2F;&#x2F;查找数据 长度\n        Long size &#x3D; redisTemplate.opsForValue().size(&quot;user1&quot;);\n\n        &#x2F;&#x2F; 删除数据\n        redisTemplate.delete(&quot;user1&quot;);\n    &#125;\n&#125;\n</code></pre>\n\n<h4 id=\"Set-集合类型\"><a href=\"#Set-集合类型\" class=\"headerlink\" title=\"Set-集合类型\"></a>Set-集合类型</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n    * Set 集合类型CURD\n    * *&#x2F;\n   @Test\n   public void SetDataTest() &#123;\n       User user &#x3D; new User(&quot;1&quot;, &quot;Tom&quot;, &quot;打棒球&quot;, 15);\n       User user1 &#x3D; new User(&quot;2&quot;, &quot;Jack&quot;, &quot;打网球&quot;, 17);\n       User user2 &#x3D; new User(&quot;3&quot;, &quot;Rose&quot;, &quot;打篮球&quot;, 18);\n       User user3 &#x3D; new User(&quot;4&quot;, &quot;Jerry&quot;, &quot;踢足球&quot;, 19);\n\n       &#x2F;&#x2F; 添加 key为user_1的user对象\n       redisTemplate.opsForSet().add(&quot;user_1&quot;, user);\n       redisTemplate.opsForSet().add(&quot;user_1&quot;, user1);\n\n\t&#x2F;&#x2F; 定时 设置 user_1 数据的存活时间为5秒 测试时注释\n       redisTemplate.expire(&quot;user_1&quot;, 5, TimeUnit.SECONDS);\n\n       &#x2F;&#x2F; 查询 user_1 集合中的所有 value\n       Set user1_list &#x3D; redisTemplate.opsForSet().members(&quot;user_1&quot;);\n       &#x2F;&#x2F; 查询 user_1 集合中是否有 user 对象\n       Boolean result &#x3D; redisTemplate.opsForSet().isMember(&quot;user_1&quot;, user);\n\n       &#x2F;&#x2F; 删除 user_1 集合中的 user对象 ,并返回移除成功数量\n       Long success_count &#x3D; redisTemplate.opsForSet().remove(&quot;user_1&quot;, user);\n       &#x2F;&#x2F; 删除 user_1 集合中的栈顶元素\n       Object user_1 &#x3D; redisTemplate.opsForSet().pop(&quot;user_1&quot;);\n\n       &#x2F;&#x2F; 测试 交集 并集 差集的数据\n       redisTemplate.opsForSet().add(&quot;names1&quot;, user, user1, user2);\n       redisTemplate.opsForSet().add(&quot;names2&quot;, user, user1, user3);\n       &#x2F;&#x2F;取交集\n       Set&lt;User&gt; intersect &#x3D; redisTemplate.opsForSet().intersect(&quot;names1&quot;, &quot;names2&quot;);\n       for (User u1 : intersect) &#123;\n           System.out.println(&quot;交集: &quot; + u1);\n       &#125;\n       &#x2F;&#x2F;取并集\n       Set&lt;User&gt; union &#x3D; redisTemplate.opsForSet().union(&quot;names1&quot;, &quot;names2&quot;);\n       for (User u2 : union) &#123;\n           System.out.println(&quot;并集: &quot; + u2);\n       &#125;\n       &#x2F;&#x2F;取差集[第一个集合中存在，但第二个集合中不存在的元素]\n       Set&lt;User&gt; difference &#x3D; redisTemplate.opsForSet().difference(&quot;names1&quot;, &quot;names2&quot;);\n       for (User u3 : difference) &#123;\n           System.out.println(&quot;差集: &quot; + u3);\n       &#125;\n   &#125;\n</code></pre>\n\n<h4 id=\"List-链表类型\"><a href=\"#List-链表类型\" class=\"headerlink\" title=\"List-链表类型\"></a>List-链表类型</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n    * List 数据类型的CRUD\n    * *&#x2F;\n   @Test\n   public void ListDataTest() &#123;\n       User user &#x3D; new User(&quot;1&quot;, &quot;Tom&quot;, &quot;打棒球&quot;, 15);\n       User user1 &#x3D; new User(&quot;2&quot;, &quot;Jack&quot;, &quot;打网球&quot;, 17);\n\n       &#x2F;&#x2F;从左边添加一个元素\n       redisTemplate.opsForList().rightPush(&quot;user1&quot;, user);\n       &#x2F;&#x2F;从左边添加多个元素\n       redisTemplate.opsForList().leftPushAll(&quot;user2&quot;, user, user1);\n\n       &#x2F;&#x2F;从右边添加一个元素\n       redisTemplate.opsForList().rightPush(&quot;user3&quot;, user1);\n       &#x2F;&#x2F;从右边添加多个元素\n       redisTemplate.opsForList().rightPushAll(&quot;user4&quot;, user, user1);\n\n\t&#x2F;&#x2F; 定时 设置 user2 数据的存活时间为5秒 测试时注释\n       redisTemplate.expire(&quot;user2&quot;, 5, TimeUnit.SECONDS);\n\n       &#x2F;* 根据key和元素索引进行查询\n        *  0和正数代表从左边开始\n        *  负数代表从右边开始\n        * *&#x2F;\n       &#x2F;&#x2F; 查询 user3 链表中所有的元素\n       List user3 &#x3D; redisTemplate.opsForList().range(&quot;user3&quot;, 0, -1);\n       &#x2F;&#x2F; 查询 user3 链表中第一个元素\n       User data &#x3D; (User) redisTemplate.opsForList().index(&quot;user3&quot;, 0);\n       System.out.println(data);\n\n       &#x2F;&#x2F; 修改 user3 链表中第一个的元素为 user1 对象\n       redisTemplate.opsForList().set(&quot;user3&quot;, 0, user);\n \t  \n \t    &#x2F;&#x2F; 删除链表左侧第二个 user 对象\n       redisTemplate.opsForList().remove(&quot;user3&quot;, 2, user);\n       &#x2F;&#x2F;删除 user3 链表中左侧的第一个元素\n       redisTemplate.opsForList().leftPop(&quot;user3&quot;);\n       &#x2F;&#x2F;删除 user3 链表中右侧的第一个元素\n       redisTemplate.opsForList().rightPop(&quot;user3&quot;);\n   &#125;\n</code></pre>\n\n<h4 id=\"Hash-散列类型\"><a href=\"#Hash-散列类型\" class=\"headerlink\" title=\"Hash-散列类型\"></a>Hash-<a href=\"https://so.csdn.net/so/search?q=%E6%95%A3%E5%88%97&spm=1001.2101.3001.7020\">散列</a>类型</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">  &#x2F;*\n   * Hash集合CRUD\n   * *&#x2F;\n  @Test\n  public void HashDataTest() &#123;\n      User user &#x3D; new User(&quot;1&quot;, &quot;Tom&quot;, &quot;打棒球&quot;, 15);\n      User user1 &#x3D; new User(&quot;2&quot;, &quot;Jack&quot;, &quot;打网球&quot;, 17);\n\n      &#x2F;&#x2F; 添加 user 到 hash集合\n      redisTemplate.opsForHash().put(&quot;hash&quot;, &quot;1&quot;, user);\n      redisTemplate.opsForHash().put(&quot;hash&quot;, &quot;2&quot;, user1);\n\n&#x2F;&#x2F; 定时 设置 hash 的数据存活时间为5秒 测试时注释\n      redisTemplate.expire(&quot;hash&quot;, 5, TimeUnit.SECONDS);\n\n      &#x2F;&#x2F; 查询 hash中hashKey 为1的值\n      User hash &#x3D; (User) redisTemplate.opsForHash().get(&quot;hash&quot;, &quot;1&quot;);\n      &#x2F;&#x2F; 查询 hash中 所有hashKey 对应的的值\n      List&lt;User&gt; userList &#x3D; redisTemplate.opsForHash().values(&quot;hash&quot;);\n      &#x2F;&#x2F; 查询 hash中 所有hashKey 对应的键值对\n      Map&lt;String, User&gt; hashKeyMap &#x3D; redisTemplate.opsForHash().entries(&quot;hash&quot;);\n      &#x2F;&#x2F; 查询 hash中所有的hashKey\n      Set hashKeyList &#x3D; redisTemplate.opsForHash().keys(&quot;hash&quot;);\n      &#x2F;&#x2F; 查询 hash 中 是否有 hashKey 为1\n      Boolean result &#x3D; redisTemplate.opsForHash().hasKey(&quot;hash&quot;, &quot;1&quot;);\n\n      &#x2F;&#x2F; 删除hash 中 HashKey为的1 的值(如需要删除多个,只需要用 &quot;,&quot; 隔开\n      Long removeSize &#x3D; redisTemplate.opsForHash().delete(&quot;hash&quot;, &quot;1&quot;);\n  &#125;\n</code></pre>\n\n<h4 id=\"Zset-有序集合类型\"><a href=\"#Zset-有序集合类型\" class=\"headerlink\" title=\"[Zset]-有序集合类型\"></a>[Zset]-有序集合类型</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n     * zSet集合CRUD\n     * *&#x2F;\n    @Test\n    public void zSetDataTest() &#123;\n        &#x2F;&#x2F; 添加值\n        redisTemplate.opsForZSet().add(&quot;student&quot;, &quot;wangwu&quot;, 60);\n        redisTemplate.opsForZSet().add(&quot;student&quot;, &quot;lishi&quot;, 100);\n        redisTemplate.opsForZSet().add(&quot;student&quot;, &quot;zhangshan&quot;, 90);\n\n\t\t&#x2F;&#x2F; 定时 设置 student 的数据存活时间为5秒 测试时注释\n        redisTemplate.expire(&quot;student&quot;, 5, TimeUnit.SECONDS);\n\n        &#x2F;&#x2F; 增加分数\n        redisTemplate.opsForZSet().incrementScore(&quot;student&quot;, &quot;wangwu&quot;, 30);\n        &#x2F;&#x2F; 减少分数\n        redisTemplate.opsForZSet().incrementScore(&quot;student&quot;, &quot;wangwu&quot;, -50);\n\n        &#x2F;&#x2F;查询 student 下 wangwu 的分数\n        Double score &#x3D; redisTemplate.opsForZSet().score(&quot;student&quot;, &quot;wangwu&quot;);\n        &#x2F;&#x2F;查询 一个元素在集合中的排名  排名从0开始\n        Long rank &#x3D; redisTemplate.opsForZSet().rank(&quot;student&quot;, &quot;zhangshan&quot;);\n        &#x2F;&#x2F; 查询前三个元素\n        Set&lt;String&gt; students &#x3D; redisTemplate.opsForZSet().range(&quot;student&quot;, 0, 2);\n        &#x2F;&#x2F; 查询  前三个元素的键值对\n        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; student &#x3D; redisTemplate.opsForZSet().rangeWithScores(&quot;student&quot;, 0, 2);\n        &#x2F;&#x2F; 查询 根据值的区间查询 key\n        Set&lt;String&gt; students1 &#x3D; redisTemplate.opsForZSet().rangeByScore(&quot;student&quot;, 50, 100);\n        &#x2F;&#x2F; 查询 根据值区间查询 Set集合\n        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; student1 &#x3D; redisTemplate.opsForZSet().rangeByScoreWithScores(&quot;student&quot;, 50, 100);\n        &#x2F;&#x2F;查询 student 中有几个 key\n        Long result &#x3D; redisTemplate.opsForZSet().zCard(&quot;student&quot;);\n\n        &#x2F;&#x2F;根据key-value删除 value允许传入多个\n        redisTemplate.opsForZSet().remove(&quot;student&quot;,&quot;zhangsan&quot;,&quot;lisi&quot;);\n        &#x2F;&#x2F;根据排名区间删除\n        redisTemplate.opsForZSet().removeRange(&quot;student&quot;,0,1);\n        &#x2F;&#x2F;根据分数区间删除\n        redisTemplate.opsForZSet().removeRangeByScore(&quot;student&quot;,70,90);\n    &#125;\n</code></pre>\n\n<h3 id=\"增删改查工具类\"><a href=\"#增删改查工具类\" class=\"headerlink\" title=\"增删改查工具类\"></a>增删改查工具类</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lsqingfeng.springboot.utils; \nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\n \nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n \n&#x2F;**\n * @className: RedisUtil\n * @description:\n * @author: sh.Liu\n * @date: 2022-03-09 14:07\n *&#x2F;\n@Component\npublic class RedisUtil &#123;\n \n    @Autowired\n    private RedisTemplate redisTemplate;\n    &#x2F;**\n     * 给一个指定的 key 值附加过期时间\n     *\n     * @param key\n     * @param time\n     * @return\n     *&#x2F;\n    public boolean expire(String key, long time) &#123;\n        return redisTemplate.expire(key, time, TimeUnit.SECONDS);\n    &#125;\n    &#x2F;**\n     * 根据key 获取过期时间\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public long getTime(String key) &#123;\n        return redisTemplate.getExpire(key, TimeUnit.SECONDS);\n    &#125;\n    &#x2F;**\n     * 根据key 获取过期时间\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public boolean hasKey(String key) &#123;\n        return redisTemplate.hasKey(key);\n    &#125;\n    &#x2F;**\n     * 移除指定key 的过期时间\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public boolean persist(String key) &#123;\n        return redisTemplate.boundValueOps(key).persist();\n    &#125;\n \n    &#x2F;&#x2F;- - - - - - - - - - - - - - - - - - - - -  String类型 - - - - - - - - - - - - - - - - - - - -\n \n    &#x2F;**\n     * 根据key获取值\n     *\n     * @param key 键\n     * @return 值\n     *&#x2F;\n    public Object get(String key) &#123;\n        return key &#x3D;&#x3D; null ? null : redisTemplate.opsForValue().get(key);\n    &#125;\n \n    &#x2F;**\n     * 将值放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     * @return true成功 false 失败\n     *&#x2F;\n    public void set(String key, String value) &#123;\n        redisTemplate.opsForValue().set(key, value);\n    &#125;\n \n    &#x2F;**\n     * 将值放入缓存并设置时间\n     *\n     * @param key   键\n     * @param value 值\n     * @param time  时间(秒) -1为无期限\n     * @return true成功 false 失败\n     *&#x2F;\n    public void set(String key, String value, long time) &#123;\n        if (time &gt; 0) &#123;\n            redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\n        &#125; else &#123;\n            redisTemplate.opsForValue().set(key, value);\n        &#125;\n    &#125;\n \n    &#x2F;**\n     * 批量添加 key (重复的键会覆盖)\n     *\n     * @param keyAndValue\n     *&#x2F;\n    public void batchSet(Map&lt;String, String&gt; keyAndValue) &#123;\n        redisTemplate.opsForValue().multiSet(keyAndValue);\n    &#125;\n \n    &#x2F;**\n     * 批量添加 key-value 只有在键不存在时,才添加\n     * map 中只要有一个key存在,则全部不添加\n     *\n     * @param keyAndValue\n     *&#x2F;\n    public void batchSetIfAbsent(Map&lt;String, String&gt; keyAndValue) &#123;\n        redisTemplate.opsForValue().multiSetIfAbsent(keyAndValue);\n    &#125;\n \n    &#x2F;**\n     * 对一个 key-value 的值进行加减操作,\n     * 如果该 key 不存在 将创建一个key 并赋值该 number\n     * 如果 key 存在,但 value 不是长整型 ,将报错\n     *\n     * @param key\n     * @param number\n     *&#x2F;\n    public Long increment(String key, long number) &#123;\n        return redisTemplate.opsForValue().increment(key, number);\n    &#125;\n \n    &#x2F;**\n     * 对一个 key-value 的值进行加减操作,\n     * 如果该 key 不存在 将创建一个key 并赋值该 number\n     * 如果 key 存在,但 value 不是 纯数字 ,将报错\n     *\n     * @param key\n     * @param number\n     *&#x2F;\n    public Double increment(String key, double number) &#123;\n        return redisTemplate.opsForValue().increment(key, number);\n    &#125;\n \n    &#x2F;&#x2F;- - - - - - - - - - - - - - - - - - - - -  set类型 - - - - - - - - - - - - - - - - - - - -\n \n    &#x2F;**\n     * 将数据放入set缓存\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public void sSet(String key, String value) &#123;\n        redisTemplate.opsForSet().add(key, value);\n    &#125;\n \n    &#x2F;**\n     * 获取变量中的值\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public Set&lt;Object&gt; members(String key) &#123;\n        return redisTemplate.opsForSet().members(key);\n    &#125;\n \n    &#x2F;**\n     * 随机获取变量中指定个数的元素\n     *\n     * @param key   键\n     * @param count 值\n     * @return\n     *&#x2F;\n    public void randomMembers(String key, long count) &#123;\n        redisTemplate.opsForSet().randomMembers(key, count);\n    &#125;\n \n    &#x2F;**\n     * 随机获取变量中的元素\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public Object randomMember(String key) &#123;\n        return redisTemplate.opsForSet().randomMember(key);\n    &#125;\n \n    &#x2F;**\n     * 弹出变量中的元素\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public Object pop(String key) &#123;\n        return redisTemplate.opsForSet().pop(&quot;setValue&quot;);\n    &#125;\n \n    &#x2F;**\n     * 获取变量中值的长度\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public long size(String key) &#123;\n        return redisTemplate.opsForSet().size(key);\n    &#125;\n \n    &#x2F;**\n     * 根据value从一个set中查询,是否存在\n     *\n     * @param key   键\n     * @param value 值\n     * @return true 存在 false不存在\n     *&#x2F;\n    public boolean sHasKey(String key, Object value) &#123;\n        return redisTemplate.opsForSet().isMember(key, value);\n    &#125;\n \n    &#x2F;**\n     * 检查给定的元素是否在变量中。\n     *\n     * @param key 键\n     * @param obj 元素对象\n     * @return\n     *&#x2F;\n    public boolean isMember(String key, Object obj) &#123;\n        return redisTemplate.opsForSet().isMember(key, obj);\n    &#125;\n \n    &#x2F;**\n     * 转移变量的元素值到目的变量。\n     *\n     * @param key     键\n     * @param value   元素对象\n     * @param destKey 元素对象\n     * @return\n     *&#x2F;\n    public boolean move(String key, String value, String destKey) &#123;\n        return redisTemplate.opsForSet().move(key, value, destKey);\n    &#125;\n \n    &#x2F;**\n     * 批量移除set缓存中元素\n     *\n     * @param key    键\n     * @param values 值\n     * @return\n     *&#x2F;\n    public void remove(String key, Object... values) &#123;\n        redisTemplate.opsForSet().remove(key, values);\n    &#125;\n \n    &#x2F;**\n     * 通过给定的key求2个set变量的差值\n     *\n     * @param key     键\n     * @param destKey 键\n     * @return\n     *&#x2F;\n    public Set&lt;Set&gt; difference(String key, String destKey) &#123;\n        return redisTemplate.opsForSet().difference(key, destKey);\n    &#125;\n \n \n    &#x2F;&#x2F;- - - - - - - - - - - - - - - - - - - - -  hash类型 - - - - - - - - - - - - - - - - - - - -\n \n    &#x2F;**\n     * 加入缓存\n     *\n     * @param key 键\n     * @param map 键\n     * @return\n     *&#x2F;\n    public void add(String key, Map&lt;String, String&gt; map) &#123;\n        redisTemplate.opsForHash().putAll(key, map);\n    &#125;\n \n    &#x2F;**\n     * 获取 key 下的 所有  hashkey 和 value\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public Map&lt;Object, Object&gt; getHashEntries(String key) &#123;\n        return redisTemplate.opsForHash().entries(key);\n    &#125;\n \n    &#x2F;**\n     * 验证指定 key 下 有没有指定的 hashkey\n     *\n     * @param key\n     * @param hashKey\n     * @return\n     *&#x2F;\n    public boolean hashKey(String key, String hashKey) &#123;\n        return redisTemplate.opsForHash().hasKey(key, hashKey);\n    &#125;\n \n    &#x2F;**\n     * 获取指定key的值string\n     *\n     * @param key  键\n     * @param key2 键\n     * @return\n     *&#x2F;\n    public String getMapString(String key, String key2) &#123;\n        return redisTemplate.opsForHash().get(&quot;map1&quot;, &quot;key1&quot;).toString();\n    &#125;\n \n    &#x2F;**\n     * 获取指定的值Int\n     *\n     * @param key  键\n     * @param key2 键\n     * @return\n     *&#x2F;\n    public Integer getMapInt(String key, String key2) &#123;\n        return (Integer) redisTemplate.opsForHash().get(&quot;map1&quot;, &quot;key1&quot;);\n    &#125;\n \n    &#x2F;**\n     * 弹出元素并删除\n     *\n     * @param key 键\n     * @return\n     *&#x2F;\n    public String popValue(String key) &#123;\n        return redisTemplate.opsForSet().pop(key).toString();\n    &#125;\n \n    &#x2F;**\n     * 删除指定 hash 的 HashKey\n     *\n     * @param key\n     * @param hashKeys\n     * @return 删除成功的 数量\n     *&#x2F;\n    public Long delete(String key, String... hashKeys) &#123;\n        return redisTemplate.opsForHash().delete(key, hashKeys);\n    &#125;\n \n    &#x2F;**\n     * 给指定 hash 的 hashkey 做增减操作\n     *\n     * @param key\n     * @param hashKey\n     * @param number\n     * @return\n     *&#x2F;\n    public Long increment(String key, String hashKey, long number) &#123;\n        return redisTemplate.opsForHash().increment(key, hashKey, number);\n    &#125;\n \n    &#x2F;**\n     * 给指定 hash 的 hashkey 做增减操作\n     *\n     * @param key\n     * @param hashKey\n     * @param number\n     * @return\n     *&#x2F;\n    public Double increment(String key, String hashKey, Double number) &#123;\n        return redisTemplate.opsForHash().increment(key, hashKey, number);\n    &#125;\n \n    &#x2F;**\n     * 获取 key 下的 所有 hashkey 字段\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public Set&lt;Object&gt; hashKeys(String key) &#123;\n        return redisTemplate.opsForHash().keys(key);\n    &#125;\n \n    &#x2F;**\n     * 获取指定 hash 下面的 键值对 数量\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public Long hashSize(String key) &#123;\n        return redisTemplate.opsForHash().size(key);\n    &#125;\n \n    &#x2F;&#x2F;- - - - - - - - - - - - - - - - - - - - -  list类型 - - - - - - - - - - - - - - - - - - - -\n \n    &#x2F;**\n     * 在变量左边添加元素值\n     *\n     * @param key\n     * @param value\n     * @return\n     *&#x2F;\n    public void leftPush(String key, Object value) &#123;\n        redisTemplate.opsForList().leftPush(key, value);\n    &#125;\n \n    &#x2F;**\n     * 获取集合指定位置的值。\n     *\n     * @param key\n     * @param index\n     * @return\n     *&#x2F;\n    public Object index(String key, long index) &#123;\n        return redisTemplate.opsForList().index(&quot;list&quot;, 1);\n    &#125;\n \n    &#x2F;**\n     * 获取指定区间的值。\n     *\n     * @param key\n     * @param start\n     * @param end\n     * @return\n     *&#x2F;\n    public List&lt;Object&gt; range(String key, long start, long end) &#123;\n        return redisTemplate.opsForList().range(key, start, end);\n    &#125;\n \n    &#x2F;**\n     * 把最后一个参数值放到指定集合的第一个出现中间参数的前面，\n     * 如果中间参数值存在的话。\n     *\n     * @param key\n     * @param pivot\n     * @param value\n     * @return\n     *&#x2F;\n    public void leftPush(String key, String pivot, String value) &#123;\n        redisTemplate.opsForList().leftPush(key, pivot, value);\n    &#125;\n \n    &#x2F;**\n     * 向左边批量添加参数元素。\n     *\n     * @param key\n     * @param values\n     * @return\n     *&#x2F;\n    public void leftPushAll(String key, String... values) &#123;\n&#x2F;&#x2F;        redisTemplate.opsForList().leftPushAll(key,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;);\n        redisTemplate.opsForList().leftPushAll(key, values);\n    &#125;\n \n    &#x2F;**\n     * 向集合最右边添加元素。\n     *\n     * @param key\n     * @param value\n     * @return\n     *&#x2F;\n    public void leftPushAll(String key, String value) &#123;\n        redisTemplate.opsForList().rightPush(key, value);\n    &#125;\n \n    &#x2F;**\n     * 向左边批量添加参数元素。\n     *\n     * @param key\n     * @param values\n     * @return\n     *&#x2F;\n    public void rightPushAll(String key, String... values) &#123;\n        &#x2F;&#x2F;redisTemplate.opsForList().leftPushAll(key,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;);\n        redisTemplate.opsForList().rightPushAll(key, values);\n    &#125;\n \n    &#x2F;**\n     * 向已存在的集合中添加元素。\n     *\n     * @param key\n     * @param value\n     * @return\n     *&#x2F;\n    public void rightPushIfPresent(String key, Object value) &#123;\n        redisTemplate.opsForList().rightPushIfPresent(key, value);\n    &#125;\n \n    &#x2F;**\n     * 向已存在的集合中添加元素。\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public long listLength(String key) &#123;\n        return redisTemplate.opsForList().size(key);\n    &#125;\n \n    &#x2F;**\n     * 移除集合中的左边第一个元素。\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public void leftPop(String key) &#123;\n        redisTemplate.opsForList().leftPop(key);\n    &#125;\n \n    &#x2F;**\n     * 移除集合中左边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public void leftPop(String key, long timeout, TimeUnit unit) &#123;\n        redisTemplate.opsForList().leftPop(key, timeout, unit);\n    &#125;\n \n    &#x2F;**\n     * 移除集合中右边的元素。\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public void rightPop(String key) &#123;\n        redisTemplate.opsForList().rightPop(key);\n    &#125;\n \n    &#x2F;**\n     * 移除集合中右边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。\n     *\n     * @param key\n     * @return\n     *&#x2F;\n    public void rightPop(String key, long timeout, TimeUnit unit) &#123;\n        redisTemplate.opsForList().rightPop(key, timeout, unit);\n    &#125;\n&#125;\n</code></pre>\n\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><p><a href=\"https://img-blog.csdnimg.cn/37bd6dbb88c045ce84deb3fed774b59c.png\">穿透</a></p>\n<h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h2><p><a href=\"https://img-blog.csdnimg.cn/9c38ab494d4b4d13930ea14d8f3f0db7.png\">雪崩</a></p>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><p><a href=\"https://img-blog.csdnimg.cn/3d01ccb55bde4a2d96aad731d98f4ef3.png\">击穿</a></p>\n<h2 id=\"主从集群-复制\"><a href=\"#主从集群-复制\" class=\"headerlink\" title=\"主从集群-复制\"></a>主从集群-复制</h2><h2 id=\"哨兵\"><a href=\"#哨兵\" class=\"headerlink\" title=\"哨兵\"></a>哨兵</h2>"},{"title":"React 使用详解","date":"2024-03-18T14:14:03.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/react.svg","author":{"name":"TriDiamond","link":"https://tridiamond.tech","avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/illust_77229305_20210626_204628.png","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/tridiamond"}},"_content":"# React 使用详解","source":"_posts/React.md","raw":"---\ntitle: React 使用详解\ndate: 2024-03-18 22:14:03\ntags: React\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/react.svg\nauthor:\n  name: TriDiamond # 作者名字\n  link: https://tridiamond.tech #链接\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/illust_77229305_20210626_204628.png #作者头像\n  description: 'Think like an artist, code like an artisan.' #简介\n  socials:\n    github: https://github.com/tridiamond #联系方式\n---\n# React 使用详解","slug":"React","published":1,"updated":"2024-03-20T15:27:26.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxo000tiou28hyaaxqr","content":"<h1 id=\"React-使用详解\"><a href=\"#React-使用详解\" class=\"headerlink\" title=\"React 使用详解\"></a>React 使用详解</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"React-使用详解\"><a href=\"#React-使用详解\" class=\"headerlink\" title=\"React 使用详解\"></a>React 使用详解</h1>"},{"title":"blender笔记","date":"2024-03-22T11:38:41.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/o.jpg","_content":"# blender笔记","source":"_posts/blender笔记.md","raw":"---\ntitle: blender笔记\ndate: 2024-03-22 19:38:41\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/o.jpg\ntags:\n - Blender\n - 3D建模\ncategories: \n - Blender建模\n---\n# blender笔记","slug":"blender笔记","published":1,"updated":"2024-03-22T11:51:33.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxp000viou26dpicvp2","content":"<h1 id=\"blender笔记\"><a href=\"#blender笔记\" class=\"headerlink\" title=\"blender笔记\"></a>blender笔记</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"blender笔记\"><a href=\"#blender笔记\" class=\"headerlink\" title=\"blender笔记\"></a>blender笔记</h1>"},{"title":"hexo 文档详解","cover":"/svg/60b9ed3cae5a9ba4024b411c.png","description":"本文详细介绍了hexo文档中的各种功能和用法，帮助用户更好地使用hexo。","author":{"name":"Zmc 作者名字","link":"https://hexo-git-test-3309446352s-projects.vercel.app/","avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg","description":"古来圣贤皆寂寞，惟有饮者留其名。","socials":{"github":"https://github.com/3309446352"}},"date":"2024-03-22T12:19:44.000Z","_content":"\n# 1. 安装hexo\n https://hexo.io/zh-cn/docs/front-matter\n```bash\nnpm install -g hexo-cli\n```\n\n","source":"_posts/hexo-文档详解.md","raw":"---\ntitle: hexo 文档详解\ncover: /svg/60b9ed3cae5a9ba4024b411c.png\ndescription: 本文详细介绍了hexo文档中的各种功能和用法，帮助用户更好地使用hexo。\nauthor:\n  name: Zmc 作者名字\n  link: https://hexo-git-test-3309446352s-projects.vercel.app/\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\n  description: 古来圣贤皆寂寞，惟有饮者留其名。\n  socials:\n    github: https://github.com/3309446352\ndate: 2024-03-22 20:19:44\ntags:\n  - 博客搭建\ncategories:\n---\n\n# 1. 安装hexo\n https://hexo.io/zh-cn/docs/front-matter\n```bash\nnpm install -g hexo-cli\n```\n\n","slug":"hexo-文档详解","published":1,"updated":"2024-03-23T14:27:10.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxr000ziou2at2309ia","content":"<h1 id=\"1-安装hexo\"><a href=\"#1-安装hexo\" class=\"headerlink\" title=\"1. 安装hexo\"></a>1. 安装hexo</h1><p> <a href=\"https://hexo.io/zh-cn/docs/front-matter\">https://hexo.io/zh-cn/docs/front-matter</a></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install -g hexo-cli</code></pre>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-安装hexo\"><a href=\"#1-安装hexo\" class=\"headerlink\" title=\"1. 安装hexo\"></a>1. 安装hexo</h1><p> <a href=\"https://hexo.io/zh-cn/docs/front-matter\">https://hexo.io/zh-cn/docs/front-matter</a></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install -g hexo-cli</code></pre>\n\n"},{"title":"jsoup","date":"2024-03-18T16:12:01.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-03-27_21-51-18.png?token=ASFPQID2C66R7XCXGYTGM4LF7JJ2U","_content":"### 一、jsoup概述\n\njsoup 是一款基于 Java 的HTML解析器，它提供了一套非常省力的API，不但能直接解析某个URL地址、HTML文本内容，而且还能通过类似于DOM、CSS或者jQuery的方法来操作数据，所以 jsoup 也可以被当做爬虫工具使用。\n\n### 二、相关概念简介\n\nDocument ：文档对象。每份HTML页面都是一个文档对象，Document 是 jsoup 体系中最顶层的结构。\nElement：元素对象。一个 Document 中可以着包含着多个 Element 对象，可以使用 Element 对象来遍历节点提取数据或者直接操作HTML。\nElements：元素对象集合，类似于List<Element>。\nNode：节点对象。标签名称、属性等都是节点对象，节点对象用来存储数据。\n类继承关系：Document 继承自 Element ，Element 继承自 Node。\n一般执行流程：先获取 Document 对象，然后获取 Element 对象，最后再通过 Node 对象获取数据。\n","source":"_posts/jsoup.md","raw":"---\ntitle: jsoup\ndate: 2024-03-19 00:12:01\ntags: \n  -爬虫\ncategories:\n  - 爬虫\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-03-27_21-51-18.png?token=ASFPQID2C66R7XCXGYTGM4LF7JJ2U\n---\n### 一、jsoup概述\n\njsoup 是一款基于 Java 的HTML解析器，它提供了一套非常省力的API，不但能直接解析某个URL地址、HTML文本内容，而且还能通过类似于DOM、CSS或者jQuery的方法来操作数据，所以 jsoup 也可以被当做爬虫工具使用。\n\n### 二、相关概念简介\n\nDocument ：文档对象。每份HTML页面都是一个文档对象，Document 是 jsoup 体系中最顶层的结构。\nElement：元素对象。一个 Document 中可以着包含着多个 Element 对象，可以使用 Element 对象来遍历节点提取数据或者直接操作HTML。\nElements：元素对象集合，类似于List<Element>。\nNode：节点对象。标签名称、属性等都是节点对象，节点对象用来存储数据。\n类继承关系：Document 继承自 Element ，Element 继承自 Node。\n一般执行流程：先获取 Document 对象，然后获取 Element 对象，最后再通过 Node 对象获取数据。\n","slug":"jsoup","published":1,"updated":"2024-03-20T06:25:08.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxs0010iou25dum5ji8","content":"<h3 id=\"一、jsoup概述\"><a href=\"#一、jsoup概述\" class=\"headerlink\" title=\"一、jsoup概述\"></a>一、jsoup概述</h3><p>jsoup 是一款基于 Java 的HTML解析器，它提供了一套非常省力的API，不但能直接解析某个URL地址、HTML文本内容，而且还能通过类似于DOM、CSS或者jQuery的方法来操作数据，所以 jsoup 也可以被当做爬虫工具使用。</p>\n<h3 id=\"二、相关概念简介\"><a href=\"#二、相关概念简介\" class=\"headerlink\" title=\"二、相关概念简介\"></a>二、相关概念简介</h3><p>Document ：文档对象。每份HTML页面都是一个文档对象，Document 是 jsoup 体系中最顶层的结构。<br>Element：元素对象。一个 Document 中可以着包含着多个 Element 对象，可以使用 Element 对象来遍历节点提取数据或者直接操作HTML。<br>Elements：元素对象集合，类似于List<Element>。<br>Node：节点对象。标签名称、属性等都是节点对象，节点对象用来存储数据。<br>类继承关系：Document 继承自 Element ，Element 继承自 Node。<br>一般执行流程：先获取 Document 对象，然后获取 Element 对象，最后再通过 Node 对象获取数据。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、jsoup概述\"><a href=\"#一、jsoup概述\" class=\"headerlink\" title=\"一、jsoup概述\"></a>一、jsoup概述</h3><p>jsoup 是一款基于 Java 的HTML解析器，它提供了一套非常省力的API，不但能直接解析某个URL地址、HTML文本内容，而且还能通过类似于DOM、CSS或者jQuery的方法来操作数据，所以 jsoup 也可以被当做爬虫工具使用。</p>\n<h3 id=\"二、相关概念简介\"><a href=\"#二、相关概念简介\" class=\"headerlink\" title=\"二、相关概念简介\"></a>二、相关概念简介</h3><p>Document ：文档对象。每份HTML页面都是一个文档对象，Document 是 jsoup 体系中最顶层的结构。<br>Element：元素对象。一个 Document 中可以着包含着多个 Element 对象，可以使用 Element 对象来遍历节点提取数据或者直接操作HTML。<br>Elements：元素对象集合，类似于List<Element>。<br>Node：节点对象。标签名称、属性等都是节点对象，节点对象用来存储数据。<br>类继承关系：Document 继承自 Element ，Element 继承自 Node。<br>一般执行流程：先获取 Document 对象，然后获取 Element 对象，最后再通过 Node 对象获取数据。</p>\n"},{"title":"VueRouter","date":"2024-03-18T15:59:10.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-04-19_18-35-56.png?token=ASFPQIH5ZFVFELX7P4ECQWLF7JJY6","_content":"# 一.VueRouter","source":"_posts/VueRouter.md","raw":"---\ntitle: VueRouter\ndate: 2024-03-18 23:59:10\ntags: Vue\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-04-19_18-35-56.png?token=ASFPQIH5ZFVFELX7P4ECQWLF7JJY6\n---\n# 一.VueRouter","slug":"VueRouter","published":1,"updated":"2024-03-20T04:14:27.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxt0015iou26c1mhuhc","content":"<h1 id=\"一-VueRouter\"><a href=\"#一-VueRouter\" class=\"headerlink\" title=\"一.VueRouter\"></a>一.VueRouter</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一-VueRouter\"><a href=\"#一-VueRouter\" class=\"headerlink\" title=\"一.VueRouter\"></a>一.VueRouter</h1>"},{"title":"python","date":"2024-03-18T16:11:31.000Z","abstracts":"A abstracts of what this article is about","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/79399507_p0_square1200.jpg?token=ASFPQIH6CFM5ZQ2BGP4U2C3F7JJYE","_content":"# 一.python简介\n\n","source":"_posts/python.md","raw":"---\ntitle: python\ndate: 2024-03-19 00:11:31\ntags: 爬虫\nabstracts: A abstracts of what this article is about\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/79399507_p0_square1200.jpg?token=ASFPQIH6CFM5ZQ2BGP4U2C3F7JJYE\n---\n# 一.python简介\n\n","slug":"python","published":1,"updated":"2024-03-23T13:03:51.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxu0016iou2928rcvv6","content":"<h1 id=\"一-python简介\"><a href=\"#一-python简介\" class=\"headerlink\" title=\"一.python简介\"></a>一.python简介</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一-python简介\"><a href=\"#一-python简介\" class=\"headerlink\" title=\"一.python简介\"></a>一.python简介</h1>"},{"title":"k8s","date":"2024-03-18T14:13:22.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/屏幕截图(2).png","_content":"# 一.k8s简介","source":"_posts/k8s.md","raw":"---\ntitle: k8s\ndate: 2024-03-18 22:13:22\ntags: k8s\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/屏幕截图(2).png\ncategories: 运维\n---\n# 一.k8s简介","slug":"k8s","published":1,"updated":"2024-03-21T07:01:42.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxw001aiou2d2bba4qh","content":"<h1 id=\"一-k8s简介\"><a href=\"#一-k8s简介\" class=\"headerlink\" title=\"一.k8s简介\"></a>一.k8s简介</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一-k8s简介\"><a href=\"#一-k8s简介\" class=\"headerlink\" title=\"一.k8s简介\"></a>一.k8s简介</h1>"},{"title":"java八股文","date":"2024-03-18T09:14:43.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/index-read.gif","feature":true,"_content":"\n# 1、JAVA\n\n## 一、@Resource和@Autowire注解的区别\n\n@Resource和@Autowired都是用来进行依赖注入的注解，但是它们有一些不同之处。\n\n@Autowired是Spring框架中的注解，它可以用来标注字段、构造函数、方法等，表示需要自动装配。它可以用来注入依赖的bean。如果有多个bean符合条件，可能会抛出异常。\n\n@Resource是Java自带的注解，它可以用来标注字段、方法等，表示需要自动装配。它可以用来注入依赖的bean。如果有多个bean符合条件，会按照名称进行匹配。\n\n总结:\n\n@Autowired 是 Spring 框架中的注解，用来标注需要自动装配的 bean。\n@Resource 是 Java 自带的注解，用来标注需要自动装配的 bean。\n@Autowired 是按类型装配，如果有多个同类型的 bean，会抛出异常； @Resource 是按名称装配，如果名称不存在，会使用类型装配。\n\n## 2、重载与重写区别    难度系数：⭐\n\n1. 重载发生在本类，重写发生在父类与子类之间\n2. 重载的方法名必须相同，重写的方法名相同且返回值类型必须相同\n3. 重载的参数列表不同，重写的参数列表必须相同\n4. 重写的访问权限不能比父类中被重写的方法的访问权限更低\n5. 构造方法不能被重写\n\n## 12、普通类和抽象类有哪些区别？★★★★★\n\n抽象类不能被实例化；\n抽象类可以有抽象方法，只需申明，无须实现；\n有抽象方法的类一定是抽象类；\n抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类；\n抽象方法不能声明为静态、不能被static、final修饰。\n\n## 13、接口和抽象类有什么区别？★★★★★\n\n（1）接口\n\n接口使用interface修饰；\n接口不能实例化；\n类可以实现多个接口；\n\n①java8之前，接口中的方法都是抽象方法，省略了public abstract。②java8之后；接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；\n\n（2）抽象类\n\n抽象类使用abstract修饰；\n抽象类不能被实例化；\n抽象类只能单继承；\n抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体；\n如果一个类继承了抽象类，①如果实现了所有的抽象方法，子类可以不是抽象类；②如果没有实现所有的抽象方法，子类仍然是抽象类。\n\n共同点 不能实例化；\n\n不同点 接口使用interface修饰；抽象类使用abstract修饰；\n\n## 6、String、StringBuffer、StringBuilder 有什么区别？★★★★★\n\nString、StringBuffer、StringBuilder 最大的不同是 String 不可变，后者可变。StringBuffer 是线\n\n程安全的，StringBuilder 线程不安全速度较快。\n\n## 7、String.trim()方法去掉的是哪些字符？\n\ntrim 去掉字符串首尾的空白字符。\n\n## 8、String 可以被子类继承吗？\n\n既然 String 是 final 的，所以不能被继承。\n\n## 9、可以自定义 java.lang.String 类并使用吗？\n\n可以自定义 java.lang.String 类并编译成功，但不能被加载使用，具体请学习类加载机制。\n\n## 10、String 与 byte[]两者相互之间如何转换？\n\nString > byte[] 通过 String 类的 getBytes 方法；byte[] > String 通过 new String(byte[])构造器。\n\n## 11、==和 equals ⽅法的区别\n\n==：如果是基本数据类型，⽐较是值，如果是引⽤类型，⽐较的是引⽤地址\n\nequals：具体看各个类重写 equals ⽅法之后的⽐较逻辑，⽐如 String 类，虽然是引⽤类型，但是 String 类中重写了 equals ⽅法，⽅法内部⽐较的是字符串中的各个字符是否全部相等。\n\n### 2、== 和 [equals](https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020) 的区别是什么？\n\n1. 对于基本类型，==比较的是值；\n2. 对于引用类型，==比较的是地址；\n3. equals不能用于基本类型的比较；\n4. 如果没有重写equals，equals就相当于==；\n5. 如果重写了equals方法，equals比较的是对象的内容；\n\n## 12、 hashCode()与 equals()之间的关系★★★★★\n\n6 在 Java 中，每个对象都可以调⽤⾃⼰的 hashCode()⽅法得到⾃⼰的哈希值(hashCode)，相当于对象的 指纹信息，通常来说世界上没有完全相同的两个指纹，但是在 Java 中做不到这么绝对，但是我们仍然可 以利⽤ hashCode 来做⼀些提前的判断，⽐如： 如果两个对象的 hashCode 不相同，那么这两个对象肯定不同的两个对象 如果两个对象的 hashCode 相同，不代表这两个对象⼀定是同⼀个对象，也可能是两个对象 如果两个对象相等，那么他们的 hashCode 就⼀定相同 在 Java 的⼀些集合类的实现中，在⽐较两个对象是否相等时，会根据上⾯的原则，会先调⽤对象的 hashCode()⽅法得到 hashCode 进⾏⽐较，如果 hashCode 不相同，就可以直接认为这两个对象不相 同，如果 hashCode 相同，那么就会进⼀步调⽤ equals()⽅法进⾏⽐较。⽽ equals()⽅法，就是⽤来最终 确定两个对象是不是相等的，通常 equals ⽅法的实现会⽐较重，逻辑⽐较多，⽽ hashCode()主要就是得 到⼀个哈希值，实际上就⼀个数字，相对⽽⾔⽐较轻，所以在⽐较两个对象时，通常都会先根据 hashCode 想⽐较⼀下。 所以我们就需要注意，如果我们重写了 equals()⽅法，那么就要注意 hashCode()⽅法，⼀定要保证能遵 守上述规则。\n\n13、重载和重写的区别\n\n- 重载是指在一个类中定义了多个同名的方法，但他们的参数列表是不同的\n- 子[类继承](https://so.csdn.net/so/search?q=%E7%B1%BB%E7%BB%A7%E6%89%BF&spm=1001.2101.3001.7020)父类，子类重写父类中的所有公共方法，覆盖父类的方法并对其重写。\n\n重载\n\n```java\npublic static int add(int x, int y) {\n        return x + y;\n    }\n    public static double add(int x, int y) {\n        return x + y;\n    }\n```\n\n重写\n\n```java\nclass Animal {\n    public void eat(String food) {\n \t\t...\n    }\n}\n\nclass Bird extends Animal {\n    @Override\n    public void eat(String food) {\n\t\t...\n    }\n```\n\n## 13、String、StringBuffer 和 StringBuilder 的区别是什 么?★★★★★\n\nstring 不可变 线程安全 操作少量数据或不操作数据 是个对象 消耗内存性能底\n\nStringBuffer 不可变 线程不安全 频繁操作数据 不考虑线程安全\n\nStringBuilder 不可变 线程安全 频繁操作数据 考虑线程安全 +了 synchronizd(锁)\n\n## 14、 Java 创建对象有几种方式？★★★★★\n\njava 中提供了以下四种创建对象的方式:\n\n1. new 创建新对象\n2. 通过反射机制\n3. 采用 clone 机制\n4. 通过序列化机制\n\n15、 有没有可能两个不相等的对象有相同的 hashcode\n\n有可能.在产生 hash 冲突时,两个不相等的对象就会有相同的 hashcode 值.当 hash 冲突产生时,一般有以 下几种方式来处理:\n\n拉链法:每个哈希表节点都有一个 next 指针,多个哈希表节点可以用 next 指针构成一个单向链表，被 分配到同一个索引上的多个节点可以用这个单向链表进行存储.\n\n开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找 到,并将记录存入\n\n再哈希:又叫双哈希法,有多个不同的 Hash 函数.当发生冲突时,使用第二个,第三个….等哈希函数计算 地址,直到无冲突\n\n## 15、 深拷贝和浅拷贝的区别是什么?★★★★★\n\n### 深拷贝和浅拷贝\n\n深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。\n\n浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象\n深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象\n浅拷贝: 基本数据类型+实例对象的地址(这时浅拷贝的两个实例对象地址是同一个, 也就是同一个实例); 深拷贝: 基本数据类型+实例对象地址下的数据(也就是将实例对象也拷贝了一份)\n\n浅拷贝:被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向 原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.\n\n深拷贝:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被 复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都 复制了一遍.\n\n深拷⻉和浅拷⻉就是指对象的拷⻉，⼀个对象中存在两种类型的属性，⼀种是基本数据类型，⼀种是实 例对象的引⽤。 1. 浅拷⻉是指，只会拷⻉基本数据类型的值，以及实例对象的引⽤地址，并不会复制⼀份引⽤地址所 指向的对象，也就是浅拷⻉出来的对象，内部的类属性指向的是同⼀个对象 2. 深拷⻉是指，既会拷⻉基本数据类型的值，也会针对实例对象的引⽤地址所指向的对象进⾏复制， 深拷⻉出来的对象，内部的属性指向的不是同⼀个对象\n\n## 16、 final 有哪些用法? ★★★★★\n\n被 final 修饰的类不可以被继承\n\n被 final 修饰的方法不可以被重写\n\n被 final 修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.\n\n被 final 修饰的方法,JVM 会尝试将其内联,以提高运行效率 被 final 修饰的常量,在编译阶段会存入常量池中.\n\n修饰类：表示类不可被继承 修饰方法：表示方法不可被子类覆盖，但是可以重载 修饰变量：表示变量一旦被赋值就不可以更改它的值。 （1）修饰成员变量 如果 final 修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。 如果 final 修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。\n\nfinal 在 java 中有什么作用？\n（1）用来修饰一个引用\n\n如果引用为基本数据类型，则该引用为常量，该值无法修改；\n如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。\n如果引用时类的成员变量，则必须当场赋值，否则编译会报错。\n（2）用来修饰一个方法\n\n当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。\n\n（3）用来修饰类\n\n当用final修改类时，该类成为最终类，无法被继承。\n\n比如常用的String类就是最终类。\n\n## 7、如何将字符串反转？\n\n将对象封装到stringBuilder中，调用reverse方法反转。\n\n![1709658384085](images/1、JAVA/1709658384085.png)\n\n## 16、 3\\*0.1 == 0.3 返回值是什么\n\nfalse,因为有些浮点数不能完全精确的表示出来.\n\n## 17 Java 中有哪些类加载器★★★★★\n\nJDK ⾃带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。 BootStrapClassLoader 是 ExtClassLoader 的⽗类加载器，默认负责加载%JAVA_HOME%lib 下的 jar 包和 class ⽂件。 ExtClassLoader 是 AppClassLoader 的⽗类加载器，负责加载%JAVA_HOME%/lib/ext ⽂件夹下的 jar 包和 class 类。 AppClassLoader 是⾃定义类加载器的⽗类，负责加载 classpath 下的类⽂件\n\n## 16.hashCode()和 equals()方法有何重要性？★★★★★\n\n### ★★★★★\n\nHashMap 使用 Key 对象的 hashCode()和 equals()方法去决定 key-value 对的索引。点击这里一\n\n文搞懂它们之间的关系。\n\n当我们试着从 HashMap 中获取值的时候，这些方法也会被用到。如果这些方法没有被正确\n\n地实现，在这种情况下，两个不同 Key 也许会产生相同的 hashCode()和 equals()输出，HashMap\n\n将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。\n\n同样的，所有不允许存储重复数据的集合类都使用 hashCode()和 equals()去查找重复，所以\n\n正确实现它们非常重要。equals()和 hashCode()的实现应该遵循以下规则：\n\n1.如果 o1.equals(o2)，那么 o1.hashCode() == o2.hashCode()总是为 true 的。\n\n2.如果 o1.hashCode() == o2.hashCode()，并不意味着 o1.equals(o2)会为 true。\n\n## 17.Map 接口提供了哪些不同的集合视图？\n\nMap 接口提供三个集合视图：\n\n1）Set keyset()：返回 map 中包含的所有 key 的一个 Set 视图。集合是受 map 支持的，map\n\n的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若 map 被修\n\n改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过 Iterator\n\n更多关注 Java 大后端公众号的 Remove、Set.remove、removeAll、retainAll 和 clear 操作进行元素移除，从 map 中移除对\n\n应的映射。\n\n它不支持 add 和 addAll 操作。\n\n2）Collection values()：返回一个 map 中包含的所有 value 的一个 Collection 视图。这个 collection\n\n受 map 支持的，map 的变化会在 collection 中反映出来，反之亦然。当一个迭代器正在遍历\n\n一个 collection 时，若 map 被修改了（除迭代器自身的移除操作以外），迭代器的结果会变\n\n为未定义。集合支持通过 Iterator 的 Remove、Set.remove、removeAll、retainAll 和 clear 操作\n\n进行元素移除，从 map 中移除对应的映射。它不支持 add 和 addAll 操作。\n\n3）Set<Map.Entry<K,V>> entrySet()：返回一个 map 钟包含的所有映射的一个集合视图。这个\n\n集合受 map 支持的，map 的变化会在 collection 中反映出来，反之亦然。当一个迭代器正在\n\n遍历一个集合时，若 map 被修改了（除迭代器自身的移除操作，以及对迭代器返回的 entry\n\n进行 setValue 外），迭代器的结果会变为未定义。集合支持通过 Iterator 的 Remove、Set.remove、\n\nremoveAll、retainAll 和 clear 操作进行元素移除，从 map 中移除对应的映射。它不支持 add\n\n和 addAll 操作。\n\n## hashCode与equals★★★★★\n\nhashCode介绍：\nhashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是\n确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有\nhashCode() 函数。\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用\n到了散列码！（可以快速找到所需要的对象）\n为什么要有hashCode：\n以“HashSet如何检查重复”为例子来说明为什么要有hashCode：\n对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有\n值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals（）方法来\n检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会\n重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。\n如果两个对象相等，则hashcode一定也是相同的\n两个对象相等,对两个对象分别调用equals方法都返回true\n两个对象有相同的hashcode值，它们也不一定是相等的\n因此，equals方法被覆盖过，则hashCode方法也必须被覆盖\n***hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则******该class的两个\n对象无论如何都不会相等（即使这两个对象指向相同的数据）***\n\n## 18.HashMap 和 HashTable 有何不同？\n\n（1）HashMap 允许 key 和 value 为 null，而 HashTable 不允许。\n\n（2）HashTable 是同步的，而 HashMap 不是。所以 HashMap 适合单线程环境，HashTable\n\n适合多线程环境。\n\n（3）在 Java1.4 中引入了 LinkedHashMap，HashMap 的一个子类，假如你想要遍历顺序，你\n\n很容易从 HashMap 转向 LinkedHashMap，但是 HashTable 不是这样的，它的顺序是不可预知\n\n的。\n\n（4）HashMap 提供对 key 的 Set 进行遍历，因此它是 fail-fast 的，但 HashTable 提供对 key\n\n的 Enumeration 进行遍历，它不支持 fail-fast。\n\n（5）HashTable 被认为是个遗留的类，如果你寻求在迭代的时候修改 Map，你应该使用\n\nCocurrentHashMap。\n\n# 集合\n\n## [[java集合超详解\\_java集合使用-CSDN博客](https://blog.csdn.net/feiyanaffection/article/details/81394745)]\n\n![1709657326301](images/1、JAVA/1709657326301.png)\n\n![1709657362460](images/1、JAVA/1709657362460.png)\n\n![1709657394941](images/1、JAVA/1709657394941.png)\n\n![1709205810985](images/1、JAVA/1709205810985.png)\n\n[Set](https://pdai.tech/md/java/collection/java-collection-all.html#set)\n\n* [TreeSet](https://pdai.tech/md/java/collection/java-collection-all.html#treeset)\n* [HashSet](https://pdai.tech/md/java/collection/java-collection-all.html#hashset)\n* [LinkedHashSet](https://pdai.tech/md/java/collection/java-collection-all.html#linkedhashset)\n\n[List](https://pdai.tech/md/java/collection/java-collection-all.html#list)\n\n* [ArrayList ](https://pdai.tech/md/java/collection/java-collection-all.html#arraylist)\n* [Vector](https://pdai.tech/md/java/collection/java-collection-all.html#vector)\n* [LinkedList](https://pdai.tech/md/java/collection/java-collection-all.html#linkedlist)\n\n[Queue](https://pdai.tech/md/java/collection/java-collection-all.html#queue)\n\n* [LinkedList](https://pdai.tech/md/java/collection/java-collection-all.html#linkedlist-1)\n* [PriorityQueue](https://pdai.tech/md/java/collection/java-collection-all.html#priorityqueue)\n\n[Map](https://pdai.tech/md/java/collection/java-collection-all.html#map)\n\n* [TreeMap](https://pdai.tech/md/java/collection/java-collection-all.html#treemap)\n* [HashMap](https://pdai.tech/md/java/collection/java-collection-all.html#hashmap)\n* [HashTable](https://pdai.tech/md/java/collection/java-collection-all.html#hashtable)\n* [LinkedHashMap](https://pdai.tech/md/java/collection/java-collection-all.html#linkedhashmap)\n\nlist\n\nArrayList     底层数据结构是动态数组，查询快，增删慢。线程不安全，效率高\n\nVector       底层数据结构是数组，查询快，增删慢。线程安全，效率低\n\nLinkedList 底层数据结构是链表，查询慢，增删快 线程不安全，效率高\n\nset\n\nTreeset 红黑树\n\nHashset\n\n* 底层其实是包装了一个HashMap实现的\n* 底层数据结构是数组+链表 + 红黑树\n* 具有比较好的读取和查找性能， 可以有null 值\n* 通过equals和HashCode来判断两个元素是否相等\n* 非线程安全\n\nLinedHashkset\n\n* 继承HashSet，本质是LinkedHashMap实现\n* 底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。\n* 有序的，根据HashCode的值来决定元素的存储位置，同时使用一个链表来维护元素的插入顺序\n* 非线程安全，可以有null 值\n\nmap\n\n![1709208051453](images/1、JAVA/1709208051453.png)\n\nHashmap 哈希表\n\n特点是访问速度快，遍历顺序不确定，线程不安全，最多允许一个key为null，允许多个value为null。\n\n* 可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap类。\n\nTreemap 红黑树\n\n* TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。\n\nLinkedHashmap 双向链表\n\n* LinkedHashMap继承了HashMap，是Map接口的哈希表和链接列表实现，它维护着一个双重链接列表，此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。\n\nHashTable\n\nHashmap底层原理\n\n**HashMap的底层是数组+链表+红黑树实现的。集合put时，通过计算key键的哈希值来放入元素。若有key值相同的哈希值时，会通过链表进行存放，链表长度达到8时会开辟红黑树进行存放，以此提高查询效率**..\n\n## ArrayList 和 Vector 有何异同点？\n\n**ArrayList 和 Vector 在很多时候都很类似。**\n\n（1）两者都是基于索引的，内部由一个数组支持。\n\n（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。\n\n（3）ArrayList 和 Vector 的迭代器实现都是 fail-fast 的。\n\n（4）ArrayList 和 Vector 两者允许 null 值，也可以使用索引值对元素进行随机访问。\n\n**以下是 ArrayList 和 Vector 的不同点。**\n\n（1）Vector 是同步的，而 ArrayList 不是。然而，如果你寻求在迭代的时候对列表进行改变，\n\n你应该使用 CopyOnWriteArrayList。\n\n（2）ArrayList 比 Vector 快，它因为有同步，不会过载。\n\n（3）ArrayList 更加通用，因为我们可以使用 Collections 工具类轻易地获取同步列表和只读\n\n列表。\n\n## ArrayList 和 LinkedList 有何区别？\n\n![1709479433567](images/1、JAVA/1709479433567.png)\n\nArrayList 和 LinkedList 两者都实现了 List 接口，但是它们之间有些不同。\n\n1）ArrayList 是由 Array 所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，\n\n复杂度为 O(1)，但 LinkedList 存储一系列的节点数据，每个节点都与前一个和下一个节点相\n\n连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引\n\n的节点然后返回元素，时间复杂度为 O(n)，比 ArrayList 要慢。\n\n2）与 ArrayList 相比，在 LinkedList 中插入、添加和删除一个元素会更快，因为在一个元素被\n\n插入到中间的时候，不会涉及改变数组的大小，或更新索引。\n\n3）LinkedList 比 ArrayList 消耗更多的内存，因为 LinkedList 中的每个节点存储了前后节点的\n\n引用。\n\n.哪些集合类提供对元素的随机访问？\n\nArrayList、HashMap、TreeMap 和 HashTable 类提供对元素的随机访问。\n\n24.哪些集合类是线程安全的？\n\nVector、HashTable、Properties 和 Stack 是同步类，所以它们是线程安全的，可以在多线程环\n\n境下使用。Java1.5 并发 API 包括一些集合类，允许迭代时修改，因为它们都工作在集合的\n\n克隆上，所以它们在多线程环境中是安全的。\n\n## HashMap 和 HashSet 区别\n\n![1709211409103](images/1、JAVA/1709211409103.png)\n\n## 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同\n\nHashSet 是 Set 接口的主要实现类 ，HashSet 的底层是 HashMap，线程不安全的，可以存储 null\n值；\nLinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历；\nTreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。\n\n# 2、多线程\n\n## sleep(), wait(), join(), yield()区别★★★★★\n\nsleep()和wait\nsleep()方法是Thread类的静态本地方法, wait()则是Object类的本地方法(where)\nsleep一般用于当前线程休眠，或者轮循暂停操作，wait则多用于多线程之间的通信。(作用)\nsleep方法不依赖于同步器synchronized, 但是wait需要依赖synchronized(依赖)\nsleep方法不会释放锁, 但是wait会释放锁(锁)\nsleep不需要被唤醒（休眠之后推出阻塞)，但是wait需要〈不指定时间需要被别人中断)。(醒)\nwhere 作用 依赖 锁 醒\n\nyield\nyield()执行后线程直接进入就绪状态, 马上释放cpu执行权, 但是依然保留cpu的执行资格, 所以cpu下次进行线程调度还可能会让这个线程去的执行权\njoin()执行后线程进入阻塞状态, 例如在线程B中调用线程A的join(), 那线程B会进入阻塞队列, 直到线程A结束或中断结束\n例如t1线程正在执行, t2线程调用了t1.join(), 那线程B就会立即进入阻塞队列, 直到线程A结束或者中断线程\n\n## 线程同步方式\n\n1、Java通过加锁实现线程同步,锁有两类：synchronized和Lock。  2、synchronized加在三个不同的位置,对应三种不同的使用方式,这三种方式的区别是锁对象不同：  （1.）加在普通方法上,则锁是当前的实例（this）。 （2.）加在静态方法上,锁是当前类的Class对象。 （3.）加在代码块上,则需要在关键字后面的小括号里,显式指定一个对象作为锁对象。\n\n## 并发的三大特性\n\n原子性 原子性是指在一个操作中 cpu 不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要 不都不执行。\n\n可见性 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n有序性 虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按 照我们写的代码 的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，虽然对 变量的值没有造成影响，但有可能会出现线程安全问题。\n\n## 线程有几种状态\n\n![1709658004796](images/1、JAVA/1709658004796.png)\n\n1.线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。\n\n2.阻塞的情况又分为三种：\n\n(1)、等待阻塞：运行的线程执行 wait 方法，该线程会释放占用的所有资源，JVM 会把该线程放入“等待 池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用 notify 或 notifyAll 方法才能被唤 醒，wait 是 object 类的方法\n\n(2)、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放 入“锁池”中。\n\n(3)、其他阻塞：运行的线程执行 sleep 或 join 方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状 态。当 sleep 状态超时、join 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。 sleep 是 Thread 类的方法 1.新建状态（New）：新创建了一个线程对象。 2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的 start 方法。该状态的线程位于 可运行线程池中，变得可运行，等待获取 CPU 的使用权。 3.运行状态（Running）：就绪状态的线程获取了 CPU，执行程序代码。\n\n4.阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进 入就绪状态，才有机会转到运行状态。 5.死亡状态（Dead）：线程执行完了或者因异常退出了 run 方法，该线程结束生命周期\n\n## juc是什么\n\nJUC即java.util.concurrent,包含了支持并发操作的各种工具。\n\n## \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n# 3、Nginx\n\n## **1、请解释一下什么是 Nginx?**\n\nNginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3 和\n\nIMAP 协议。\n\n## **2、请列举 Nginx 的一些特性。**\n\nNginx 服务器的特性包括：\n\n反向代理/L7 负载均衡器\n\n嵌入式 Perl 解释器\n\n动态二进制升级\n\n可用于重新编写 URL，具有非常好的 PCRE 支持\n\n## **3、请列举 Nginx 和 Apache 之间的不同点**\n\n## **4、请解释 Nginx 如何处理 HTTP 请求。**\n\nNginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数\n\n据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提\n\n供数万个并发连接。\n\n## **5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?**\n\n只需将请求删除的服务器就可以定义为：\n\nServer {listen 80;server_name “ “ ;return 444;\n\n}\n\n这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下匹\n\n配请求，而一个特殊的 Nginx 的非标准代码 444 被返回，从而终止连接。\n\n## **6、 使用“反向代理服务器”的优点是什么?**\n\n更多关注 Java 大后端公众号更多关注 Java 大后端公众号\n\n反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器\n\n之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服务时。\n\n## **7、请列举 Nginx 服务器的最佳用途。**\n\nNginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应用\n\n程序服务器、用于脚本的 FastCGI 处理程序。它还可以作为负载均衡器。\n\n## **8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?**\n\nMaster 进程：读取及评估配置和维持\n\nWorker 进程：处理请求\n\n## **9、请解释你如何通过不同于 80 的端口开启 Nginx?**\n\n为了通过一个不同的端口开启 Nginx，你必须进入/etc/Nginx/sites-enabled/，\n\n如果这是默认文件，那么你必须打开名为“default”的文件。编辑文件，并放\n\n置在你想要的端口：\n\nLike server { listen 81; }\n\n## **10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?**\n\n502 =错误网关\n\n503 =服务器超载\n\n有可能，但是您可以确保 fastcgi_intercept_errors 被设置为 ON，并使用错误\n\n页面指令。\n\nLocation / {fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors\n\non;error_page 502 =503/error_page.html;#…}\n\n## **11、在 Nginx 中，解释如何在 URL 中保留双斜线?**\n\n要在 URL 中保留双斜线，就必须使用 merge_slashes_off;\n\n语法:merge_slashes [on/off]更多关注 Java 大后端公众号\n\n默认值: merge_slashes on\n\n环境: http，server\n\n## **12、请解释 ngx_http_upstream_module 的作用是什么?**\n\nngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi\n\n传递、memcached 传递和 scgi 传递指令来引用的服务器组。\n\n## **13、请解释什么是 C10K 问题?**\n\nC10K 问题是指无法同时处理大量客户端(10,000)的网络套接字。\n\n## **14、请陈述 stub_status 和 sub_filter 指令的作用是什么?**\n\nStub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活动\n\n连接，接受和处理当前读/写/等待连接的总数\n\nSub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据\n\n## **15、解释 Nginx 是否支持将请求压缩到上游?**\n\n您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤器，\n\n它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编码:gzip”来\n\n解压缩响应。\n\n## **16、解释如何在 Nginx 中获得当前的时间?**\n\n要获得 Nginx 的当前时间，必须使用 SSI 模块、$date_gmt 和$date_local 的变\n\n量。\n\nProxy_set_header THE-TIME $date_gmt;\n\n## **17、用 Nginx 服务器解释-s 的目的是什么?**\n\n用于运行 Nginx -s 参数的可执行文件。\n\n## **18、解释如何在 Nginx 服务器上添加模块?**\n\n在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选择。\n\n## \\\\\\\\\\\\\\\\\n\n1、请解释一下什么是 Nginx?\n\nNginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3\n\n和 IMAP 协议。\n\n2、请列举 Nginx 的一些特性。\n\nNginx 服务器的特性包括：\n\n反向代理/L7 负载均衡器\n\n嵌入式 Perl 解释器\n\n动态二进制升级\n\n可用于重新编写 URL，具有非常好的 PCRE 支持\n\n3、请列举 Nginx 和 Apache 之间的不同点\n\n4、请解释 Nginx 如何处理 HTTP 请求。\n\nNginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样\n\n数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可\n\n以提供数万个并发连接。\n\n5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?\n\n只需将请求删除的服务器就可以定义为：\n\nServer {listen 80;server_name “ “ ;return 444;\n\n}\n\n这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下\n\n匹配请求，而一个特殊的 Nginx 的非标准代码 444 被返回，从而终止连接。\n\n6、 使用“反向代理服务器”的优点是什么?\n\n反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务\n\n器之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服\n\n务时。\n\n7、请列举 Nginx 服务器的最佳用途。Nginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应\n\n用程序服务器、用于脚本的 FastCGI 处理程序。它还可以作为负载均衡器。\n\n8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?\n\nMaster 进程：读取及评估配置和维持\n\nWorker 进程：处理请求\n\n9、请解释你如何通过不同于 80 的端口开启 Nginx?\n\n为了通过一个不同的端口开启 Nginx，你必须进入/etc/Nginx/sites\u0002\n\nenabled/，如果这是默认文件，那么你必须打开名为“default”的文件。编辑\n\n文件，并放置在你想要的端口：\n\nLike server { listen 81; }\n\n10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?\n\n502 =错误网关\n\n503 =服务器超载\n\n有可能，但是您可以确保 fastcgi_intercept_errors 被设置为 ON，并使用错\n\n误页面指令。\n\nLocation / {fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors\n\non;error_page 502 =503/error_page.html;#…}\n\n11、在 Nginx 中，解释如何在 URL 中保留双斜线?\n\n要在 URL 中保留双斜线，就必须使用 merge_slashes_off;\n\n语法:merge_slashes [on/off]\n\n默认值: merge_slashes on\n\n环境: http，server\n\n12、请解释 ngx_http_upstream_module 的作用是什么?\n\nngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi\n\n传递、memcached 传递和 scgi 传递指令来引用的服务器组。\n\n13、请解释什么是 C10K 问题?C10K 问题是指无法同时处理大量客户端(10,000)的网络套接字。\n\n14、请陈述 stub_status 和 sub_filter 指令的作用是什么?\n\nStub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活\n\n动连接，接受和处理当前读/写/等待连接的总数\n\nSub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据\n\n15、解释 Nginx 是否支持将请求压缩到上游?\n\n您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤\n\n器，它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编\n\n码:gzip”来解压缩响应。\n\n16、解释如何在 Nginx 中获得当前的时间?\n\n要获得 Nginx 的当前时间，必须使用 SSI 模块、\\$date_gmt 和\\$date_local 的变\n\n量。\n\nProxy_set_header THE-TIME \\$date_gmt;\n\n17、用 Nginx 服务器解释-s 的目的是什么?\n\n用于运行 Nginx -s 参数的可执行文件。\n\n18、解释如何在 Nginx 服务器上添加模块?\n\n在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选\n\n择。\n\n# 4、spring\n\n## 1、springboot\n\n### **1、什么是 Spring Boot？**\n\nSpring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是\n\n简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。\n\n更多 Spring Boot 详细介绍请看这篇文章《什么是 Spring Boot?》。\n\n### **2、为什么要用 Spring Boot？**\n\nSpring Boot 优点非常多，如：\n\n![1709736051227](images/1、JAVA/1709736051227.png)\n\n 独立运行\n\n 简化配置\n\n 自动配置\n\n 无代码生成和 XML 配置\n\n 应用监控\n\n 上手容易\n\nSpring Boot 集这么多优点于一身，还有理由不使用它呢？\n\n### **5、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？**\n\n启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要\n\n组合包含了以下 3 个注解：\n\n@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。\n\n@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，\n\n如关闭数据源自动配置功能： @SpringBootApplication(exclude =\n\n{ DataSourceAutoConfiguration.class })。\n\n@ComponentScan：Spring 组件扫描。\n\n### **6、开启 Spring Boot 特性有哪几种方式？**\n\n1）继承 spring-boot-starter-parent 项目\n\n2）导入 spring-boot-dependencies 项目依赖\n\n具体请参考这篇文章《Spring Boot 开启的 2 种方式》。\n\n更多关注 Java 大后端公众号**7、Spring Boot 需要独立的容器运行吗？**\n\n可以不需要，内置了 Tomcat/ Jetty 等容器。\n\n### **8、运行 Spring Boot 有哪几种方式？**\n\n1）打包用命令或者放到容器中运行\n\n2）用 Maven/ Gradle 插件运行\n\n3）直接执行 main 方法运行\n\n### **9、Spring Boot 自动配置原理是什么？**\n\n注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动\n\n配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。\n\nSpring Boot 自动配置原理？\n\n@Import + @Configuration + Spring spi 图灵学院 自动配置类由各个 starter 提供，使用@Configuration + @Bean 定义配置类，放到 META\u0002INF/spring.factories 下 使用 Spring spi 扫描 META-INF/spring.factories 下的配置类 使用@Import 导入自动配置类具体看这篇文章《Spring Boot 自动配置原理、实战》。\n\n## 2、spring MVC\n\n### 1、什么是 SpringMvc？\n\n答：SpringMvc 是 spring 的一个模块，基于 MVC 的一个框架，无需中间整合层来整合。\n\n### 2、Spring MVC 的优点：\n\n答：\n\n1）它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java\n\n组件.并且和 Spring 提供的其他基础结构紧密集成.\n\n2）不依赖于 Servlet API(目标虽是如此,但是在实现的时候确实是依赖于 Servlet 的)\n\n3）可以任意使用各种视图技术,而不仅仅局限于 JSP\n\n4）支持各种请求资源的映射策略\n\n5）它应是易于扩展的\n\n### 3、SpringMVC 工作原理？\n\n答：\n\n1）客户端发送请求到 DispatcherServlet\n\n2）DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller\n\n3）Controller 调用业务逻辑后，返回 ModelAndView\n\n4）DispatcherServlet 查询 ModelAndView，找到指定视图\n\n5）视图将结果返回到客户端\n\n### 4、SpringMVC 流程？★★★★★\n\n1）用户发送请求至前端控制器 DispatcherServlet。\n\n2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。\n\n3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器对象\n\n及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。\n\n更多关注 Java 大后端公众号 4）DispatcherServlet 调用 HandlerAdapter 处理器适配器。\n\n5）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)。\n\n6）Controller 执行完成返回 ModelAndView。\n\n7）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。\n\n8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。\n\n9）ViewReslover 解析后返回具体 View。\n\n10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。\n\n11）DispatcherServlet 响应用户。\n\n## 3、spring\n\n![1709742703501](images/1、JAVA/1709742703501.png)\n\n## BeanFactory和ApplicationContext有什么区别(不熟)\n\nApplicationContext接口作为BeanFactory的子类,除了提供BeanFactory所具有的功能外,还提供了更完整的框架功能:\n①继承MessageSource,因此支持国际化\n②资源文件访问，如URL和文件（ResourceLoader）\n③载入多个（有继承关系）上下文（及同时加载多个配置文件），使得每一个上下文都专注于一个特定的层次\n④提供在监听器中注册bean的事件；\n\n## Spring是什么\n\nSpring 是一个轻量级的控制翻转(IOC)和面向切面(AOP)的容器框架\n\n从大小与开销两方面而言Spring都是轻量级的\n\n包含并且管理Bean的配置和生命周期,又通过控制反转和依赖注入来达到松耦合, 在这个意义上是一个Bean容器,\n\n提供了面向切面编程的丰富支持, 允许通过分离应用的业务逻辑和系统级 服务进行内聚性的开发\n将简单的组件配置, 组合为复杂的应用, 这个意义上是一个框架\n谈谈你对AOP的理解\n系统是由许多不同的组件所组成的, 每一个组件各负责着一些功能, 除了主要业务功能之外, 有些组件比如日志, 事务管理和安全等服务会水平散布到所有对象层次中去,\nOOP运行从上到下的关系但是并不适合定义从左到右的关系, 所以如果仍然按照OOP设计就会有大量代码的重复; 如果使用AOP就会将这些功能封装为一个切面, 然后注入到目标对象中, 而且AOP还可以对对象进行增强, 去做一些额外的事情.\n谈谈你对IOC的理解\n容器概念, 控制翻转, 依赖注入\n\n(容器概念)IOC容器中存有自己配置获取的一些Bean(比如@Repository, @Service, @Controller), 在项目启动时使用反射创建对应的对象放到map中 ;(依赖注入) 这时候map中就有各种对象了, 接下来通过bean的配置文件中去获取xml文件中该bean节点下的, 根据其ref属性进行依赖注入, 注入到对应的注解下(@Autowired或者@Resource)\n控制翻转: 控制翻转就是一个概念, 就是对象通过IOC容器和依赖注入自动进行装配, 就相当于原本属于程序员对对象创建的控制权交给了IOC\n总结来说, 就是IOC通过容器概念, 控制翻转和依赖注入成为了整个系统的关键核心, 它起到一种类似\"粘合剂\"的作用, 把系统中的所有对象粘合起来一起发挥作用.\n\n## 12.spring用了哪些设计模式\n\nBeanFactory用了工厂模式，AOP用了动态代理模式，RestTemplate用来模板方法模式，SpringMVC中handlerAdaper用来适配器模式，Spring里的监听器用了观察者模式\n\n## 14.SpringMV工作原理★★★★★\n\nSpringMVC工作过程围绕着前端控制器DispatchServerlet，几个重要组件有HandleMapping（处理器映射器）、HandleAdapter（处理器适配器）、ViewReslover（试图解析器）\n\n工作流程：\n\n（1）DispatchServerlet接收用户请求将请求发送给HandleMapping\n\n（2）HandleMapping根据请求url找到具体的handle和拦截器，返回给DispatchServerlet\n\n（3）DispatchServerlet调用HandleAdapter,HandleAdapter执行具体的controller，并将controller返回的ModelAndView返回给DispatchServler\n\n（4）DispatchServerlet将ModelAndView传给ViewReslover,ViewReslover解析后返回具体view\n\n（5）DispatchServerlet根据view进行视图渲染，返回给用户\n\n## 谈谈你对AOP的理解★★★★★\n\n系统是由许多不同的组件所组成的, 每一个组件各负责着一些功能, 除了主要业务功能之外, 有些组件比如日志, 事务管理和安全等服务会水平散布到所有对象层次中去,\nOOP运行从上到下的关系但是并不适合定义从左到右的关系, 所以如果仍然按照OOP设计就会有大量代码的重复; 如果使用AOP就会将这些功能封装为一个切面, 然后注入到目标对象中, 而且AOP还可以对对象进行增强, 去做一些额外的事情.\n\n## 谈谈你对IOC的理解★★★★★\n\n容器概念, 控制翻转, 依赖注入\n\n(容器概念)IOC容器中存有自己配置获取的一些Bean(比如@Repository, @Service, @Controller), 在项目启动时使用反射创建对应的对象放到map中 ;(依赖注入) 这时候map中就有各种对象了, 接下来通过bean的配置文件中去获取xml文件中该bean节点下的, 根据其ref属性进行依赖注入, 注入到对应的注解下(@Autowired或者@Resource)\n控制翻转: 控制翻转就是一个概念, 就是对象通过IOC容器和依赖注入自动进行装配, 就相当于原本属于程序员对对象创建的控制权交给了IOC\n总结来说, 就是IOC通过容器概念, 控制翻转和依赖注入成为了整个系统的关键核心, 它起到一种类似\"粘合剂\"的作用, 把系统中的所有对象粘合起来一起发挥作用.\n\n## bean的作用域\n\nsingleton：在Spring容器中仅存在一个实例，即Bean以单例的形式存在。\nprototype：为每一个bean请求提供一个实例。\nrequest ：每次HTTP请求都会创建一个新的Bean。\nsession：同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。\nglobalSession：同一个全局的Session共享一个Bean，一般用于Portlet环境\n\n## .bean的自动装配\n\n* @Autowried：通过byType方式实现，并且要求这个对象存在\n* @Resouce：默认通过byName方式实现，如果name找不到再通过byType实现\n\n### 1、什么是 Spring 框架？Spring 框架有哪些主要模块？\n\n轻量级的开源的 J2EE 框架。它是一个容器框架，用来装 javabean（java 对象），中间层框架（万能胶） 可以起一个连接作用，比如说把 Struts 和 hibernate 粘合在一起运用，可以让我们的企业开发更快、更简 洁 Spring 是一个轻量级的控制反转（IoC)和面向切面（AOP）的容器框架\n\n谈谈你对AOP的理解\nAOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象\n（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增\n强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情\n\n## 依赖注入的三种方式\n\n> 常用的注入方式主要有三种：构造方法注入（Construct注入），setter注入，基于注解的注入（接口注入）\n\n### 3、什么是控制反转(IOC)？什么是依赖注入？\n\n控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象\n\n之间耦合关系在编译时通常是未知的。在传统的编程方式中，业 务逻辑的流程是由应用程序中的早\n\n已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来\n\n决定的，该对象关系图由装配 器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽\n\n象化。而绑定的过程是通过“依赖注入”实现的。\n\n控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了\n\n有效的作用。\n\n依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实\n\n例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的\n\n基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？\n\n## 在 Java 中依然注入有以下三种实现方式：★★★★★\n\n1. 构造器注入\n2. Setter 方法注入\n3. 接口注入\n\n### 4、请解释下 Spring 框架中的 IoC？\n\nSpring 中的 org.springframework.beans 包和 org.springframework.context 包\n\n构成了 Spring 框架 IoC 容器的基础。\n\nBeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。\n\nApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory\n\n的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource\n\n的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的\n\nWebApplicationContext。\n\norg.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现，\n\n用来包装和管理前面提到的各种 bean。BeanFactory 接口是 Spring IoC 容器的核心接口。\n\nIOC:把对象的创建、初始化、销毁交给 spring 来管理，而不是由开发者控制，实现控制反转。\n\n### 5、BeanFactory 和 ApplicationContext 有什么区别？\n\n![1709478839382](images/1、JAVA/1709478839382.png)\n\nBeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在\n\n接收到客户端请求时将对应的 bean 实例化。\n\nBeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的\n\n配置中解放出来。BeanFactory 还包含 了 bean 生命周期的控制，调用客户端的初始化方法\n\n（initialization methods）和销毁方法（destruction methods）。\n\n从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，\n\n根据请求分发 bean 的功能。但 applicationcontext 在此基础上还提供了其他的功能。\n\n1. 提供了支持国际化的文本消息\n2. 统一的资源文件读取方式\n3. 已在监听器中注册的 bean 的事件\n\n以下是三种较常见的 ApplicationContext 实现方式：\n\n1、ClassPathXmlApplicationContext：从 classpath 的 XML 配置文件中读取上下文，并生成上\n\n下文定义。应用程序上下文从程序环境变量中\n\nApplicationContext context = new\n\nClassPathXmlApplicationContext(“bean.xml”);\n\n2、FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。\n\nApplicationContext context = new\n\nFileSystemXmlApplicationContext(“bean.xml”);\n\n3、XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。\n\n4.AnnotationConfigApplicationContext(基于 Java 配置启动容器)\n\n![1708002876939](images/1、JAVA/1708002876939.png)\n\n### 6、Spring 有几种配置方式？\n\n将 Spring 配置到应用开发中有以下三种方式：\n\n1. 基于 XML 的配置\n2. 基于注解的配置\n3. 基于 Java 的配置\n\n1.什么是 spring?\n\nSpring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用，但是有些\n\n扩展是针对构建 J2EE 平台的 web 应用。Spring 框架目标是简化 Java 企业级应用开发，并\n\n通过 POJO 为基础的编程模型促进良好的编程习惯。\n\n### 2.使用 Spring 框架的好处是什么？★★★★★\n\n 轻量：Spring 是轻量的，基本的版本大约 2MB。\n\n 控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建\n\n或查找依赖的对象们。\n\n 面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务\n\n分开。\n\n 容器：Spring 包含并管理应用中对象的生命周期和配置。\n\n MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。\n\n 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事\n\n务（JTA）。\n\n 异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，HibernateorJDO\n\n抛出的）转化为一致的 unchecked 异常。\n\n### 14.IOC 的优点是什么？\n\nIOC 或依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和\n\nJNDI 查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC 容器支持加载服务时\n\n的饿汉式初始化和懒加载。\n\n### 15.ApplicationContext 通常的实现是什么?\n\n FileSystemXmlApplicationContext：此容器从一个 XML 文件中加载 beans 的定义，\n\nXMLBean 配置文件的全路径名必须提供给它的构造函数。\n\n ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans 的定义，这\n\n里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。\n\n WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个 WEB 应用的\n\n所有 bean。\n\n### 16.Bean 工厂和 Applicationcontexts 有什么区别？\n\nApplicationcontexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如\n\n镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内的对象上执行\n\n的那些不得不由 bean 工厂以程序化方式处理的操作，可以在 Applicationcontexts 中以声\n\n明的方式处理。Applicationcontexts 实现了 MessageSource 接口，该接口的实现以可插拔\n\n的方式提供获取本地化消息的方法。\n\n### 19.有哪些不同类型的 IOC（依赖注入）方式？\n\n更多关注 Java 大后端公众号  构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系\n\n列参数，每个参数代表一个对其他类的依赖。\n\n Setter 方法注入：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂方法\n\n实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注入。\n\n### 11、 解释 Spring 支持的几种 bean 的作用域。\n\nSpring 容器中的 bean 可以分为 5 个范围：\n\n（1）singleton：默认，每个容器中只有一个 bean 的实例，单例的模式由 BeanFactory 自身来维护。\n\n（2）prototype：为每一个 bean 请求提供一个实例。\n\n（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回 收。\n\n（4）session：与 request 范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。\n\n（5）global-session：全局作用域，global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器 中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局 变量需要存储在 global-session 中。全局作用域与 Servlet 中的 session 作用域效果相同。25.解释 Spring 支持的几种 bean 的作用域。★★★★★\n\n## ★★★★★Spring 基于 xml 注入 bean 的几种方式：\n\n（1）Set 方法注入；\n\n（2）构造器注入：① 通过 index 设置参数的位置；② 通过 type 设置参数类型； （3）静态工厂注入； （4）实例工厂；\n\n## Spring Boot、Spring MVC 和 Spring 有什么区别\n\nspring 是一个 IOC 容器，用来管理 Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提 供 AOP 机制弥补 OOP 的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给 方法执行，比如日志、异常等 springmvc 是 spring 对 web 框架的一个解决方案，提供了一个总的前端控制器 Servlet，用来接收请求， 然后定义了一套路由策略（url 到 handle 的映射）及适配执行 handle，将 handle 结果使用视图解析技术 生成视图展现给前端 springboot 是 spring 提供的一个快速开发工具包，让程序员能更方便、更快速的开发 spring+springmvc 应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter 机制）、redis、 mongodb、es，可以开箱即用\n\n## #{}和\\${}的区别是什么？★★★★★\n\n#{}是预编译处理、是占位符， \\${}是字符串替换、是拼接符。 Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 来赋值； Mybatis 在处理\\${}时， 就是把\\${}替换成变量的值，调用 Statement 来赋值； #{} 的变量替换是在 DBMS 中、变量替换后，#{} 对应的变量自动加上单引号 \\${} 的变量替换是在 DBMS 外、变量替换后，\\${} 对应的变量不会加上单引号 使用#{}可以有效的防止 SQL 注入， 提高系统安全性。\n\n## 缓存雪崩、缓存穿透、缓存击穿★★★★★\n\n4.缓存穿透、缓存击穿、缓存雪崩\n缓存穿透：客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数据。\n解决方案：缓存空对象；布隆过滤器\n缓存击穿：一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。\n解决方案：热点数据永不过期；加互斥锁\n缓存雪崩\n解决方案：设置过期时间时，附加一个随机数，避免数据同时过期；\n\n缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内 承受大量请求而崩掉。 解决方案：\n\n- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。\n- 给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓 存。\n- 缓存预热\n- 互斥锁\n\n缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承 受大量请求而崩掉。\n\n- 解决方案： 接口层增加校验，如用户鉴权校验，id 做基础校验，id<=0 的直接拦截；\n- 从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有 效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户 反复用同一个 id 暴力攻击\n- 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据 会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力\n\n缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同 时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪 崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查 数据库。\n\n解决方案\n\n- 设置热点数据永远不过期。\n- 加互斥锁\n\n# Mybatis\n\n2、MyBatis 的优点和缺点 优点：\n\n1. （1）基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重 用。\n2. （2）与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；\n3. （3）很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。\n4. （4）能够与 Spring 很好的集成； （5）提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系 组件维护。\n\n缺点\n\n1. （1）SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定 要求。\n2. （2）SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。\n\n## #{}和\\${}的区别是什么？\n\n#{}是预编译处理，\\${}是字符串替换。 Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值； Mybatis 在处理\\${}时，就是把\\${}替换成变量的值。 使用#{}可以有效的防止 SQL 注入，提高系统安全性。\n\n# 5、ES\n\n### 1.为什么要使用 ES？\n\n虽然 lucene 是性能最先进的、功能完善的搜索引擎，但是它只能有一个库，而且使用它需\n\n要集成到 java 项目才能使用，配置还特别复杂,而 ES 语法简单、是基于 Resultful api 风格的,\n\n它在 lucene 所有功能基础上还能集成多台服务器进行搜索，也就是集群;\n\n### 2. ES 和 lucene 的区别是什么？\n\nlucene 是现存功能最强大、最先进搜索库，直接基于 lucene 开发，api 非常复杂大量的 java\n\n代码、需要深入了解原理\n\n对比处:\n\n只有一个索引库、\n\n传统的遍历搜索方式\n\n采用 B+树索引;\n\nEs 是基于 lucene 的，隐藏了 lucene 复杂部分的一个分布式全文检索框架\n\n对比处:\n\n一个 es 的集群包含多个索引库、\n\n分布式搜索\n\nEs 是采用倒排式索引\n\nes 没有事物概念,删除不能恢复\n\nes 开源免费\n\n正排索引：id ---> value\n\n倒排索引：value ---> id\n\n### 3.你还了解哪些全文检索工具？\n\nLucene，Solr，HadoopContrib，Katta\n\n### 4.Bulk 一次最大处理多少数据量？\n\nbulk 会把将要处理的数据载入内存中，所以数据量是有限制的\n\n最佳的数据量不是一个确定的数值，它取决于你的硬件，你的文档大小以及复杂性，你的索\n\n更多关注 Java 大后端公众号引以及搜索的负载。\n\n一般建议是 1000-5000 个文档，如果你的文档很大，可以适当减少队列,大小建议是 5-15MB，\n\n默认不能超过 100M，可以在 es 的配置文件中修改这个值 http.max_content_length: 100mb\n\n### 5.ES 在高并发的情况下如何保证数据线程安全问题？\n\n在读数据与写数据之间如果有其他线程进行写操作，就会出问题，es 使用版本控制才避免\n\n这种问题\n\n在修改数据的时候指定版本号，操作一次版本号加 1\n\n### 6.ES 管理的工具有哪些？\n\n1）BigDesk Plugin (作者 Luká? Vl?ek)：监控 es 状态的插件,推荐！主要提供的是节点的实时\n\n状态监控，包括 jvm 的情况，linux 的情况，elasticsearch 的情况\n\n2）Elasticsearch Head Plugin (作者 Ben Birch)：很方便对 es 进行各种操作的客户端。?\n\n3）Kibana(ES 官方推荐)：Es 基于?RestAPI 调试、数据报表、数据搜索\n\n### 7.ES 自动映射的规则？\n\nEs 映射是用于确定字段类型，将新增的每个字段数据类型映射后确定的字段类型，常见的\n\n映射类型有基本数据类型、复杂数据类型映射有数组对象(但对象映射扁平化后相关性会丢\n\n失，不能确定哪个是哪个属性)、\n\n全局映射的方式默认映射继承\\_default\\_的配置、动态模板映射：dynamic_templates，使用动\n\n态模板映射会覆盖默认模板，可设置关键字分词，默认模板是 string 类型的。\n\n# 6、面试\n\n## 1、请你自我介绍一下你自己？\n\n回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历\n\n上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究\n\n的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习\n\n无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。\n\n企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”，企\n\n业喜欢有礼貌的求职者。\n\n## 2、你觉得你个性上最大的优点是什么？\n\n回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和\n\n幽默感、乐观和友爱。\n\n## 3、说说你最大的缺点？\n\n回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求\n\n职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对\n\n不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比\n\n较出色，但事实上，他已经岌岌可危了。业喜欢求职者从自己的优点说起，中间加一些小缺\n\n点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者。\n\n## 4、你对加班的看法？\n\n回答提示：实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公\n\n司奉献。\n\n回答样本：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身\n\n心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n\n## 5、你对薪资的要求？\n\n回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，\n\n那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，\n\n因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这\n\n笔钱是否足以引起你对该工作的兴趣。如果你自己必须说出具体数目，请不要说一个宽泛的\n\n范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当\n\n今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。\n\n回答样本一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重\n\n的是找对工作机会，所以只要条件公平，我则不会计较太多。\n\n回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程\n\n特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n\n## 6、你的职业规划？\n\n回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多\n\n的答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地\n\n位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感\n\n兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的\n\n工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧\n\n失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司\n\n的管理思路发展”。\n\n## 7、你还有什么问题要问吗？\n\n回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，\n\n因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人\n\n这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋\n\n升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的\n\n上进心。\n\n## 8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，\n\n你怎么办？\n\n回答提示：一段时间发现工作不适合我，有两种情况：① 如果你确实热爱这个职业，那你就\n\n要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业\n\n要求，力争减少差距；② 你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，\n\n你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n\n## 9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该\n\n怎么做？\n\n回答提示：①.原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，\n\n婉转地表达自己的想法，看看领导是否能改变想法。② 如果领导没有采纳我的建议，我也同\n\n样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原\n\n则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n## 10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？\n\n回答提示：① 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法\n\n去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。② 分清责任，各负其责，\n\n如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，\n\n作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。\n\n③ 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中\n\n吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的\n\n深度和力度是否不够，以致出现了本可以避免的错误。\n\n更多关注 Java 大后端公众号 11、谈谈你对跳槽的看法？\n\n回答提示：① 正常的“跳槽”能促进人才合理流动，应该支持。② 频繁的跳槽对单位和个人\n\n双方都不利，应该反对。\n\n## 12、工作中你难以和同事、上司相处，你该怎么办？\n\n回答提示：① 我会服从领导的指挥，配合同事的工作。② 我会从自身找原因，仔细分析是不\n\n是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，\n\n如果是这样的话 我会努力改正。③ 如果我找不到原因，我会找机会跟他们沟通，请他们指\n\n出我的不足，有问题就及时改正。④ 作为优秀的员工，应该时刻以大局为重，即使在一段时\n\n间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看\n\n见我在努力，总有一天会对我微笑的。\n\n## 13、你对于我们公司了解多少？\n\n回答提示：在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加\n\n强与国外大厂的 OEM 合作，自有品牌的部分则透过海外经销商。\n\n## 14、请说出你选择这份工作的动机？\n\n回答提示：这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，\n\n如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。\n\n## 15、你最擅长的技术方向是什么？\n\n回答提示：说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。\n\n## 16、你能为我们公司带来什么呢？\n\n回答提示：企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后\n\n说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多\n\n的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以\n\n说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需\n\n求和消费。”等等。\n\n## 17、最能概括你自己的三个词是什么？\n\n回答提示：我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主\n\n考官解释，\n\n## 18、为什么要离职?\n\n回答提示：回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少\n\n的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪\n\n及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的\n\n更多关注 Java 大后端公众号空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等\n\n等，回答的答案最好是积极正面的。\n\n回答样本：我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，\n\n已经达到顶峰，即沒有升迁机会。\n\n## 19、对工作的期望与目标何在？\n\n回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解\n\n的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这\n\n时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我\n\n的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为\n\n了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目\n\n标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。\n\n## 20、就你申请的这个职位，你认为你还欠缺什么？\n\n回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的\n\n求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可\n\n以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学\n\n习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地\n\n躲过难题的求职者。\n\n## 21、你通常如何处理別人的批评？\n\n回答提示：① 沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。② 我会\n\n等大家冷靜下来再讨论。\n\n## 22、怎样对待自己的失敗？\n\n回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n\n## 23、什么会让你有成就感？\n\n回答提示：为贵公司竭力效劳，尽我所能，完成一个项目。\n\n## 24、你为什么愿意到我们公司来工作？\n\n回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些\n\n详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，\n\n我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市\n\n场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你\n\n已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。\n\n## 25、你和别人发生过争执吗？你是怎样解决的？\n\n更多关注 Java 大后端公众号回答提示：这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过\n\n错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，\n\n这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。\n\n考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没\n\n有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n\n## 26、对这项工作，你有哪些可预见的困难？\n\n回答提示：① 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。② 可以尝试迂回\n\n战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但\n\n是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以\n\n克服。\n\n分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中\n\n的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。第一，看看应\n\n聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一\n\n下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难\n\n的态度。\n\n## 27、如果我录用你，你将怎样开展工作？\n\n回答提示： ① 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工\n\n作的具体办法。② 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就\n\n有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开\n\n展工作。”。\n\n分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知\n\n道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回\n\n避的话，此人绝对不会录用了。\n\n## 28、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应\n\n该怎么做？与上级意见不一是，你将怎么办？\n\n回答提示：①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，\n\n婉转地表达自己的想法，看看领导是否能改变想法。② 如果领导没有采纳我的建议，我也同\n\n样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原\n\n则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n## 29、你工作经验欠缺，如何能胜任这项工作？\n\n常规思路：① 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在\n\n乎“经验”，关键看应聘者怎样回答。② 对这个问题的回答最好要体现出应聘者的诚恳、机\n\n智、果敢及敬业。③ 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期\n\n间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。\n\n更多关注 Java 大后端公众号但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各\n\n项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我\n\n一定能胜任这个职位。”\n\n点评：这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习\n\n成绩）为好。\n\n## 30、您在前一家公司的离职原因是什么？\n\n回答提示：① 最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”\n\n在此家招聘单位里不存在。② 避免把“离职原因”说得太详细、太具体。③ 不能掺杂主观的\n\n负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥\n\n我们某某的员工”等。④ 但也不能躲闪、回避，如“想换换环境”、“个人原因”等。⑤ 不能\n\n涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等。⑥ 尽量使解释的理由\n\n为应聘者个人形象添彩。⑦ 相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三\n\n年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步\n\n我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只\n\n有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对\n\n面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。\n\n分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考\n\n官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真\n\n诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能\n\n准假，所以辞职，这个答案一般面试官还能接受。\n\n## 31、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？\n\n回答提示：每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得\n\n到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重\n\n要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n\n## 32、果你在这次面试中没有被录用，你怎么打算？\n\n回答提示：现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有\n\n优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅\n\n仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方\n\n面来正确看待这次失败：① 要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就\n\n不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己\n\n经历了这次之后经过努力一定能行，能够超越自我。② 善于反思，对于这次面试经验要认真\n\n总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的\n\n看待自己的长短得失，做一个明白人。③ 走出阴影，要克服这一次失败带给自己的心理压力，\n\n时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④ 认真工作，回到原单位岗位\n\n上后，要实实在在、踏踏实实地工作，三十六行、行行出状元，争取在本岗位上做出一定的\n\n更多关注 Java 大后端公众号成绩。⑤ 再接再厉，成为国家公务员一直是我的梦想，以后如果有机会我仍然后再次参加竞\n\n争。\n\n## 33、谈谈你过去做过的成功案例？(工作中遇到什么问题)\n\n回答提示：举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。切\n\n忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电\n\n话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。\n\n## 34、如何安排自己的时间？会不会排斥加班？\n\n回答提示：基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也\n\n知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配\n\n合。\n\n分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。\n\n## 35、这个职务的期许？\n\n回答提示：希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、\n\n我个人而言，缔造“双赢”的局面。\n\n分析：回答前不妨先询问该公司对这项职务的责任认定及归属，因为每一家公司的状况不尽\n\n相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n\n## 36、什么选择我们这家公司？\n\n回答提示：曾经在报章杂志看过关于贵公司的报道，与自己所追求的理念有志一同。而贵公\n\n司在业界的成绩也是有目共睹的，而且对员工的教育训练、升迁等也都很有制度。\n\n分析：去面试前先做功课，了解一下该公司的背景，让对方觉得你真的很有心想得到这份工\n\n作，而不只是探探路。\n\n## 37、谈谈如何适应办公室工作的新环境？\n\n回答提示：① 办公室里每个人有各自的岗位与职责，不得擅离岗位。② 根据领导指示和工作\n\n安排，制定工作计划，提前预备，并按计划完成。③ 多请示并及时汇报，遇到不明白的要虚\n\n心请教。④ 抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n\n## 38、工作中学习到了些什么？\n\n回答提示：这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来\n\n回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学\n\n习到哪些经验，把握这些要点做陈述，就可以轻易过关了。\n\n## 39、除了本公司外，还应聘了哪些公司？\n\n回答提示：很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，\n\n更多关注 Java 大后端公众号所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，\n\n如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n\n## 40、何时可以到职？\n\n回答提示：大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司规\n\n定上班”，但如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至\n\n少要一个月的时间，应进一步说明原因，录取公司应该会通融的。\n\n# 7、redis\n\n## 1.redis为什么快？\n\n（1）完全基于内存操作\n\n（2）数据结构简单，对数据操作简单\n\n（3）redis执行命令是单线程的，避免了上下文切换带来的性能问题，也不用考虑锁的问题\n\n(4) 采用了非阻塞的io多路复用机制，使用了单线程来处理并发的连接;内部采用的epoll+自己实现的事件分离器\n\n其实Redis不是完全多线程的，在核心的网络模型中是多线程的用来处理并发连接，但是数据的操作都是单线程。Redis坚持单线程是因为Redis是的性能瓶颈是网络延迟而不是CPU，多线程对数据读取不会带来性能提升。\n\n## Redis如何实现key的过期删除？★★★★★\n\n采用的定期过期+惰性过期\n\n定期删除 ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。\n惰性删除 ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。\n\n## 11.Redis缓存一致性解决方案\n\nRedis缓存一致性解决方案主要思考的是删除缓存和更新数据库的先后顺序\n\n先删除缓存后更新数据库存在的问题是可能会数据不一致，一般使用延时双删来解决，即先删除缓存，再更新数据库，休眠X秒后再次淘汰缓存。第二次删除可能导致吞吐率降低，可以考虑进行异步删除。\n\n先更新数据库后删除缓存存在的问题是会可能会更新失败，可以采用延时删除。但由于读比写快，发生这一情况概率较小。\n\n但是无论哪种策略，都可能存在删除失败的问题，解决方案是用中间件canal订阅binlog日志提取需要删除的key，然后另写一段非业务代码去获取key并尝试删除，若删除失败就把删除失败的key发送到消息队列，然后进行删除重试。\n\n## 12.Redis内存淘汰策略\n\n当内存不足时按设定好的策略进行淘汰，策略有(1)淘汰最久没使用的（2）淘汰一段时间内最少使用的（3）淘汰快要过期的\n\n## 1、什么是 Redis？\n\nRedis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载\n\n在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。因为是纯\n\n内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快\n\n的 Key-Value DB。\n\nRedis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结\n\n构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis\n\n可以用来实现很多有用的功能，比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的\n\n高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。另外 Redis 也可以对存入\n\n的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。\n\nRedis\n\n的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis\n\n适合的场景主要局限在较小数据量的高性能操作和运算上。\n\n## 2、Redis 相比 memcached 有哪些优势？\n\n(1) memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型\n\n(2) redis 的速度比 memcached 快很多\n\n(3) redis 可以持久化其数据\n\n## 3、Redis 支持哪几种数据类型？\n\nString、List、Set、Sorted Set、hashes\n\n字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。如果是高级用户，那\n\n么还会有，如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、\n\nGeo、Pub/Sub。\n\n## 4、Redis 主要消耗什么物理资源？\n\n内存。\n\n## 5、Redis 的全称是什么？\n\nRemote Dictionary Server。\n\n## 6、Redis 有哪几种数据淘汰策略？\n\nnoeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部\n\n分的写入指令，但 DEL 和几个例外）\n\nallkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。\n\nvolatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有\n\n空间存放。\n\nallkeys-random: 回收随机的键使得新添加的数据有空间存放。\n\nvolatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。\n\nvolatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数\n\n据有空间存放。\n\n## 7、Redis 官方为什么不提供 Windows 版本？\n\n因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来\n\n兼容性等问题。\n\n## 8、一个字符串类型的值能存储最大容量是多少？\n\n512M\n\n更多关注 Java 大后端公众号 9、为什么 Redis 需要把所有数据放到内存中？\n\nRedis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。\n\n所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度为严重\n\n影响 redis 的性能。在内存越来越便宜的今天，redis 将会越来越受欢迎。 如果设置了最大\n\n使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。\n\n## 10、Redis 集群方案应该怎么做？都有哪些方案？\n\n1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通 redis 无任何区别，设\n\n置好它下属的多个 redis 实例后，使用时在本需要连接 redis 的地方改为连接 twemproxy，它\n\n会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再\n\n返回 twemproxy。使用方式简便(相对 redis 只需修改连接端口)，对旧项目扩展的首选。 问\n\n题：twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的\n\n计算值的改变，数据无法自动移动到新的节点。\n\n2.codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量\n\n改变情况下，旧节点数据可恢复到新 hash 节点。\n\n3.redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概\n\n念，以及自身支持节点设置从节点。具体看官方文档介绍。\n\n4.在业务代码层实现，起几个毫无关联的 redis 实例，在代码层，对 key 进行 hash 计算，然\n\n后去对应的 redis 实例操作数据。 这种方式对 hash 层代码要求比较高，考虑部分包括，节\n\n点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。\n\n## 11、Redis 集群方案什么情况下会导致整个集群不可用？\n\n有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就\n\n会以为缺少 5501-11000 这个范围的槽而不可用。\n\n## 12、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点\n\n数据？\n\nredis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。\n\n## 13、Redis 有哪些适合的场景？\n\n更多关注 Java 大后端公众号（1）、会话缓存（Session Cache）\n\n最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储\n\n（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存\n\n时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？\n\n幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。\n\n甚至广为人知的商业平台 Magento 也提供 Redis 的插件。\n\n（2）、全页缓存（FPC）\n\n除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了\n\nRedis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改\n\n进，类似 PHP 本地 FPC。\n\n再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。\n\n此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助\n\n你以最快速度加载你曾浏览过的页面。\n\n（3）、队列\n\nReids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很\n\n好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）\n\n对 list 的 push/pop 操作。\n\n如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项\n\n目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一\n\n个后台就是使用 Redis 作为 broker，你可以从这里去查看。\n\n（4），排行榜/计数器\n\nRedis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted\n\nSet）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结\n\n构。所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，\n\n我们只需要像下面一样执行即可：\n\n更多关注 Java 大后端公众号当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你\n\n需要这样执行：\n\nZRANGE user_scores 0 10 WITHSCORES\n\nAgora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据\n\n的，你可以在这里看到。\n\n（5）、发布/订阅\n\n最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常\n\n多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用\n\nRedis 的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。\n\n## 14、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？\n\nRedisson、Jedis、lettuce 等等，官方推荐使用 Redisson。\n\n## 15、Redis 和 Redisson 有什么关系？\n\nRedisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些\n\nJava 的 对 象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map,\n\nConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore,\n\nLock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。\n\n## 16、Jedis 与 Redisson 对比有什么优缺点？\n\nJedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；Redisson\n\n实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，\n\n不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关\n\n注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。\n\n## 17、Redis 如何设置密码及验证密码？\n\n设置密码：config set requirepass 123456\n\n授权密码：auth 123456\n\n更多关注 Java 大后端公众号 18、说说 Redis 哈希槽的概念？\n\nRedis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，\n\n每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分\n\nhash 槽。\n\n## 19、Redis 集群的主从复制模型是怎样的？\n\n为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主\n\n从复制模型,每个节点都会有 N-1 个复制品.\n\n## 20、Redis 集群会有写操作丢失吗？为什么？\n\nRedis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操\n\n作。\n\n## 21、Redis 集群之间是如何复制的？\n\n异步复制\n\n## 22、Redis 集群最大节点个数是多少？\n\n16384 个。\n\n## 23、Redis 集群如何选择数据库？\n\nRedis 集群目前无法做数据库选择，默认在 0 数据库。\n\n## 24、怎么测试 Redis 的连通性？\n\nping\n\n## 25、Redis 中的管道有什么用？\n\n一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命\n\n令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。\n\n这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现\n\n更多关注 Java 大后端公众号支持这个功能，大大加快了从服务器下载新邮件的过程。\n\n## 26、怎么理解 Redis 事务？\n\n事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的\n\n过程中，不会被其他客户端发送来的命令请求所打断。\n\n事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。\n\n## 27、Redis 事务相关的命令有哪几个？\n\nMULTI、EXEC、DISCARD、WATCH\n\n## 28、Redis key 的过期时间和永久有效分别怎么设置？\n\nEXPIRE 和 PERSIST 命令。\n\n## 29、Redis 如何做内存优化？\n\n尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，\n\n所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个\n\n用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户\n\n的所有信息存储到一张散列表里面.\n\n## 30、Redis 回收进程如何工作的？\n\n一个客户端运行了新的命令，添加了新的数据。\n\nRedi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。\n\n一个新的命令被执行，等等。\n\n所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。\n\n如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不\n\n用多久内存限制就会被这个内存使用量超越。\n\n## 31、Redis 回收使用的是什么算法？\n\nLRU 算法\n\n## 32、Redis 如何做大量数据插入？\n\n更多关注 Java 大后端公众号 Redis2.6 开始 redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工\n\n作。\n\n## 33、为什么要做 Redis 分区？\n\n分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，你\n\n最多只能使用一台机器的内存。分区使 Redis 的计算能力通过简单地增加计算机得到成倍提\n\n升,Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。\n\n## 34、你知道有哪些 Redis 分区实现方案？\n\n客户端分区就是在客户端就已经决定数据会被存储到哪个 redis 节点或者从哪个 redis 节点读\n\n取。大多数客户端已经实现了客户端分区。\n\n代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。\n\n代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。redis\n\n和 memcached 的一种代理实现就是 Twemproxy\n\n查询路由(Query routing) 的意思是客户端随机地请求任意一个 redis 实例，然后由 Redis 将请\n\n求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接\n\n将请求从一个 redis 节点转发到另一个 redis 节点，而是在客户端的帮助下直接 redirected 到\n\n正确的 redis 节点。\n\n## 35、Redis 分区有什么缺点？\n\n涉及多个 key 的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储\n\n到不同的 Redis 实例（实际上这种情况也有办法，但是不能直接使用交集指令）。\n\n同时操作多个 key,则不能使用 Redis 事务.\n\n分区使用的粒度是 key，不能使用一个非常长的排序 key 存储一个数据集（The partitioning\n\ngranularity is the key, so it is not possible to shard a dataset with a single huge key like a very big\n\nsorted set）.\n\n当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的 Redis 实例和主机\n\n同时收集 RDB / AOF 文件。\n\n分区时动态扩容或缩容可能非常复杂。Redis 集群在运行时增加或者删除 Redis 节点，能做\n\n到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这\n\n种特性。然而，有一种预分片的技术也可以较好的解决这个问题。\n\n## 36、Redis 持久化数据和缓存怎么做扩容？\n\n更多关注 Java 大后端公众号如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。\n\n如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数\n\n量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行\n\n时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。\n\n## 37、分布式 Redis 是前期做还是后期规模上来了再做好？为什么？\n\n既然 Redis 是如此的轻量（单实例只使用 1M 内存）,为防止以后的扩容，最好的办法就是一\n\n开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式\n\n运行，使用分区，在同一台服务器上启动多个实例。\n\n一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可\n\n能比较麻烦，但是从长久来看做这点牺牲是值得的。\n\n这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis\n\n实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了\n\n另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。\n\n## 38、Twemproxy 是什么？\n\nTwemproxy 是 Twitter 维护的（缓存）代理系统，代理 Memcached 的 ASCII 协议和 Redis 协\n\n议。它是单线程程序，使用 c 语言编写，运行起来非常快。它是采用 Apache 2.0 license 的开\n\n源软件。 Twemproxy 支持自动分区，如果其代理的其中一个 Redis 节点不可用时，会自动\n\n将该节点排除（这将改变原来的 keys-instances 的映射关系，所以你应该仅在把 Redis 当缓存\n\n时使用 Twemproxy)。 Twemproxy 本身不存在单点问题，因为你可以启动多个 Twemproxy 实\n\n例，然后让你的客户端去连接任意一个 Twemproxy 实例。 Twemproxy 是 Redis 客户端和服\n\n务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。\n\n## 39、支持一致性哈希的客户端有哪些？\n\nRedis-rb、Predis 等。\n\n## 40、Redis 与其他 key-value 存储有什么不同？\n\nRedis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库\n\n的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外\n\n的抽象。\n\nRedis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡\n\n更多关注 Java 大后端公众号更多关注 Java 大后端公众号\n\n内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上\n\n相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很\n\n强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要\n\n进行随机访问。\n\n## 41、Redis 的内存占用情况怎么样？\n\n给你举个例子： 100 万个键值对（键是 0 到 999999 值是字符串“hello world”）在我的 32\n\n位的 Mac 笔记本上 用了 100MB。同样的数据放到一个 key 里只需要 16MB，\n\n这是因为键值\n\n有一个很大的开销。 在 Memcached 上执行也是类似的结果，但是相对 Redis 的开销要小一\n\n点点，因为 Redis 会记录类型信息引用计数等等。\n\n当然，大键值对时两者的比例要好很多。\n\n64 位的系统比 32 位的需要更多的内存开销，尤其是键值对都较小时，这是因为 64 位的系\n\n统里指针占用了 8 个字节。 但是，当然，64 位系统支持更大的内存，所以为了运行大型的\n\nRedis 服务器或多或少的需要使用 64 位的系统。\n\n## 42、都有哪些办法可以降低 Redis 的内存使用情况呢？\n\n如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据，\n\n因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。\n\n43、查看 Redis 使用情况及状态信息用什么命令？\n\ninfo\n\n## 44、Redis 的内存用完了会发生什么？\n\n如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或者\n\n你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。\n\n## 45、Redis 是单线程的，如何提高多核 CPU 的利用率？\n\n可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时\n\n候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU，你可以考虑一下分片\n\n（shard）。\n\n## 46、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2\n\n亿 5 千万的 keys。我们正在测试一些较大的值。\n\n任何 list、set、和 sorted set 都可以放 232 个元素。\n\n换句话说，Redis 的存储极限是系统中的可用内存值。\n\n## 47、Redis 常见性能问题和解决方案？\n\n(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件\n\n(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次\n\n(3) 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内\n\n(4) 尽量避免在压力很大的主库上增加从库\n\n(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <-\n\nSlave3...\n\n这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以\n\n立刻启用 Slave1 做 Master，其他不变。\n\n## 48、Redis 提供了哪几种持久化方式？\n\nRDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储.\n\nAOF 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢\n\n复原始的数据,AOF 命令以 redis 协议追加保存每次写的操作到文件末尾.Redis 还能对 AOF 文\n\n件进行后台重写,使得 AOF 文件的体积不至于过大.\n\n如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.\n\n你也可以同时开启两种持久化方式, 在这种情况下, 当 redis 重启的时候会优先载入 AOF 文\n\n件来恢复原始的数据,因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集\n\n要完整.\n\n最重要的事情是了解 RDB 和 AOF 持久化方式的不同,让我们以 RDB 持久化方式开始。\n\n## 49、如何选择合适的持久化方式？\n\n一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化\n\n更多关注 Java 大后端公众号功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只\n\n使用 RDB 持久化。\n\n有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）\n\n非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除\n\n此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug。\n\n## 50、修改配置不重启 Redis 会实时生效吗？\n\n针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式\n\n的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要\n\n重启 Redis。检索 ‘CONFIG GET \\*’ 命令获取更多信息。\n\n但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前\n\nCONFIG 命令还不支持的配置参数的时候。\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n# 8.MySQL\n\n## 1\\***\\*、数据库的三范式是什么★★★★★**\n\n第一范式：列不可再分\n\n第二范式：行可以唯一区分，主键约束\n\n第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束\n\n且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。\n\n## **2\\*\\***、数据库引擎有哪些\\*\\*\n\n如何查看 mysql 提供的所有存储引擎\n\n![1709735857375](images/1、JAVA/1709735857375.png)\n\n`mysql> show engines;`\n\nmysql 常用引擎包括：MYISAM、Innodb、Memory、MERGE\n\n- MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对\n- 较小，对事务完整性没有要求，以 select、insert 为主的应用基本上可以使用这引擎\n- Innodb:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键\n- 约束，并发能力强，占用空间是 MYISAM 的 2.5 倍，处理效率相对会差一些\n- Memory:全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在 mysql 重\n- 启时会丢失，默认使用 HASH 索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变\n- 化不频繁的代码表\n- MERGE：是一组 MYISAM 表的组合\n\n## **3\\*\\***、\\***\\*InnoDB\\*\\***与\\***\\*MyISAM\\*\\***的区别\n\n1. InnoDB 支持事务，MyISAM 不支持，对于 InnoDB 每一条 SQL 语言都默认封装成事务，自动提交，\n\n这样会影响速度，所以最好把多条 SQL 语言放在 begin 和 commit 之间，组成一个事务；\n\n2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；\n3. InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但\n\n是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，\n\n因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的\n\n是数据文件的指针。主键索引和辅助索引是独立的。\n\n4. InnoDB 不保存表的具体行数，执行 select count(\\*) from table 时需要全表扫描。而 MyISAM 用一\n\n个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；\n\n5. Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；\n\nmysql> show engines;**如何选择引擎？**\n\n如果没有特别的需求，使用默认的 Innodb 即可。\n\nMyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。\n\nInnodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如\n\nOA 自动化办公系统。\n\n**4\\*\\***、数据库的事务\\*\\*\n\n## 4\\***\\*、数据库的事务★★★★★**\n\n**什么是事务？**\n\n**：** 多条 sql 语句，要么全部成功，要么全部失败。\n\n**事务的特性：**\n\n**数据库事务特性：原子性\\*\\***(Atomic)\\***\\*、一致性\\*\\***(Consistency)\\***\\*、隔离性\\*\\***(Isolation)\\***\\*、持久性\\*\\***(Durabiliy)\\***\\*。**\n\n**简称\\*\\***ACID\\***\\*。**\n\n原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功，整个\n\n事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。\n\n一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如 A\n\n转账 100 元给 B，不管操作是否成功，A 和 B 的账户总额是不变的。\n\n隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰\n\n持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。\n\n## 事务并发产生的三种问题\n\n## 脏读：一个事务读取到了另外一个事务没有提交的数据\n\n幻读：同一事务中，用同样的操作读取两次，得到的记录数不相同（数据条数）\n不可重复读：在同一事务中，两次读取同一数据，得到内容不同（数据内容）\n6.mysql的事务隔离级别\n读未提交 Read uncommitted：一个事务还没有提交时，它做的变更就能被别的事务看到。\n读提交 Read committed：一个事物提交之后，它做的变更才会被其他事务看到。\n可重复读 Repeatable read：一个事物执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。未提交变更对其他事务也是不可见的。\n串行化 serializable：对于同一行记录，写会加“写锁”，读会加“读锁”，当出现\n\n## .innodb和myisam区别\n\ninnodb支持事务；myisam不支持事务\ninnodb支持外键；myisam不支持外键\ninnodb是聚集索引，数据和索引是捆绑在一起的；myisam是非聚集索引，数据和索引分开的，这也导致他们底层B+树结构不同。\ninnodb每个表下两个文件：.frm文件中保存的是表的结构，.ibd文件中保存的是数据和索引方式\nmyisam每个表下三个文件：一个文件用来保存 表结构，一个文件用来保存 数据，一个文件用来保存 索引\n\n## **5**、索引问题\n\n索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于快速获取信息。\n\n你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，\n\n索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅\n\n速地找到表中的数据，而不必扫描整个数据库。\n\n.索引\n索引是帮助MySQL高效获取数据的数据结构，通俗来讲索引就好比书本的目录，加快数据库的查询速度。\n分类\n按功能逻辑分\n主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个\n唯一索引：加速查询 + 列值唯一（可以有null）\n普通索引：仅加速查询\n组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并\n全文索引：对文本的内容进行分词，进行搜索\n按物理结构分\n聚簇索引\n非聚簇索引★★★★★\n\nmysql 有 4 种不同的索引：\n\n1. 主键索引（PRIMARY）\n2. 数据列不允许重复，不允许为 NULL，一个表只能有一个主键。\n3. 唯一索引（UNIQUE）\n4. 数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。\n5. 可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引\n6. 可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索\n7. 引\n8. 普通索引（INDEX）\n9. 可以通过 ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引\n10. 可以通过 ALTER TABLE table_name ADD INDEX index_name(column1, column2,\n11. column3); 创建组合索引\n12. 全文索引（FULLTEXT）\n13. 可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引\n\n**索引并非是越多越好，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时**\n\n**要花费较多的时间维护索引**\n\n1. 索引加快数据库的检索速度\n2. 索引降低了插入、删除、修改等维护任务的速度\n3. 唯一索引可以确保每一行数据的唯一性\n4. 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能\n5. 索引需要占物理和数据空间\n\n## 6、SQL 优化\n\n1、查询语句中不要使用 select \\*\n\n2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代\n\n3、减少使用 IN 或者 NOT IN ,使用 exists，not exists 或者关联查询语句替代\n\n4、or 的查询尽量用 union 或者 union all 代替(在确认没有重复数据或者不用剔除重复数据时，union\n\nall 会更好)\n\n5、应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。\n\n6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫\n\n描，如： select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null\n\n值，然后这样查询： select id from t where num=0\n\n## **7\\*\\***、简单说一说\\***\\*drop\\*\\***、\\***\\*delete\\*\\***与\\***\\*truncate\\*\\***的区别\\*\\*\n\nSQL 中的 drop、delete、truncate 都表示删除，但是三者有一些差别\n\ndelete 和 truncate 只删除表的数据不删除表的结构\n\n速度,一般来说: drop> truncate >delete\n\ndelete 语句是 dml,这个操作会放到 rollback segement 中,事务提交之后才生效;\n\n如果有相应的 trigger,执行的时候将被触发. truncate,drop 是 ddl, 操作立即生效,原数据不放到 rollback\n\nsegment 中,不能回滚. 操作不触发 trigger.\n\n## **8\\*\\***、什么是视图\\*\\*\n\n视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一\n\n个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表\n\n查询。\n\n## **9\\*\\***、 什么是内联接、左外联接、右外联接？\\*\\*\n\n1. 内联接（Inner Join）：匹配 2 张表中相关联的记录。\n2. 左外联接（Left Outer Join）：除了匹配 2 张表中相关联的记录外，还会匹配左表中剩余的记录，\n3. 右表中未匹配到的字段用 NULL 表示。\n4. 右外联接（Right Outer Join）：除了匹配 2 张表中相关联的记录外，还会匹配右表中剩余的记录，\n5. 左表中未匹配到的字段用 NULL 表示。在判定左表和右表时，要根据表名出现在 Outer Join 的左右\n6. 位置关系。\n\n## **10\\*\\***、并发事务带来哪些问题\\***\\*?\\*\\***隔离级别\\*\\*\n\n**脏读**\n\n**不可重复读**\n\n**幻影读**\n\nREAD-UNCOMMITTED\n\n√\n\n√\n\n√\n\nREAD-COMMITTED\n\n×\n\n√\n\n√\n\nREPEATABLE-READ\n\n×\n\n×\n\n√\n\nSERIALIZABLE\n\n×\n\n×\n\n×\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一\n\n数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n\n**脏读（\\*\\***Dirty read\\***\\*）\\*\\***:\\*\\* 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到\n\n数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提\n\n交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确\n\n的。\n\n**丢失修改（\\*\\***Lost to modify\\***\\*）\\*\\***:\\*\\* 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那\n\n么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结\n\n果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事\n\n务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。\n\n**不可重复读（\\*\\***Unrepeatableread\\***\\*）\\*\\***:\\*\\* 指在一个事务内多次读同一数据。在这个事务还没有结束\n\n时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改\n\n导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样\n\n的情况，因此称为不可重复读。\n\n**幻读（\\*\\***Phantom read\\***\\*）\\*\\***:\\*\\* 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接\n\n着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了\n\n一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n**不可重复读和幻读区别：**\n\n不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者\n\n删除比如多次读取一条记录发现记录增多或减少了。\n\n## **11\\*\\***、事务隔离级别有哪些\\***\\*?MySQL\\*\\***的默认隔离级别是\\***\\*?**\n\n**SQL** **标准定义了四个隔离级别：**\n\n**READ-UNCOMMITTED(\\*\\***读取未提交\\***\\*)\\*\\***：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会\\*\\*\n\n**导致脏读、幻读或不可重复读**。\n\n**READ-COMMITTED(\\*\\***读取已提交\\***\\*)\\*\\***：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻\\*\\*\n\n**读或不可重复读仍有可能发生**。\n\n**REPEATABLE-READ(\\*\\***可重复读\\***\\*)\\*\\***：\\*\\* 对同一字段的多次读取结果都是一致的，除非数据是被本身事务\n\n自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。\n\n**SERIALIZABLE(\\*\\***可串行化\\***\\*)\\*\\***：\\*\\* 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执\n\n行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻**\n\n**读**。\n\nMySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ\\*\\***（可重读）\\*\\*。我们可以通过\n\nSELECT @@tx_isolation; 命令来查看这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ\\*\\***（可重读）\\*\\*\n\n事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如\n\nSQL Server) 是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ\\*\\***（可重\\*\\*\n\n**读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 **SERIALIZABLE(\\*\\***可串行化\\***\\*)** 隔离级\n\n别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ\u0002**\n\n**COMMITTED(\\*\\***读取提交内容\\***\\*)** ，但是你要知道的是 InnoDB 存储引擎默认使用 **REPEAaTABLE\u0002**\n\n**READ\\*\\***（可重读）\\*\\* 并不会有任何性能损失。\n\nInnoDB 存储引擎在 **分布式事务** 的情况下一般会用到 **SERIALIZABLE(\\*\\***可串行化\\***\\*)** 隔离级别。\n\n## **12\\*\\***、大表如何优化？\\*\\*\n\n当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：\n\n**1.** **限定数据的范围**\n\n务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以\n\n控制在一个月的范围内；\n\n**2.** **读\\*\\***/\\***\\*写分离**\n\n经典的数据库拆分方案，主库负责写，从库负责读；\n\n**3.** **垂直分区**\n\n**根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，\n\n可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。\n\n**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大\n\n家应该就更容易理解了。\n\n**垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的 Block 数，减少 I/O 次数。此外，垂\n\n直分区可以简化表的结构，易于维护。\n\n**垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起 Join 操作，可以通过在应用层进行\n\nJoin 来解决。此外，垂直分区会让事务变得更加复杂；\n\n**4.** **水平分区**\n\nmysql> SELECT @@tx_isolation;\n\n+-----------------+\n\n| @@tx_isolation |\n\n+-----------------+\n\n| REPEATABLE-READ |\n\n+-----------------+**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了**\n\n**分布式的目的。 水平拆分可以支撑非常大的数据量。**\n\n水平拆分是指数据表行的拆分，表的行数超过 200 万行时，就会变慢，这时可以把一张的表的数据拆成\n\n多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据\n\n量过大对性能造成影响。\n\n水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但\n\n由于表的数据还是在同一台机器上，其实对于提升 MySQL 并发能力没有什么意义，所以 **水平拆分最好**\n\n**分库** 。\n\n水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨节点 Join 性能较\n\n差，逻辑复杂。《Java 工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、**\n\n**部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题\n\n的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络 I/O。\n\n**下面补充一下数据库分片的两种常见方案：**\n\n**客户端代理： 分片逻辑在应用端，封装在\\*\\***jar\\***\\*包中，通过修改或者封装\\*\\***JDBC\\***\\*层来实现。** 当当网的\n\n**Sharding-JDBC** 、阿里的 TDDL 是两种比较常用的实现。\n\n**中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在\n\n谈的 **Mycat** 、360 的 Atlas、网易的 DDB 等等都是这种架构的实现。\n\n详细内容可以参考： MySQL 大表优化方案: https://segmentfault.com/a/1190000006158186\n\n## **13\\*\\***、分库分表之后\\***\\*,id** **主键如何处理？**\n\n因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来\n\n支持。\n\n生成全局 id 有下面这几种方式：\n\n**UUID**：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的\n\n名字的标示比如文件的名字。\n\n**数据库自增** **id** : 两台数据库分别设置不同步长，生成不重复 ID 的策略来实现高可用。这种方式生成\n\n的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。\n\n**利用** **redis** **生成** **id :** 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更\n\n加复杂，可用性降低，编码更加复杂，增加了系统成本。\n\n**Twitter\\*\\***的\\***\\*snowflake\\*\\***算法\\*\\* ：Github 地址：https://github.com/twitter-archive/snowflake。\n\n**美团的\\*\\***Leaf\\***\\*分布式\\*\\***ID\\***\\*生成系统** ：Leaf 是美团开源的分布式 ID 生成器，能保证全局唯一性、趋势递\n\n增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、\n\nZookeeper 等中间件。感觉还不错。美团技术团队的一篇文章：https://tech.meituan.com/2017/\n\n04/21/mt-leaf.html 。**14\\*\\***、\\***\\*mysql\\*\\***有关权限的表都有哪几个\\*\\*\n\nMySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里，由\n\nmysql_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和 host。下面分\n\n别介绍一下这些表的结构和内容：\n\nuser 权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。\n\ndb 权限表：记录各个帐号在各个数据库上的操作权限。\n\ntable_priv 权限表：记录数据表级的操作权限。\n\ncolumns_priv 权限表：记录数据列级的操作权限。\n\nhost 权限表：配合 db 权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受\n\nGRANT 和 REVOKE 语句的影响。\n\n## **15\\*\\***、\\***\\*mysql\\*\\***有哪些数据类型\\*\\*\n\n**1\\*\\***、整数类型\\*\\* ，包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示 1 字节、2 字节、3\n\n字节、4 字节、8 字节整数。任何整数类型都可以加上 UNSIGNED 属性，表示数据是无符号的，即非负整\n\n数。\n\n长度：整数类型可以被指定长度，例如：INT(11)表示长度为 11 的 INT 类型。长度在大多数场景是没有意\n\n义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和 UNSIGNED ZEROFILL 属性配\n\n合使用才有意义。\n\n例子，假定类型设定为 INT(5)，属性为 UNSIGNED ZEROFILL，如果用户插入的数据为 12 的话，那么数\n\n据库实际存储数据为 00012。\n\n**2\\*\\***、实数类型\\*\\*，包括 FLOAT、DOUBLE、DECIMAL。\n\nDECIMAL 可以用于存储比 BIGINT 还大的整型，能存储精确的小数。\n\n而 FLOAT 和 DOUBLE 是有取值范围的，并支持使用标准的浮点进行近似计算。\n\n计算时 FLOAT 和 DOUBLE 相比 DECIMAL 效率更高一些，DECIMAL 你可以理解成是用字符串进行处理。\n\n**3\\*\\***、字符串类型\\*\\*，包括 VARCHAR、CHAR、TEXT、BLOB\n\nVARCHAR 用于存储可变长字符串，它比定长类型更节省空间。\n\nVARCHAR 使用额外 1 或 2 个字节存储字符串长度。列长度小于 255 字节时，使用 1 字节表示，否则使用 2\n\n字节表示。\n\nVARCHAR 存储的内容超出设置的长度时，内容会被截断。\n\nCHAR 是定长的，根据定义的字符串长度分配足够的空间。\n\nCHAR 会根据需要使用空格进行填充方便比较。\n\nCHAR 适合存储很短的字符串，或者所有值都接近同一个长度。\n\nCHAR 存储的内容超出设置的长度时，内容同样会被截断。\n\n**使用策略：**\n\n对于经常变更的数据来说，CHAR 比 VARCHAR 更好，因为 CHAR 不容易产生碎片。\n\n对于非常短的列，CHAR 比 VARCHAR 在存储空间上更有效率。\n\n使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。\n\n尽量避免使用 TEXT/BLOB 类型，查询时会使用临时表，导致严重的性能开销。\n\n**4\\*\\***、枚举类型（\\***\\*ENUM\\*\\***）\\*\\*，把不重复的数据存储为一个预定义的集合。\n\n有时可以使用 ENUM 代替常用的字符串类型。\n\nENUM 存储非常紧凑，会把列表值压缩到一个或两个字节。\n\nENUM 在内部存储时，其实存的是整数。\n\n尽量避免使用数字作为 ENUM 枚举的常量，因为容易混乱。\n\n排序是按照内部存储的整数**5\\*\\***、日期和时间类型\\*\\*，尽量使用 timestamp，空间效率高于 datetime，\n\n用整数保存时间戳通常不方便处理。\n\n如果需要存储微妙，可以使用 bigint 存储。\n\n看到这里，这道真题是不是就比较容易回答了。\n\n## **16\\*\\***、创建索引的三种方式，删除索引\\*\\*\n\n第一种方式：在执行 CREATE TABLE 时创建索引\n\n第二种方式：使用 ALTER TABLE 命令去增加索引\n\nALTER TABLE 用来创建普通索引、UNIQUE 索引或 PRIMARY KEY 索引。\n\n其中 table_name 是要增加索引的表名，column_list 指出对哪些列进行索引，多列时各列之间用逗号分\n\n隔。\n\n索引名 index_name 可自己命名，缺省时，MySQL 将根据第一个索引列赋一个名称。另外，ALTER\n\nTABLE 允许在单个语句中更改多个表，因此可以在同时创建多个索引。\n\n第三种方式：使用 CREATE INDEX 命令创建\n\nCREATE INDEX 可对表增加普通索引或 UNIQUE 索引。（但是，不能创建 PRIMARY KEY 索引）\n\n删除索引\n\n根据索引名删除普通索引、唯一索引、全文索引： alter table 表名 drop KEY 索引名\n\n删除主键索引： alter table 表名 drop primary key （因为主键只有一个）。这里值得注意的是，\n\n如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：\n\nCREATE TABLE user_index2 (\n\nid INT auto_increment PRIMARY KEY,\n\nfirst_name VARCHAR (16),\n\nlast_name VARCHAR (16),\n\nid_card VARCHAR (18),\n\ninformation text,\n\nKEY name (first_name, last_name),\n\nFULLTEXT KEY (information),\n\nUNIQUE KEY (id_card)\n\n);\n\nALTER TABLE table_name ADD INDEX index_name (column_list);\n\nCREATE INDEX index_name ON table_name (column_list);\n\nalter table user_index drop KEY name;\n\nalter table user_index drop KEY id_card;\n\nalter table user_index drop KEY information;需要取消自增长再行删除：\n\n但通常不会删除主键，因为设计主键一定与业务逻辑无关。\n\n# 2、未分类\n\n## 1、你知道的 List 都有哪些？\n\nArrayList、LinkedList、Vector 等。\n\n## 2、List 和 Vector 有什么区别？\n\nVector 是 List 接口下线程安全的集合。\n\n## 3、List 是有序的吗？\n\nList 是有序的。\n\n## 4、ArrayList 和 LinkedList 的区别？分别用在什么场景？\n\nArrayList 和 LinkedList 数据结构不一样，前者用在查询较多的场合，后者适用于插入较多的\n\n场合。\n\n## 5、ArrayList 和 LinkedList 的底层数据结构是什么？\n\nArrayList 使用的是数组结构，LinkedList 使用的是链表结构。\n\n## 6、ArrayList 默认大小是多少，是如何扩容的？\n\nJdk1.7 之前 ArrayList 默认大小是 10，JDK1.7 之后是 0，JDK 差异，每次约按 1.5 倍扩容。\n\n## 7、List 是线程安全的吗？如果要线程安全要怎么做？\n\nList 中 的 Vector 才 是 线 程 安 全 的 ， 其 他 要 实 现 线 程 安 全 使 用 工 具 类\n\nCollections.synchronizedList(new ArrayList())方法。\n\n## 8、怎么给 List 排序？\n\n使用 List 自身的 sort 方法，或者使用 Collections.sort(list)方法;\n\n## 9、Arrays.asList 方法后的 List 可以扩容吗？\n\nArrays.asList 使用的是 final 数组，并且不支持 add 方法，不支持扩容。\n\n## 10、List 和 Array 之间如何互相转换？\n\nList>Array 使用 toArray 方法，Array>List 使用 Arrays.asList(array)方法，由于它是固定的，不固\n\n定的可以使用 new ArrayList(Arrays.asList(array))。\n","source":"_posts/java八股文.md","raw":"---\ntitle: java八股文\ndate: 2024-03-18 17:14:43\ntags: 面试题\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/index-read.gif\nfeature: true\n---\n\n# 1、JAVA\n\n## 一、@Resource和@Autowire注解的区别\n\n@Resource和@Autowired都是用来进行依赖注入的注解，但是它们有一些不同之处。\n\n@Autowired是Spring框架中的注解，它可以用来标注字段、构造函数、方法等，表示需要自动装配。它可以用来注入依赖的bean。如果有多个bean符合条件，可能会抛出异常。\n\n@Resource是Java自带的注解，它可以用来标注字段、方法等，表示需要自动装配。它可以用来注入依赖的bean。如果有多个bean符合条件，会按照名称进行匹配。\n\n总结:\n\n@Autowired 是 Spring 框架中的注解，用来标注需要自动装配的 bean。\n@Resource 是 Java 自带的注解，用来标注需要自动装配的 bean。\n@Autowired 是按类型装配，如果有多个同类型的 bean，会抛出异常； @Resource 是按名称装配，如果名称不存在，会使用类型装配。\n\n## 2、重载与重写区别    难度系数：⭐\n\n1. 重载发生在本类，重写发生在父类与子类之间\n2. 重载的方法名必须相同，重写的方法名相同且返回值类型必须相同\n3. 重载的参数列表不同，重写的参数列表必须相同\n4. 重写的访问权限不能比父类中被重写的方法的访问权限更低\n5. 构造方法不能被重写\n\n## 12、普通类和抽象类有哪些区别？★★★★★\n\n抽象类不能被实例化；\n抽象类可以有抽象方法，只需申明，无须实现；\n有抽象方法的类一定是抽象类；\n抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类；\n抽象方法不能声明为静态、不能被static、final修饰。\n\n## 13、接口和抽象类有什么区别？★★★★★\n\n（1）接口\n\n接口使用interface修饰；\n接口不能实例化；\n类可以实现多个接口；\n\n①java8之前，接口中的方法都是抽象方法，省略了public abstract。②java8之后；接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；\n\n（2）抽象类\n\n抽象类使用abstract修饰；\n抽象类不能被实例化；\n抽象类只能单继承；\n抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体；\n如果一个类继承了抽象类，①如果实现了所有的抽象方法，子类可以不是抽象类；②如果没有实现所有的抽象方法，子类仍然是抽象类。\n\n共同点 不能实例化；\n\n不同点 接口使用interface修饰；抽象类使用abstract修饰；\n\n## 6、String、StringBuffer、StringBuilder 有什么区别？★★★★★\n\nString、StringBuffer、StringBuilder 最大的不同是 String 不可变，后者可变。StringBuffer 是线\n\n程安全的，StringBuilder 线程不安全速度较快。\n\n## 7、String.trim()方法去掉的是哪些字符？\n\ntrim 去掉字符串首尾的空白字符。\n\n## 8、String 可以被子类继承吗？\n\n既然 String 是 final 的，所以不能被继承。\n\n## 9、可以自定义 java.lang.String 类并使用吗？\n\n可以自定义 java.lang.String 类并编译成功，但不能被加载使用，具体请学习类加载机制。\n\n## 10、String 与 byte[]两者相互之间如何转换？\n\nString > byte[] 通过 String 类的 getBytes 方法；byte[] > String 通过 new String(byte[])构造器。\n\n## 11、==和 equals ⽅法的区别\n\n==：如果是基本数据类型，⽐较是值，如果是引⽤类型，⽐较的是引⽤地址\n\nequals：具体看各个类重写 equals ⽅法之后的⽐较逻辑，⽐如 String 类，虽然是引⽤类型，但是 String 类中重写了 equals ⽅法，⽅法内部⽐较的是字符串中的各个字符是否全部相等。\n\n### 2、== 和 [equals](https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020) 的区别是什么？\n\n1. 对于基本类型，==比较的是值；\n2. 对于引用类型，==比较的是地址；\n3. equals不能用于基本类型的比较；\n4. 如果没有重写equals，equals就相当于==；\n5. 如果重写了equals方法，equals比较的是对象的内容；\n\n## 12、 hashCode()与 equals()之间的关系★★★★★\n\n6 在 Java 中，每个对象都可以调⽤⾃⼰的 hashCode()⽅法得到⾃⼰的哈希值(hashCode)，相当于对象的 指纹信息，通常来说世界上没有完全相同的两个指纹，但是在 Java 中做不到这么绝对，但是我们仍然可 以利⽤ hashCode 来做⼀些提前的判断，⽐如： 如果两个对象的 hashCode 不相同，那么这两个对象肯定不同的两个对象 如果两个对象的 hashCode 相同，不代表这两个对象⼀定是同⼀个对象，也可能是两个对象 如果两个对象相等，那么他们的 hashCode 就⼀定相同 在 Java 的⼀些集合类的实现中，在⽐较两个对象是否相等时，会根据上⾯的原则，会先调⽤对象的 hashCode()⽅法得到 hashCode 进⾏⽐较，如果 hashCode 不相同，就可以直接认为这两个对象不相 同，如果 hashCode 相同，那么就会进⼀步调⽤ equals()⽅法进⾏⽐较。⽽ equals()⽅法，就是⽤来最终 确定两个对象是不是相等的，通常 equals ⽅法的实现会⽐较重，逻辑⽐较多，⽽ hashCode()主要就是得 到⼀个哈希值，实际上就⼀个数字，相对⽽⾔⽐较轻，所以在⽐较两个对象时，通常都会先根据 hashCode 想⽐较⼀下。 所以我们就需要注意，如果我们重写了 equals()⽅法，那么就要注意 hashCode()⽅法，⼀定要保证能遵 守上述规则。\n\n13、重载和重写的区别\n\n- 重载是指在一个类中定义了多个同名的方法，但他们的参数列表是不同的\n- 子[类继承](https://so.csdn.net/so/search?q=%E7%B1%BB%E7%BB%A7%E6%89%BF&spm=1001.2101.3001.7020)父类，子类重写父类中的所有公共方法，覆盖父类的方法并对其重写。\n\n重载\n\n```java\npublic static int add(int x, int y) {\n        return x + y;\n    }\n    public static double add(int x, int y) {\n        return x + y;\n    }\n```\n\n重写\n\n```java\nclass Animal {\n    public void eat(String food) {\n \t\t...\n    }\n}\n\nclass Bird extends Animal {\n    @Override\n    public void eat(String food) {\n\t\t...\n    }\n```\n\n## 13、String、StringBuffer 和 StringBuilder 的区别是什 么?★★★★★\n\nstring 不可变 线程安全 操作少量数据或不操作数据 是个对象 消耗内存性能底\n\nStringBuffer 不可变 线程不安全 频繁操作数据 不考虑线程安全\n\nStringBuilder 不可变 线程安全 频繁操作数据 考虑线程安全 +了 synchronizd(锁)\n\n## 14、 Java 创建对象有几种方式？★★★★★\n\njava 中提供了以下四种创建对象的方式:\n\n1. new 创建新对象\n2. 通过反射机制\n3. 采用 clone 机制\n4. 通过序列化机制\n\n15、 有没有可能两个不相等的对象有相同的 hashcode\n\n有可能.在产生 hash 冲突时,两个不相等的对象就会有相同的 hashcode 值.当 hash 冲突产生时,一般有以 下几种方式来处理:\n\n拉链法:每个哈希表节点都有一个 next 指针,多个哈希表节点可以用 next 指针构成一个单向链表，被 分配到同一个索引上的多个节点可以用这个单向链表进行存储.\n\n开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找 到,并将记录存入\n\n再哈希:又叫双哈希法,有多个不同的 Hash 函数.当发生冲突时,使用第二个,第三个….等哈希函数计算 地址,直到无冲突\n\n## 15、 深拷贝和浅拷贝的区别是什么?★★★★★\n\n### 深拷贝和浅拷贝\n\n深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。\n\n浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象\n深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象\n浅拷贝: 基本数据类型+实例对象的地址(这时浅拷贝的两个实例对象地址是同一个, 也就是同一个实例); 深拷贝: 基本数据类型+实例对象地址下的数据(也就是将实例对象也拷贝了一份)\n\n浅拷贝:被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向 原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.\n\n深拷贝:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被 复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都 复制了一遍.\n\n深拷⻉和浅拷⻉就是指对象的拷⻉，⼀个对象中存在两种类型的属性，⼀种是基本数据类型，⼀种是实 例对象的引⽤。 1. 浅拷⻉是指，只会拷⻉基本数据类型的值，以及实例对象的引⽤地址，并不会复制⼀份引⽤地址所 指向的对象，也就是浅拷⻉出来的对象，内部的类属性指向的是同⼀个对象 2. 深拷⻉是指，既会拷⻉基本数据类型的值，也会针对实例对象的引⽤地址所指向的对象进⾏复制， 深拷⻉出来的对象，内部的属性指向的不是同⼀个对象\n\n## 16、 final 有哪些用法? ★★★★★\n\n被 final 修饰的类不可以被继承\n\n被 final 修饰的方法不可以被重写\n\n被 final 修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.\n\n被 final 修饰的方法,JVM 会尝试将其内联,以提高运行效率 被 final 修饰的常量,在编译阶段会存入常量池中.\n\n修饰类：表示类不可被继承 修饰方法：表示方法不可被子类覆盖，但是可以重载 修饰变量：表示变量一旦被赋值就不可以更改它的值。 （1）修饰成员变量 如果 final 修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。 如果 final 修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。\n\nfinal 在 java 中有什么作用？\n（1）用来修饰一个引用\n\n如果引用为基本数据类型，则该引用为常量，该值无法修改；\n如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。\n如果引用时类的成员变量，则必须当场赋值，否则编译会报错。\n（2）用来修饰一个方法\n\n当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。\n\n（3）用来修饰类\n\n当用final修改类时，该类成为最终类，无法被继承。\n\n比如常用的String类就是最终类。\n\n## 7、如何将字符串反转？\n\n将对象封装到stringBuilder中，调用reverse方法反转。\n\n![1709658384085](images/1、JAVA/1709658384085.png)\n\n## 16、 3\\*0.1 == 0.3 返回值是什么\n\nfalse,因为有些浮点数不能完全精确的表示出来.\n\n## 17 Java 中有哪些类加载器★★★★★\n\nJDK ⾃带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。 BootStrapClassLoader 是 ExtClassLoader 的⽗类加载器，默认负责加载%JAVA_HOME%lib 下的 jar 包和 class ⽂件。 ExtClassLoader 是 AppClassLoader 的⽗类加载器，负责加载%JAVA_HOME%/lib/ext ⽂件夹下的 jar 包和 class 类。 AppClassLoader 是⾃定义类加载器的⽗类，负责加载 classpath 下的类⽂件\n\n## 16.hashCode()和 equals()方法有何重要性？★★★★★\n\n### ★★★★★\n\nHashMap 使用 Key 对象的 hashCode()和 equals()方法去决定 key-value 对的索引。点击这里一\n\n文搞懂它们之间的关系。\n\n当我们试着从 HashMap 中获取值的时候，这些方法也会被用到。如果这些方法没有被正确\n\n地实现，在这种情况下，两个不同 Key 也许会产生相同的 hashCode()和 equals()输出，HashMap\n\n将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。\n\n同样的，所有不允许存储重复数据的集合类都使用 hashCode()和 equals()去查找重复，所以\n\n正确实现它们非常重要。equals()和 hashCode()的实现应该遵循以下规则：\n\n1.如果 o1.equals(o2)，那么 o1.hashCode() == o2.hashCode()总是为 true 的。\n\n2.如果 o1.hashCode() == o2.hashCode()，并不意味着 o1.equals(o2)会为 true。\n\n## 17.Map 接口提供了哪些不同的集合视图？\n\nMap 接口提供三个集合视图：\n\n1）Set keyset()：返回 map 中包含的所有 key 的一个 Set 视图。集合是受 map 支持的，map\n\n的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若 map 被修\n\n改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过 Iterator\n\n更多关注 Java 大后端公众号的 Remove、Set.remove、removeAll、retainAll 和 clear 操作进行元素移除，从 map 中移除对\n\n应的映射。\n\n它不支持 add 和 addAll 操作。\n\n2）Collection values()：返回一个 map 中包含的所有 value 的一个 Collection 视图。这个 collection\n\n受 map 支持的，map 的变化会在 collection 中反映出来，反之亦然。当一个迭代器正在遍历\n\n一个 collection 时，若 map 被修改了（除迭代器自身的移除操作以外），迭代器的结果会变\n\n为未定义。集合支持通过 Iterator 的 Remove、Set.remove、removeAll、retainAll 和 clear 操作\n\n进行元素移除，从 map 中移除对应的映射。它不支持 add 和 addAll 操作。\n\n3）Set<Map.Entry<K,V>> entrySet()：返回一个 map 钟包含的所有映射的一个集合视图。这个\n\n集合受 map 支持的，map 的变化会在 collection 中反映出来，反之亦然。当一个迭代器正在\n\n遍历一个集合时，若 map 被修改了（除迭代器自身的移除操作，以及对迭代器返回的 entry\n\n进行 setValue 外），迭代器的结果会变为未定义。集合支持通过 Iterator 的 Remove、Set.remove、\n\nremoveAll、retainAll 和 clear 操作进行元素移除，从 map 中移除对应的映射。它不支持 add\n\n和 addAll 操作。\n\n## hashCode与equals★★★★★\n\nhashCode介绍：\nhashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是\n确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有\nhashCode() 函数。\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用\n到了散列码！（可以快速找到所需要的对象）\n为什么要有hashCode：\n以“HashSet如何检查重复”为例子来说明为什么要有hashCode：\n对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有\n值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals（）方法来\n检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会\n重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。\n如果两个对象相等，则hashcode一定也是相同的\n两个对象相等,对两个对象分别调用equals方法都返回true\n两个对象有相同的hashcode值，它们也不一定是相等的\n因此，equals方法被覆盖过，则hashCode方法也必须被覆盖\n***hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则******该class的两个\n对象无论如何都不会相等（即使这两个对象指向相同的数据）***\n\n## 18.HashMap 和 HashTable 有何不同？\n\n（1）HashMap 允许 key 和 value 为 null，而 HashTable 不允许。\n\n（2）HashTable 是同步的，而 HashMap 不是。所以 HashMap 适合单线程环境，HashTable\n\n适合多线程环境。\n\n（3）在 Java1.4 中引入了 LinkedHashMap，HashMap 的一个子类，假如你想要遍历顺序，你\n\n很容易从 HashMap 转向 LinkedHashMap，但是 HashTable 不是这样的，它的顺序是不可预知\n\n的。\n\n（4）HashMap 提供对 key 的 Set 进行遍历，因此它是 fail-fast 的，但 HashTable 提供对 key\n\n的 Enumeration 进行遍历，它不支持 fail-fast。\n\n（5）HashTable 被认为是个遗留的类，如果你寻求在迭代的时候修改 Map，你应该使用\n\nCocurrentHashMap。\n\n# 集合\n\n## [[java集合超详解\\_java集合使用-CSDN博客](https://blog.csdn.net/feiyanaffection/article/details/81394745)]\n\n![1709657326301](images/1、JAVA/1709657326301.png)\n\n![1709657362460](images/1、JAVA/1709657362460.png)\n\n![1709657394941](images/1、JAVA/1709657394941.png)\n\n![1709205810985](images/1、JAVA/1709205810985.png)\n\n[Set](https://pdai.tech/md/java/collection/java-collection-all.html#set)\n\n* [TreeSet](https://pdai.tech/md/java/collection/java-collection-all.html#treeset)\n* [HashSet](https://pdai.tech/md/java/collection/java-collection-all.html#hashset)\n* [LinkedHashSet](https://pdai.tech/md/java/collection/java-collection-all.html#linkedhashset)\n\n[List](https://pdai.tech/md/java/collection/java-collection-all.html#list)\n\n* [ArrayList ](https://pdai.tech/md/java/collection/java-collection-all.html#arraylist)\n* [Vector](https://pdai.tech/md/java/collection/java-collection-all.html#vector)\n* [LinkedList](https://pdai.tech/md/java/collection/java-collection-all.html#linkedlist)\n\n[Queue](https://pdai.tech/md/java/collection/java-collection-all.html#queue)\n\n* [LinkedList](https://pdai.tech/md/java/collection/java-collection-all.html#linkedlist-1)\n* [PriorityQueue](https://pdai.tech/md/java/collection/java-collection-all.html#priorityqueue)\n\n[Map](https://pdai.tech/md/java/collection/java-collection-all.html#map)\n\n* [TreeMap](https://pdai.tech/md/java/collection/java-collection-all.html#treemap)\n* [HashMap](https://pdai.tech/md/java/collection/java-collection-all.html#hashmap)\n* [HashTable](https://pdai.tech/md/java/collection/java-collection-all.html#hashtable)\n* [LinkedHashMap](https://pdai.tech/md/java/collection/java-collection-all.html#linkedhashmap)\n\nlist\n\nArrayList     底层数据结构是动态数组，查询快，增删慢。线程不安全，效率高\n\nVector       底层数据结构是数组，查询快，增删慢。线程安全，效率低\n\nLinkedList 底层数据结构是链表，查询慢，增删快 线程不安全，效率高\n\nset\n\nTreeset 红黑树\n\nHashset\n\n* 底层其实是包装了一个HashMap实现的\n* 底层数据结构是数组+链表 + 红黑树\n* 具有比较好的读取和查找性能， 可以有null 值\n* 通过equals和HashCode来判断两个元素是否相等\n* 非线程安全\n\nLinedHashkset\n\n* 继承HashSet，本质是LinkedHashMap实现\n* 底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。\n* 有序的，根据HashCode的值来决定元素的存储位置，同时使用一个链表来维护元素的插入顺序\n* 非线程安全，可以有null 值\n\nmap\n\n![1709208051453](images/1、JAVA/1709208051453.png)\n\nHashmap 哈希表\n\n特点是访问速度快，遍历顺序不确定，线程不安全，最多允许一个key为null，允许多个value为null。\n\n* 可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap类。\n\nTreemap 红黑树\n\n* TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。\n\nLinkedHashmap 双向链表\n\n* LinkedHashMap继承了HashMap，是Map接口的哈希表和链接列表实现，它维护着一个双重链接列表，此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。\n\nHashTable\n\nHashmap底层原理\n\n**HashMap的底层是数组+链表+红黑树实现的。集合put时，通过计算key键的哈希值来放入元素。若有key值相同的哈希值时，会通过链表进行存放，链表长度达到8时会开辟红黑树进行存放，以此提高查询效率**..\n\n## ArrayList 和 Vector 有何异同点？\n\n**ArrayList 和 Vector 在很多时候都很类似。**\n\n（1）两者都是基于索引的，内部由一个数组支持。\n\n（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。\n\n（3）ArrayList 和 Vector 的迭代器实现都是 fail-fast 的。\n\n（4）ArrayList 和 Vector 两者允许 null 值，也可以使用索引值对元素进行随机访问。\n\n**以下是 ArrayList 和 Vector 的不同点。**\n\n（1）Vector 是同步的，而 ArrayList 不是。然而，如果你寻求在迭代的时候对列表进行改变，\n\n你应该使用 CopyOnWriteArrayList。\n\n（2）ArrayList 比 Vector 快，它因为有同步，不会过载。\n\n（3）ArrayList 更加通用，因为我们可以使用 Collections 工具类轻易地获取同步列表和只读\n\n列表。\n\n## ArrayList 和 LinkedList 有何区别？\n\n![1709479433567](images/1、JAVA/1709479433567.png)\n\nArrayList 和 LinkedList 两者都实现了 List 接口，但是它们之间有些不同。\n\n1）ArrayList 是由 Array 所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，\n\n复杂度为 O(1)，但 LinkedList 存储一系列的节点数据，每个节点都与前一个和下一个节点相\n\n连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引\n\n的节点然后返回元素，时间复杂度为 O(n)，比 ArrayList 要慢。\n\n2）与 ArrayList 相比，在 LinkedList 中插入、添加和删除一个元素会更快，因为在一个元素被\n\n插入到中间的时候，不会涉及改变数组的大小，或更新索引。\n\n3）LinkedList 比 ArrayList 消耗更多的内存，因为 LinkedList 中的每个节点存储了前后节点的\n\n引用。\n\n.哪些集合类提供对元素的随机访问？\n\nArrayList、HashMap、TreeMap 和 HashTable 类提供对元素的随机访问。\n\n24.哪些集合类是线程安全的？\n\nVector、HashTable、Properties 和 Stack 是同步类，所以它们是线程安全的，可以在多线程环\n\n境下使用。Java1.5 并发 API 包括一些集合类，允许迭代时修改，因为它们都工作在集合的\n\n克隆上，所以它们在多线程环境中是安全的。\n\n## HashMap 和 HashSet 区别\n\n![1709211409103](images/1、JAVA/1709211409103.png)\n\n## 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同\n\nHashSet 是 Set 接口的主要实现类 ，HashSet 的底层是 HashMap，线程不安全的，可以存储 null\n值；\nLinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历；\nTreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。\n\n# 2、多线程\n\n## sleep(), wait(), join(), yield()区别★★★★★\n\nsleep()和wait\nsleep()方法是Thread类的静态本地方法, wait()则是Object类的本地方法(where)\nsleep一般用于当前线程休眠，或者轮循暂停操作，wait则多用于多线程之间的通信。(作用)\nsleep方法不依赖于同步器synchronized, 但是wait需要依赖synchronized(依赖)\nsleep方法不会释放锁, 但是wait会释放锁(锁)\nsleep不需要被唤醒（休眠之后推出阻塞)，但是wait需要〈不指定时间需要被别人中断)。(醒)\nwhere 作用 依赖 锁 醒\n\nyield\nyield()执行后线程直接进入就绪状态, 马上释放cpu执行权, 但是依然保留cpu的执行资格, 所以cpu下次进行线程调度还可能会让这个线程去的执行权\njoin()执行后线程进入阻塞状态, 例如在线程B中调用线程A的join(), 那线程B会进入阻塞队列, 直到线程A结束或中断结束\n例如t1线程正在执行, t2线程调用了t1.join(), 那线程B就会立即进入阻塞队列, 直到线程A结束或者中断线程\n\n## 线程同步方式\n\n1、Java通过加锁实现线程同步,锁有两类：synchronized和Lock。  2、synchronized加在三个不同的位置,对应三种不同的使用方式,这三种方式的区别是锁对象不同：  （1.）加在普通方法上,则锁是当前的实例（this）。 （2.）加在静态方法上,锁是当前类的Class对象。 （3.）加在代码块上,则需要在关键字后面的小括号里,显式指定一个对象作为锁对象。\n\n## 并发的三大特性\n\n原子性 原子性是指在一个操作中 cpu 不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要 不都不执行。\n\n可见性 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n有序性 虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按 照我们写的代码 的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，虽然对 变量的值没有造成影响，但有可能会出现线程安全问题。\n\n## 线程有几种状态\n\n![1709658004796](images/1、JAVA/1709658004796.png)\n\n1.线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。\n\n2.阻塞的情况又分为三种：\n\n(1)、等待阻塞：运行的线程执行 wait 方法，该线程会释放占用的所有资源，JVM 会把该线程放入“等待 池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用 notify 或 notifyAll 方法才能被唤 醒，wait 是 object 类的方法\n\n(2)、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放 入“锁池”中。\n\n(3)、其他阻塞：运行的线程执行 sleep 或 join 方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状 态。当 sleep 状态超时、join 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。 sleep 是 Thread 类的方法 1.新建状态（New）：新创建了一个线程对象。 2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的 start 方法。该状态的线程位于 可运行线程池中，变得可运行，等待获取 CPU 的使用权。 3.运行状态（Running）：就绪状态的线程获取了 CPU，执行程序代码。\n\n4.阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进 入就绪状态，才有机会转到运行状态。 5.死亡状态（Dead）：线程执行完了或者因异常退出了 run 方法，该线程结束生命周期\n\n## juc是什么\n\nJUC即java.util.concurrent,包含了支持并发操作的各种工具。\n\n## \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n# 3、Nginx\n\n## **1、请解释一下什么是 Nginx?**\n\nNginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3 和\n\nIMAP 协议。\n\n## **2、请列举 Nginx 的一些特性。**\n\nNginx 服务器的特性包括：\n\n反向代理/L7 负载均衡器\n\n嵌入式 Perl 解释器\n\n动态二进制升级\n\n可用于重新编写 URL，具有非常好的 PCRE 支持\n\n## **3、请列举 Nginx 和 Apache 之间的不同点**\n\n## **4、请解释 Nginx 如何处理 HTTP 请求。**\n\nNginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数\n\n据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提\n\n供数万个并发连接。\n\n## **5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?**\n\n只需将请求删除的服务器就可以定义为：\n\nServer {listen 80;server_name “ “ ;return 444;\n\n}\n\n这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下匹\n\n配请求，而一个特殊的 Nginx 的非标准代码 444 被返回，从而终止连接。\n\n## **6、 使用“反向代理服务器”的优点是什么?**\n\n更多关注 Java 大后端公众号更多关注 Java 大后端公众号\n\n反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器\n\n之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服务时。\n\n## **7、请列举 Nginx 服务器的最佳用途。**\n\nNginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应用\n\n程序服务器、用于脚本的 FastCGI 处理程序。它还可以作为负载均衡器。\n\n## **8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?**\n\nMaster 进程：读取及评估配置和维持\n\nWorker 进程：处理请求\n\n## **9、请解释你如何通过不同于 80 的端口开启 Nginx?**\n\n为了通过一个不同的端口开启 Nginx，你必须进入/etc/Nginx/sites-enabled/，\n\n如果这是默认文件，那么你必须打开名为“default”的文件。编辑文件，并放\n\n置在你想要的端口：\n\nLike server { listen 81; }\n\n## **10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?**\n\n502 =错误网关\n\n503 =服务器超载\n\n有可能，但是您可以确保 fastcgi_intercept_errors 被设置为 ON，并使用错误\n\n页面指令。\n\nLocation / {fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors\n\non;error_page 502 =503/error_page.html;#…}\n\n## **11、在 Nginx 中，解释如何在 URL 中保留双斜线?**\n\n要在 URL 中保留双斜线，就必须使用 merge_slashes_off;\n\n语法:merge_slashes [on/off]更多关注 Java 大后端公众号\n\n默认值: merge_slashes on\n\n环境: http，server\n\n## **12、请解释 ngx_http_upstream_module 的作用是什么?**\n\nngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi\n\n传递、memcached 传递和 scgi 传递指令来引用的服务器组。\n\n## **13、请解释什么是 C10K 问题?**\n\nC10K 问题是指无法同时处理大量客户端(10,000)的网络套接字。\n\n## **14、请陈述 stub_status 和 sub_filter 指令的作用是什么?**\n\nStub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活动\n\n连接，接受和处理当前读/写/等待连接的总数\n\nSub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据\n\n## **15、解释 Nginx 是否支持将请求压缩到上游?**\n\n您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤器，\n\n它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编码:gzip”来\n\n解压缩响应。\n\n## **16、解释如何在 Nginx 中获得当前的时间?**\n\n要获得 Nginx 的当前时间，必须使用 SSI 模块、$date_gmt 和$date_local 的变\n\n量。\n\nProxy_set_header THE-TIME $date_gmt;\n\n## **17、用 Nginx 服务器解释-s 的目的是什么?**\n\n用于运行 Nginx -s 参数的可执行文件。\n\n## **18、解释如何在 Nginx 服务器上添加模块?**\n\n在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选择。\n\n## \\\\\\\\\\\\\\\\\n\n1、请解释一下什么是 Nginx?\n\nNginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3\n\n和 IMAP 协议。\n\n2、请列举 Nginx 的一些特性。\n\nNginx 服务器的特性包括：\n\n反向代理/L7 负载均衡器\n\n嵌入式 Perl 解释器\n\n动态二进制升级\n\n可用于重新编写 URL，具有非常好的 PCRE 支持\n\n3、请列举 Nginx 和 Apache 之间的不同点\n\n4、请解释 Nginx 如何处理 HTTP 请求。\n\nNginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样\n\n数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可\n\n以提供数万个并发连接。\n\n5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?\n\n只需将请求删除的服务器就可以定义为：\n\nServer {listen 80;server_name “ “ ;return 444;\n\n}\n\n这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下\n\n匹配请求，而一个特殊的 Nginx 的非标准代码 444 被返回，从而终止连接。\n\n6、 使用“反向代理服务器”的优点是什么?\n\n反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务\n\n器之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服\n\n务时。\n\n7、请列举 Nginx 服务器的最佳用途。Nginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应\n\n用程序服务器、用于脚本的 FastCGI 处理程序。它还可以作为负载均衡器。\n\n8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?\n\nMaster 进程：读取及评估配置和维持\n\nWorker 进程：处理请求\n\n9、请解释你如何通过不同于 80 的端口开启 Nginx?\n\n为了通过一个不同的端口开启 Nginx，你必须进入/etc/Nginx/sites\u0002\n\nenabled/，如果这是默认文件，那么你必须打开名为“default”的文件。编辑\n\n文件，并放置在你想要的端口：\n\nLike server { listen 81; }\n\n10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?\n\n502 =错误网关\n\n503 =服务器超载\n\n有可能，但是您可以确保 fastcgi_intercept_errors 被设置为 ON，并使用错\n\n误页面指令。\n\nLocation / {fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors\n\non;error_page 502 =503/error_page.html;#…}\n\n11、在 Nginx 中，解释如何在 URL 中保留双斜线?\n\n要在 URL 中保留双斜线，就必须使用 merge_slashes_off;\n\n语法:merge_slashes [on/off]\n\n默认值: merge_slashes on\n\n环境: http，server\n\n12、请解释 ngx_http_upstream_module 的作用是什么?\n\nngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi\n\n传递、memcached 传递和 scgi 传递指令来引用的服务器组。\n\n13、请解释什么是 C10K 问题?C10K 问题是指无法同时处理大量客户端(10,000)的网络套接字。\n\n14、请陈述 stub_status 和 sub_filter 指令的作用是什么?\n\nStub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活\n\n动连接，接受和处理当前读/写/等待连接的总数\n\nSub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据\n\n15、解释 Nginx 是否支持将请求压缩到上游?\n\n您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤\n\n器，它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编\n\n码:gzip”来解压缩响应。\n\n16、解释如何在 Nginx 中获得当前的时间?\n\n要获得 Nginx 的当前时间，必须使用 SSI 模块、\\$date_gmt 和\\$date_local 的变\n\n量。\n\nProxy_set_header THE-TIME \\$date_gmt;\n\n17、用 Nginx 服务器解释-s 的目的是什么?\n\n用于运行 Nginx -s 参数的可执行文件。\n\n18、解释如何在 Nginx 服务器上添加模块?\n\n在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选\n\n择。\n\n# 4、spring\n\n## 1、springboot\n\n### **1、什么是 Spring Boot？**\n\nSpring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是\n\n简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。\n\n更多 Spring Boot 详细介绍请看这篇文章《什么是 Spring Boot?》。\n\n### **2、为什么要用 Spring Boot？**\n\nSpring Boot 优点非常多，如：\n\n![1709736051227](images/1、JAVA/1709736051227.png)\n\n 独立运行\n\n 简化配置\n\n 自动配置\n\n 无代码生成和 XML 配置\n\n 应用监控\n\n 上手容易\n\nSpring Boot 集这么多优点于一身，还有理由不使用它呢？\n\n### **5、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？**\n\n启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要\n\n组合包含了以下 3 个注解：\n\n@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。\n\n@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，\n\n如关闭数据源自动配置功能： @SpringBootApplication(exclude =\n\n{ DataSourceAutoConfiguration.class })。\n\n@ComponentScan：Spring 组件扫描。\n\n### **6、开启 Spring Boot 特性有哪几种方式？**\n\n1）继承 spring-boot-starter-parent 项目\n\n2）导入 spring-boot-dependencies 项目依赖\n\n具体请参考这篇文章《Spring Boot 开启的 2 种方式》。\n\n更多关注 Java 大后端公众号**7、Spring Boot 需要独立的容器运行吗？**\n\n可以不需要，内置了 Tomcat/ Jetty 等容器。\n\n### **8、运行 Spring Boot 有哪几种方式？**\n\n1）打包用命令或者放到容器中运行\n\n2）用 Maven/ Gradle 插件运行\n\n3）直接执行 main 方法运行\n\n### **9、Spring Boot 自动配置原理是什么？**\n\n注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动\n\n配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。\n\nSpring Boot 自动配置原理？\n\n@Import + @Configuration + Spring spi 图灵学院 自动配置类由各个 starter 提供，使用@Configuration + @Bean 定义配置类，放到 META\u0002INF/spring.factories 下 使用 Spring spi 扫描 META-INF/spring.factories 下的配置类 使用@Import 导入自动配置类具体看这篇文章《Spring Boot 自动配置原理、实战》。\n\n## 2、spring MVC\n\n### 1、什么是 SpringMvc？\n\n答：SpringMvc 是 spring 的一个模块，基于 MVC 的一个框架，无需中间整合层来整合。\n\n### 2、Spring MVC 的优点：\n\n答：\n\n1）它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java\n\n组件.并且和 Spring 提供的其他基础结构紧密集成.\n\n2）不依赖于 Servlet API(目标虽是如此,但是在实现的时候确实是依赖于 Servlet 的)\n\n3）可以任意使用各种视图技术,而不仅仅局限于 JSP\n\n4）支持各种请求资源的映射策略\n\n5）它应是易于扩展的\n\n### 3、SpringMVC 工作原理？\n\n答：\n\n1）客户端发送请求到 DispatcherServlet\n\n2）DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller\n\n3）Controller 调用业务逻辑后，返回 ModelAndView\n\n4）DispatcherServlet 查询 ModelAndView，找到指定视图\n\n5）视图将结果返回到客户端\n\n### 4、SpringMVC 流程？★★★★★\n\n1）用户发送请求至前端控制器 DispatcherServlet。\n\n2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。\n\n3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器对象\n\n及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。\n\n更多关注 Java 大后端公众号 4）DispatcherServlet 调用 HandlerAdapter 处理器适配器。\n\n5）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)。\n\n6）Controller 执行完成返回 ModelAndView。\n\n7）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。\n\n8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。\n\n9）ViewReslover 解析后返回具体 View。\n\n10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。\n\n11）DispatcherServlet 响应用户。\n\n## 3、spring\n\n![1709742703501](images/1、JAVA/1709742703501.png)\n\n## BeanFactory和ApplicationContext有什么区别(不熟)\n\nApplicationContext接口作为BeanFactory的子类,除了提供BeanFactory所具有的功能外,还提供了更完整的框架功能:\n①继承MessageSource,因此支持国际化\n②资源文件访问，如URL和文件（ResourceLoader）\n③载入多个（有继承关系）上下文（及同时加载多个配置文件），使得每一个上下文都专注于一个特定的层次\n④提供在监听器中注册bean的事件；\n\n## Spring是什么\n\nSpring 是一个轻量级的控制翻转(IOC)和面向切面(AOP)的容器框架\n\n从大小与开销两方面而言Spring都是轻量级的\n\n包含并且管理Bean的配置和生命周期,又通过控制反转和依赖注入来达到松耦合, 在这个意义上是一个Bean容器,\n\n提供了面向切面编程的丰富支持, 允许通过分离应用的业务逻辑和系统级 服务进行内聚性的开发\n将简单的组件配置, 组合为复杂的应用, 这个意义上是一个框架\n谈谈你对AOP的理解\n系统是由许多不同的组件所组成的, 每一个组件各负责着一些功能, 除了主要业务功能之外, 有些组件比如日志, 事务管理和安全等服务会水平散布到所有对象层次中去,\nOOP运行从上到下的关系但是并不适合定义从左到右的关系, 所以如果仍然按照OOP设计就会有大量代码的重复; 如果使用AOP就会将这些功能封装为一个切面, 然后注入到目标对象中, 而且AOP还可以对对象进行增强, 去做一些额外的事情.\n谈谈你对IOC的理解\n容器概念, 控制翻转, 依赖注入\n\n(容器概念)IOC容器中存有自己配置获取的一些Bean(比如@Repository, @Service, @Controller), 在项目启动时使用反射创建对应的对象放到map中 ;(依赖注入) 这时候map中就有各种对象了, 接下来通过bean的配置文件中去获取xml文件中该bean节点下的, 根据其ref属性进行依赖注入, 注入到对应的注解下(@Autowired或者@Resource)\n控制翻转: 控制翻转就是一个概念, 就是对象通过IOC容器和依赖注入自动进行装配, 就相当于原本属于程序员对对象创建的控制权交给了IOC\n总结来说, 就是IOC通过容器概念, 控制翻转和依赖注入成为了整个系统的关键核心, 它起到一种类似\"粘合剂\"的作用, 把系统中的所有对象粘合起来一起发挥作用.\n\n## 12.spring用了哪些设计模式\n\nBeanFactory用了工厂模式，AOP用了动态代理模式，RestTemplate用来模板方法模式，SpringMVC中handlerAdaper用来适配器模式，Spring里的监听器用了观察者模式\n\n## 14.SpringMV工作原理★★★★★\n\nSpringMVC工作过程围绕着前端控制器DispatchServerlet，几个重要组件有HandleMapping（处理器映射器）、HandleAdapter（处理器适配器）、ViewReslover（试图解析器）\n\n工作流程：\n\n（1）DispatchServerlet接收用户请求将请求发送给HandleMapping\n\n（2）HandleMapping根据请求url找到具体的handle和拦截器，返回给DispatchServerlet\n\n（3）DispatchServerlet调用HandleAdapter,HandleAdapter执行具体的controller，并将controller返回的ModelAndView返回给DispatchServler\n\n（4）DispatchServerlet将ModelAndView传给ViewReslover,ViewReslover解析后返回具体view\n\n（5）DispatchServerlet根据view进行视图渲染，返回给用户\n\n## 谈谈你对AOP的理解★★★★★\n\n系统是由许多不同的组件所组成的, 每一个组件各负责着一些功能, 除了主要业务功能之外, 有些组件比如日志, 事务管理和安全等服务会水平散布到所有对象层次中去,\nOOP运行从上到下的关系但是并不适合定义从左到右的关系, 所以如果仍然按照OOP设计就会有大量代码的重复; 如果使用AOP就会将这些功能封装为一个切面, 然后注入到目标对象中, 而且AOP还可以对对象进行增强, 去做一些额外的事情.\n\n## 谈谈你对IOC的理解★★★★★\n\n容器概念, 控制翻转, 依赖注入\n\n(容器概念)IOC容器中存有自己配置获取的一些Bean(比如@Repository, @Service, @Controller), 在项目启动时使用反射创建对应的对象放到map中 ;(依赖注入) 这时候map中就有各种对象了, 接下来通过bean的配置文件中去获取xml文件中该bean节点下的, 根据其ref属性进行依赖注入, 注入到对应的注解下(@Autowired或者@Resource)\n控制翻转: 控制翻转就是一个概念, 就是对象通过IOC容器和依赖注入自动进行装配, 就相当于原本属于程序员对对象创建的控制权交给了IOC\n总结来说, 就是IOC通过容器概念, 控制翻转和依赖注入成为了整个系统的关键核心, 它起到一种类似\"粘合剂\"的作用, 把系统中的所有对象粘合起来一起发挥作用.\n\n## bean的作用域\n\nsingleton：在Spring容器中仅存在一个实例，即Bean以单例的形式存在。\nprototype：为每一个bean请求提供一个实例。\nrequest ：每次HTTP请求都会创建一个新的Bean。\nsession：同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。\nglobalSession：同一个全局的Session共享一个Bean，一般用于Portlet环境\n\n## .bean的自动装配\n\n* @Autowried：通过byType方式实现，并且要求这个对象存在\n* @Resouce：默认通过byName方式实现，如果name找不到再通过byType实现\n\n### 1、什么是 Spring 框架？Spring 框架有哪些主要模块？\n\n轻量级的开源的 J2EE 框架。它是一个容器框架，用来装 javabean（java 对象），中间层框架（万能胶） 可以起一个连接作用，比如说把 Struts 和 hibernate 粘合在一起运用，可以让我们的企业开发更快、更简 洁 Spring 是一个轻量级的控制反转（IoC)和面向切面（AOP）的容器框架\n\n谈谈你对AOP的理解\nAOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象\n（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增\n强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情\n\n## 依赖注入的三种方式\n\n> 常用的注入方式主要有三种：构造方法注入（Construct注入），setter注入，基于注解的注入（接口注入）\n\n### 3、什么是控制反转(IOC)？什么是依赖注入？\n\n控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象\n\n之间耦合关系在编译时通常是未知的。在传统的编程方式中，业 务逻辑的流程是由应用程序中的早\n\n已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来\n\n决定的，该对象关系图由装配 器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽\n\n象化。而绑定的过程是通过“依赖注入”实现的。\n\n控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了\n\n有效的作用。\n\n依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实\n\n例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的\n\n基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？\n\n## 在 Java 中依然注入有以下三种实现方式：★★★★★\n\n1. 构造器注入\n2. Setter 方法注入\n3. 接口注入\n\n### 4、请解释下 Spring 框架中的 IoC？\n\nSpring 中的 org.springframework.beans 包和 org.springframework.context 包\n\n构成了 Spring 框架 IoC 容器的基础。\n\nBeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。\n\nApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory\n\n的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource\n\n的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的\n\nWebApplicationContext。\n\norg.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现，\n\n用来包装和管理前面提到的各种 bean。BeanFactory 接口是 Spring IoC 容器的核心接口。\n\nIOC:把对象的创建、初始化、销毁交给 spring 来管理，而不是由开发者控制，实现控制反转。\n\n### 5、BeanFactory 和 ApplicationContext 有什么区别？\n\n![1709478839382](images/1、JAVA/1709478839382.png)\n\nBeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在\n\n接收到客户端请求时将对应的 bean 实例化。\n\nBeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的\n\n配置中解放出来。BeanFactory 还包含 了 bean 生命周期的控制，调用客户端的初始化方法\n\n（initialization methods）和销毁方法（destruction methods）。\n\n从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，\n\n根据请求分发 bean 的功能。但 applicationcontext 在此基础上还提供了其他的功能。\n\n1. 提供了支持国际化的文本消息\n2. 统一的资源文件读取方式\n3. 已在监听器中注册的 bean 的事件\n\n以下是三种较常见的 ApplicationContext 实现方式：\n\n1、ClassPathXmlApplicationContext：从 classpath 的 XML 配置文件中读取上下文，并生成上\n\n下文定义。应用程序上下文从程序环境变量中\n\nApplicationContext context = new\n\nClassPathXmlApplicationContext(“bean.xml”);\n\n2、FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。\n\nApplicationContext context = new\n\nFileSystemXmlApplicationContext(“bean.xml”);\n\n3、XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。\n\n4.AnnotationConfigApplicationContext(基于 Java 配置启动容器)\n\n![1708002876939](images/1、JAVA/1708002876939.png)\n\n### 6、Spring 有几种配置方式？\n\n将 Spring 配置到应用开发中有以下三种方式：\n\n1. 基于 XML 的配置\n2. 基于注解的配置\n3. 基于 Java 的配置\n\n1.什么是 spring?\n\nSpring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用，但是有些\n\n扩展是针对构建 J2EE 平台的 web 应用。Spring 框架目标是简化 Java 企业级应用开发，并\n\n通过 POJO 为基础的编程模型促进良好的编程习惯。\n\n### 2.使用 Spring 框架的好处是什么？★★★★★\n\n 轻量：Spring 是轻量的，基本的版本大约 2MB。\n\n 控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建\n\n或查找依赖的对象们。\n\n 面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务\n\n分开。\n\n 容器：Spring 包含并管理应用中对象的生命周期和配置。\n\n MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。\n\n 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事\n\n务（JTA）。\n\n 异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，HibernateorJDO\n\n抛出的）转化为一致的 unchecked 异常。\n\n### 14.IOC 的优点是什么？\n\nIOC 或依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和\n\nJNDI 查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC 容器支持加载服务时\n\n的饿汉式初始化和懒加载。\n\n### 15.ApplicationContext 通常的实现是什么?\n\n FileSystemXmlApplicationContext：此容器从一个 XML 文件中加载 beans 的定义，\n\nXMLBean 配置文件的全路径名必须提供给它的构造函数。\n\n ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans 的定义，这\n\n里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。\n\n WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个 WEB 应用的\n\n所有 bean。\n\n### 16.Bean 工厂和 Applicationcontexts 有什么区别？\n\nApplicationcontexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如\n\n镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内的对象上执行\n\n的那些不得不由 bean 工厂以程序化方式处理的操作，可以在 Applicationcontexts 中以声\n\n明的方式处理。Applicationcontexts 实现了 MessageSource 接口，该接口的实现以可插拔\n\n的方式提供获取本地化消息的方法。\n\n### 19.有哪些不同类型的 IOC（依赖注入）方式？\n\n更多关注 Java 大后端公众号  构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系\n\n列参数，每个参数代表一个对其他类的依赖。\n\n Setter 方法注入：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂方法\n\n实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注入。\n\n### 11、 解释 Spring 支持的几种 bean 的作用域。\n\nSpring 容器中的 bean 可以分为 5 个范围：\n\n（1）singleton：默认，每个容器中只有一个 bean 的实例，单例的模式由 BeanFactory 自身来维护。\n\n（2）prototype：为每一个 bean 请求提供一个实例。\n\n（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回 收。\n\n（4）session：与 request 范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。\n\n（5）global-session：全局作用域，global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器 中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局 变量需要存储在 global-session 中。全局作用域与 Servlet 中的 session 作用域效果相同。25.解释 Spring 支持的几种 bean 的作用域。★★★★★\n\n## ★★★★★Spring 基于 xml 注入 bean 的几种方式：\n\n（1）Set 方法注入；\n\n（2）构造器注入：① 通过 index 设置参数的位置；② 通过 type 设置参数类型； （3）静态工厂注入； （4）实例工厂；\n\n## Spring Boot、Spring MVC 和 Spring 有什么区别\n\nspring 是一个 IOC 容器，用来管理 Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提 供 AOP 机制弥补 OOP 的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给 方法执行，比如日志、异常等 springmvc 是 spring 对 web 框架的一个解决方案，提供了一个总的前端控制器 Servlet，用来接收请求， 然后定义了一套路由策略（url 到 handle 的映射）及适配执行 handle，将 handle 结果使用视图解析技术 生成视图展现给前端 springboot 是 spring 提供的一个快速开发工具包，让程序员能更方便、更快速的开发 spring+springmvc 应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter 机制）、redis、 mongodb、es，可以开箱即用\n\n## #{}和\\${}的区别是什么？★★★★★\n\n#{}是预编译处理、是占位符， \\${}是字符串替换、是拼接符。 Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 来赋值； Mybatis 在处理\\${}时， 就是把\\${}替换成变量的值，调用 Statement 来赋值； #{} 的变量替换是在 DBMS 中、变量替换后，#{} 对应的变量自动加上单引号 \\${} 的变量替换是在 DBMS 外、变量替换后，\\${} 对应的变量不会加上单引号 使用#{}可以有效的防止 SQL 注入， 提高系统安全性。\n\n## 缓存雪崩、缓存穿透、缓存击穿★★★★★\n\n4.缓存穿透、缓存击穿、缓存雪崩\n缓存穿透：客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数据。\n解决方案：缓存空对象；布隆过滤器\n缓存击穿：一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。\n解决方案：热点数据永不过期；加互斥锁\n缓存雪崩\n解决方案：设置过期时间时，附加一个随机数，避免数据同时过期；\n\n缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内 承受大量请求而崩掉。 解决方案：\n\n- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。\n- 给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓 存。\n- 缓存预热\n- 互斥锁\n\n缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承 受大量请求而崩掉。\n\n- 解决方案： 接口层增加校验，如用户鉴权校验，id 做基础校验，id<=0 的直接拦截；\n- 从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有 效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户 反复用同一个 id 暴力攻击\n- 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据 会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力\n\n缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同 时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪 崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查 数据库。\n\n解决方案\n\n- 设置热点数据永远不过期。\n- 加互斥锁\n\n# Mybatis\n\n2、MyBatis 的优点和缺点 优点：\n\n1. （1）基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重 用。\n2. （2）与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；\n3. （3）很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。\n4. （4）能够与 Spring 很好的集成； （5）提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系 组件维护。\n\n缺点\n\n1. （1）SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定 要求。\n2. （2）SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。\n\n## #{}和\\${}的区别是什么？\n\n#{}是预编译处理，\\${}是字符串替换。 Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值； Mybatis 在处理\\${}时，就是把\\${}替换成变量的值。 使用#{}可以有效的防止 SQL 注入，提高系统安全性。\n\n# 5、ES\n\n### 1.为什么要使用 ES？\n\n虽然 lucene 是性能最先进的、功能完善的搜索引擎，但是它只能有一个库，而且使用它需\n\n要集成到 java 项目才能使用，配置还特别复杂,而 ES 语法简单、是基于 Resultful api 风格的,\n\n它在 lucene 所有功能基础上还能集成多台服务器进行搜索，也就是集群;\n\n### 2. ES 和 lucene 的区别是什么？\n\nlucene 是现存功能最强大、最先进搜索库，直接基于 lucene 开发，api 非常复杂大量的 java\n\n代码、需要深入了解原理\n\n对比处:\n\n只有一个索引库、\n\n传统的遍历搜索方式\n\n采用 B+树索引;\n\nEs 是基于 lucene 的，隐藏了 lucene 复杂部分的一个分布式全文检索框架\n\n对比处:\n\n一个 es 的集群包含多个索引库、\n\n分布式搜索\n\nEs 是采用倒排式索引\n\nes 没有事物概念,删除不能恢复\n\nes 开源免费\n\n正排索引：id ---> value\n\n倒排索引：value ---> id\n\n### 3.你还了解哪些全文检索工具？\n\nLucene，Solr，HadoopContrib，Katta\n\n### 4.Bulk 一次最大处理多少数据量？\n\nbulk 会把将要处理的数据载入内存中，所以数据量是有限制的\n\n最佳的数据量不是一个确定的数值，它取决于你的硬件，你的文档大小以及复杂性，你的索\n\n更多关注 Java 大后端公众号引以及搜索的负载。\n\n一般建议是 1000-5000 个文档，如果你的文档很大，可以适当减少队列,大小建议是 5-15MB，\n\n默认不能超过 100M，可以在 es 的配置文件中修改这个值 http.max_content_length: 100mb\n\n### 5.ES 在高并发的情况下如何保证数据线程安全问题？\n\n在读数据与写数据之间如果有其他线程进行写操作，就会出问题，es 使用版本控制才避免\n\n这种问题\n\n在修改数据的时候指定版本号，操作一次版本号加 1\n\n### 6.ES 管理的工具有哪些？\n\n1）BigDesk Plugin (作者 Luká? Vl?ek)：监控 es 状态的插件,推荐！主要提供的是节点的实时\n\n状态监控，包括 jvm 的情况，linux 的情况，elasticsearch 的情况\n\n2）Elasticsearch Head Plugin (作者 Ben Birch)：很方便对 es 进行各种操作的客户端。?\n\n3）Kibana(ES 官方推荐)：Es 基于?RestAPI 调试、数据报表、数据搜索\n\n### 7.ES 自动映射的规则？\n\nEs 映射是用于确定字段类型，将新增的每个字段数据类型映射后确定的字段类型，常见的\n\n映射类型有基本数据类型、复杂数据类型映射有数组对象(但对象映射扁平化后相关性会丢\n\n失，不能确定哪个是哪个属性)、\n\n全局映射的方式默认映射继承\\_default\\_的配置、动态模板映射：dynamic_templates，使用动\n\n态模板映射会覆盖默认模板，可设置关键字分词，默认模板是 string 类型的。\n\n# 6、面试\n\n## 1、请你自我介绍一下你自己？\n\n回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历\n\n上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究\n\n的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习\n\n无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。\n\n企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”，企\n\n业喜欢有礼貌的求职者。\n\n## 2、你觉得你个性上最大的优点是什么？\n\n回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和\n\n幽默感、乐观和友爱。\n\n## 3、说说你最大的缺点？\n\n回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求\n\n职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对\n\n不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比\n\n较出色，但事实上，他已经岌岌可危了。业喜欢求职者从自己的优点说起，中间加一些小缺\n\n点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者。\n\n## 4、你对加班的看法？\n\n回答提示：实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公\n\n司奉献。\n\n回答样本：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身\n\n心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n\n## 5、你对薪资的要求？\n\n回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，\n\n那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，\n\n因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这\n\n笔钱是否足以引起你对该工作的兴趣。如果你自己必须说出具体数目，请不要说一个宽泛的\n\n范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当\n\n今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。\n\n回答样本一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重\n\n的是找对工作机会，所以只要条件公平，我则不会计较太多。\n\n回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程\n\n特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n\n## 6、你的职业规划？\n\n回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多\n\n的答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地\n\n位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感\n\n兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的\n\n工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧\n\n失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司\n\n的管理思路发展”。\n\n## 7、你还有什么问题要问吗？\n\n回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，\n\n因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人\n\n这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋\n\n升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的\n\n上进心。\n\n## 8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，\n\n你怎么办？\n\n回答提示：一段时间发现工作不适合我，有两种情况：① 如果你确实热爱这个职业，那你就\n\n要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业\n\n要求，力争减少差距；② 你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，\n\n你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n\n## 9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该\n\n怎么做？\n\n回答提示：①.原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，\n\n婉转地表达自己的想法，看看领导是否能改变想法。② 如果领导没有采纳我的建议，我也同\n\n样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原\n\n则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n## 10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？\n\n回答提示：① 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法\n\n去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。② 分清责任，各负其责，\n\n如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，\n\n作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。\n\n③ 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中\n\n吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的\n\n深度和力度是否不够，以致出现了本可以避免的错误。\n\n更多关注 Java 大后端公众号 11、谈谈你对跳槽的看法？\n\n回答提示：① 正常的“跳槽”能促进人才合理流动，应该支持。② 频繁的跳槽对单位和个人\n\n双方都不利，应该反对。\n\n## 12、工作中你难以和同事、上司相处，你该怎么办？\n\n回答提示：① 我会服从领导的指挥，配合同事的工作。② 我会从自身找原因，仔细分析是不\n\n是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，\n\n如果是这样的话 我会努力改正。③ 如果我找不到原因，我会找机会跟他们沟通，请他们指\n\n出我的不足，有问题就及时改正。④ 作为优秀的员工，应该时刻以大局为重，即使在一段时\n\n间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看\n\n见我在努力，总有一天会对我微笑的。\n\n## 13、你对于我们公司了解多少？\n\n回答提示：在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加\n\n强与国外大厂的 OEM 合作，自有品牌的部分则透过海外经销商。\n\n## 14、请说出你选择这份工作的动机？\n\n回答提示：这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，\n\n如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。\n\n## 15、你最擅长的技术方向是什么？\n\n回答提示：说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。\n\n## 16、你能为我们公司带来什么呢？\n\n回答提示：企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后\n\n说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多\n\n的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以\n\n说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需\n\n求和消费。”等等。\n\n## 17、最能概括你自己的三个词是什么？\n\n回答提示：我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主\n\n考官解释，\n\n## 18、为什么要离职?\n\n回答提示：回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少\n\n的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪\n\n及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的\n\n更多关注 Java 大后端公众号空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等\n\n等，回答的答案最好是积极正面的。\n\n回答样本：我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，\n\n已经达到顶峰，即沒有升迁机会。\n\n## 19、对工作的期望与目标何在？\n\n回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解\n\n的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这\n\n时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我\n\n的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为\n\n了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目\n\n标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。\n\n## 20、就你申请的这个职位，你认为你还欠缺什么？\n\n回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的\n\n求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可\n\n以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学\n\n习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地\n\n躲过难题的求职者。\n\n## 21、你通常如何处理別人的批评？\n\n回答提示：① 沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。② 我会\n\n等大家冷靜下来再讨论。\n\n## 22、怎样对待自己的失敗？\n\n回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n\n## 23、什么会让你有成就感？\n\n回答提示：为贵公司竭力效劳，尽我所能，完成一个项目。\n\n## 24、你为什么愿意到我们公司来工作？\n\n回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些\n\n详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，\n\n我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市\n\n场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你\n\n已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。\n\n## 25、你和别人发生过争执吗？你是怎样解决的？\n\n更多关注 Java 大后端公众号回答提示：这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过\n\n错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，\n\n这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。\n\n考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没\n\n有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n\n## 26、对这项工作，你有哪些可预见的困难？\n\n回答提示：① 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。② 可以尝试迂回\n\n战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但\n\n是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以\n\n克服。\n\n分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中\n\n的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。第一，看看应\n\n聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一\n\n下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难\n\n的态度。\n\n## 27、如果我录用你，你将怎样开展工作？\n\n回答提示： ① 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工\n\n作的具体办法。② 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就\n\n有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开\n\n展工作。”。\n\n分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知\n\n道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回\n\n避的话，此人绝对不会录用了。\n\n## 28、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应\n\n该怎么做？与上级意见不一是，你将怎么办？\n\n回答提示：①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，\n\n婉转地表达自己的想法，看看领导是否能改变想法。② 如果领导没有采纳我的建议，我也同\n\n样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原\n\n则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n## 29、你工作经验欠缺，如何能胜任这项工作？\n\n常规思路：① 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在\n\n乎“经验”，关键看应聘者怎样回答。② 对这个问题的回答最好要体现出应聘者的诚恳、机\n\n智、果敢及敬业。③ 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期\n\n间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。\n\n更多关注 Java 大后端公众号但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各\n\n项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我\n\n一定能胜任这个职位。”\n\n点评：这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习\n\n成绩）为好。\n\n## 30、您在前一家公司的离职原因是什么？\n\n回答提示：① 最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”\n\n在此家招聘单位里不存在。② 避免把“离职原因”说得太详细、太具体。③ 不能掺杂主观的\n\n负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥\n\n我们某某的员工”等。④ 但也不能躲闪、回避，如“想换换环境”、“个人原因”等。⑤ 不能\n\n涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等。⑥ 尽量使解释的理由\n\n为应聘者个人形象添彩。⑦ 相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三\n\n年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步\n\n我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只\n\n有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对\n\n面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。\n\n分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考\n\n官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真\n\n诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能\n\n准假，所以辞职，这个答案一般面试官还能接受。\n\n## 31、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？\n\n回答提示：每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得\n\n到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重\n\n要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n\n## 32、果你在这次面试中没有被录用，你怎么打算？\n\n回答提示：现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有\n\n优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅\n\n仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方\n\n面来正确看待这次失败：① 要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就\n\n不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己\n\n经历了这次之后经过努力一定能行，能够超越自我。② 善于反思，对于这次面试经验要认真\n\n总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的\n\n看待自己的长短得失，做一个明白人。③ 走出阴影，要克服这一次失败带给自己的心理压力，\n\n时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④ 认真工作，回到原单位岗位\n\n上后，要实实在在、踏踏实实地工作，三十六行、行行出状元，争取在本岗位上做出一定的\n\n更多关注 Java 大后端公众号成绩。⑤ 再接再厉，成为国家公务员一直是我的梦想，以后如果有机会我仍然后再次参加竞\n\n争。\n\n## 33、谈谈你过去做过的成功案例？(工作中遇到什么问题)\n\n回答提示：举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。切\n\n忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电\n\n话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。\n\n## 34、如何安排自己的时间？会不会排斥加班？\n\n回答提示：基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也\n\n知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配\n\n合。\n\n分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。\n\n## 35、这个职务的期许？\n\n回答提示：希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、\n\n我个人而言，缔造“双赢”的局面。\n\n分析：回答前不妨先询问该公司对这项职务的责任认定及归属，因为每一家公司的状况不尽\n\n相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n\n## 36、什么选择我们这家公司？\n\n回答提示：曾经在报章杂志看过关于贵公司的报道，与自己所追求的理念有志一同。而贵公\n\n司在业界的成绩也是有目共睹的，而且对员工的教育训练、升迁等也都很有制度。\n\n分析：去面试前先做功课，了解一下该公司的背景，让对方觉得你真的很有心想得到这份工\n\n作，而不只是探探路。\n\n## 37、谈谈如何适应办公室工作的新环境？\n\n回答提示：① 办公室里每个人有各自的岗位与职责，不得擅离岗位。② 根据领导指示和工作\n\n安排，制定工作计划，提前预备，并按计划完成。③ 多请示并及时汇报，遇到不明白的要虚\n\n心请教。④ 抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n\n## 38、工作中学习到了些什么？\n\n回答提示：这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来\n\n回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学\n\n习到哪些经验，把握这些要点做陈述，就可以轻易过关了。\n\n## 39、除了本公司外，还应聘了哪些公司？\n\n回答提示：很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，\n\n更多关注 Java 大后端公众号所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，\n\n如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n\n## 40、何时可以到职？\n\n回答提示：大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司规\n\n定上班”，但如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至\n\n少要一个月的时间，应进一步说明原因，录取公司应该会通融的。\n\n# 7、redis\n\n## 1.redis为什么快？\n\n（1）完全基于内存操作\n\n（2）数据结构简单，对数据操作简单\n\n（3）redis执行命令是单线程的，避免了上下文切换带来的性能问题，也不用考虑锁的问题\n\n(4) 采用了非阻塞的io多路复用机制，使用了单线程来处理并发的连接;内部采用的epoll+自己实现的事件分离器\n\n其实Redis不是完全多线程的，在核心的网络模型中是多线程的用来处理并发连接，但是数据的操作都是单线程。Redis坚持单线程是因为Redis是的性能瓶颈是网络延迟而不是CPU，多线程对数据读取不会带来性能提升。\n\n## Redis如何实现key的过期删除？★★★★★\n\n采用的定期过期+惰性过期\n\n定期删除 ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。\n惰性删除 ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。\n\n## 11.Redis缓存一致性解决方案\n\nRedis缓存一致性解决方案主要思考的是删除缓存和更新数据库的先后顺序\n\n先删除缓存后更新数据库存在的问题是可能会数据不一致，一般使用延时双删来解决，即先删除缓存，再更新数据库，休眠X秒后再次淘汰缓存。第二次删除可能导致吞吐率降低，可以考虑进行异步删除。\n\n先更新数据库后删除缓存存在的问题是会可能会更新失败，可以采用延时删除。但由于读比写快，发生这一情况概率较小。\n\n但是无论哪种策略，都可能存在删除失败的问题，解决方案是用中间件canal订阅binlog日志提取需要删除的key，然后另写一段非业务代码去获取key并尝试删除，若删除失败就把删除失败的key发送到消息队列，然后进行删除重试。\n\n## 12.Redis内存淘汰策略\n\n当内存不足时按设定好的策略进行淘汰，策略有(1)淘汰最久没使用的（2）淘汰一段时间内最少使用的（3）淘汰快要过期的\n\n## 1、什么是 Redis？\n\nRedis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载\n\n在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。因为是纯\n\n内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快\n\n的 Key-Value DB。\n\nRedis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结\n\n构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis\n\n可以用来实现很多有用的功能，比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的\n\n高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。另外 Redis 也可以对存入\n\n的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。\n\nRedis\n\n的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis\n\n适合的场景主要局限在较小数据量的高性能操作和运算上。\n\n## 2、Redis 相比 memcached 有哪些优势？\n\n(1) memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型\n\n(2) redis 的速度比 memcached 快很多\n\n(3) redis 可以持久化其数据\n\n## 3、Redis 支持哪几种数据类型？\n\nString、List、Set、Sorted Set、hashes\n\n字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。如果是高级用户，那\n\n么还会有，如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、\n\nGeo、Pub/Sub。\n\n## 4、Redis 主要消耗什么物理资源？\n\n内存。\n\n## 5、Redis 的全称是什么？\n\nRemote Dictionary Server。\n\n## 6、Redis 有哪几种数据淘汰策略？\n\nnoeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部\n\n分的写入指令，但 DEL 和几个例外）\n\nallkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。\n\nvolatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有\n\n空间存放。\n\nallkeys-random: 回收随机的键使得新添加的数据有空间存放。\n\nvolatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。\n\nvolatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数\n\n据有空间存放。\n\n## 7、Redis 官方为什么不提供 Windows 版本？\n\n因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来\n\n兼容性等问题。\n\n## 8、一个字符串类型的值能存储最大容量是多少？\n\n512M\n\n更多关注 Java 大后端公众号 9、为什么 Redis 需要把所有数据放到内存中？\n\nRedis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。\n\n所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度为严重\n\n影响 redis 的性能。在内存越来越便宜的今天，redis 将会越来越受欢迎。 如果设置了最大\n\n使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。\n\n## 10、Redis 集群方案应该怎么做？都有哪些方案？\n\n1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通 redis 无任何区别，设\n\n置好它下属的多个 redis 实例后，使用时在本需要连接 redis 的地方改为连接 twemproxy，它\n\n会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再\n\n返回 twemproxy。使用方式简便(相对 redis 只需修改连接端口)，对旧项目扩展的首选。 问\n\n题：twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的\n\n计算值的改变，数据无法自动移动到新的节点。\n\n2.codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量\n\n改变情况下，旧节点数据可恢复到新 hash 节点。\n\n3.redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概\n\n念，以及自身支持节点设置从节点。具体看官方文档介绍。\n\n4.在业务代码层实现，起几个毫无关联的 redis 实例，在代码层，对 key 进行 hash 计算，然\n\n后去对应的 redis 实例操作数据。 这种方式对 hash 层代码要求比较高，考虑部分包括，节\n\n点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。\n\n## 11、Redis 集群方案什么情况下会导致整个集群不可用？\n\n有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就\n\n会以为缺少 5501-11000 这个范围的槽而不可用。\n\n## 12、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点\n\n数据？\n\nredis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。\n\n## 13、Redis 有哪些适合的场景？\n\n更多关注 Java 大后端公众号（1）、会话缓存（Session Cache）\n\n最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储\n\n（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存\n\n时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？\n\n幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。\n\n甚至广为人知的商业平台 Magento 也提供 Redis 的插件。\n\n（2）、全页缓存（FPC）\n\n除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了\n\nRedis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改\n\n进，类似 PHP 本地 FPC。\n\n再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。\n\n此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助\n\n你以最快速度加载你曾浏览过的页面。\n\n（3）、队列\n\nReids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很\n\n好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）\n\n对 list 的 push/pop 操作。\n\n如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项\n\n目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一\n\n个后台就是使用 Redis 作为 broker，你可以从这里去查看。\n\n（4），排行榜/计数器\n\nRedis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted\n\nSet）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结\n\n构。所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，\n\n我们只需要像下面一样执行即可：\n\n更多关注 Java 大后端公众号当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你\n\n需要这样执行：\n\nZRANGE user_scores 0 10 WITHSCORES\n\nAgora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据\n\n的，你可以在这里看到。\n\n（5）、发布/订阅\n\n最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常\n\n多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用\n\nRedis 的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。\n\n## 14、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？\n\nRedisson、Jedis、lettuce 等等，官方推荐使用 Redisson。\n\n## 15、Redis 和 Redisson 有什么关系？\n\nRedisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些\n\nJava 的 对 象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map,\n\nConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore,\n\nLock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。\n\n## 16、Jedis 与 Redisson 对比有什么优缺点？\n\nJedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；Redisson\n\n实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，\n\n不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关\n\n注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。\n\n## 17、Redis 如何设置密码及验证密码？\n\n设置密码：config set requirepass 123456\n\n授权密码：auth 123456\n\n更多关注 Java 大后端公众号 18、说说 Redis 哈希槽的概念？\n\nRedis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，\n\n每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分\n\nhash 槽。\n\n## 19、Redis 集群的主从复制模型是怎样的？\n\n为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主\n\n从复制模型,每个节点都会有 N-1 个复制品.\n\n## 20、Redis 集群会有写操作丢失吗？为什么？\n\nRedis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操\n\n作。\n\n## 21、Redis 集群之间是如何复制的？\n\n异步复制\n\n## 22、Redis 集群最大节点个数是多少？\n\n16384 个。\n\n## 23、Redis 集群如何选择数据库？\n\nRedis 集群目前无法做数据库选择，默认在 0 数据库。\n\n## 24、怎么测试 Redis 的连通性？\n\nping\n\n## 25、Redis 中的管道有什么用？\n\n一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命\n\n令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。\n\n这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现\n\n更多关注 Java 大后端公众号支持这个功能，大大加快了从服务器下载新邮件的过程。\n\n## 26、怎么理解 Redis 事务？\n\n事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的\n\n过程中，不会被其他客户端发送来的命令请求所打断。\n\n事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。\n\n## 27、Redis 事务相关的命令有哪几个？\n\nMULTI、EXEC、DISCARD、WATCH\n\n## 28、Redis key 的过期时间和永久有效分别怎么设置？\n\nEXPIRE 和 PERSIST 命令。\n\n## 29、Redis 如何做内存优化？\n\n尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，\n\n所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个\n\n用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户\n\n的所有信息存储到一张散列表里面.\n\n## 30、Redis 回收进程如何工作的？\n\n一个客户端运行了新的命令，添加了新的数据。\n\nRedi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。\n\n一个新的命令被执行，等等。\n\n所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。\n\n如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不\n\n用多久内存限制就会被这个内存使用量超越。\n\n## 31、Redis 回收使用的是什么算法？\n\nLRU 算法\n\n## 32、Redis 如何做大量数据插入？\n\n更多关注 Java 大后端公众号 Redis2.6 开始 redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工\n\n作。\n\n## 33、为什么要做 Redis 分区？\n\n分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，你\n\n最多只能使用一台机器的内存。分区使 Redis 的计算能力通过简单地增加计算机得到成倍提\n\n升,Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。\n\n## 34、你知道有哪些 Redis 分区实现方案？\n\n客户端分区就是在客户端就已经决定数据会被存储到哪个 redis 节点或者从哪个 redis 节点读\n\n取。大多数客户端已经实现了客户端分区。\n\n代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。\n\n代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。redis\n\n和 memcached 的一种代理实现就是 Twemproxy\n\n查询路由(Query routing) 的意思是客户端随机地请求任意一个 redis 实例，然后由 Redis 将请\n\n求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接\n\n将请求从一个 redis 节点转发到另一个 redis 节点，而是在客户端的帮助下直接 redirected 到\n\n正确的 redis 节点。\n\n## 35、Redis 分区有什么缺点？\n\n涉及多个 key 的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储\n\n到不同的 Redis 实例（实际上这种情况也有办法，但是不能直接使用交集指令）。\n\n同时操作多个 key,则不能使用 Redis 事务.\n\n分区使用的粒度是 key，不能使用一个非常长的排序 key 存储一个数据集（The partitioning\n\ngranularity is the key, so it is not possible to shard a dataset with a single huge key like a very big\n\nsorted set）.\n\n当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的 Redis 实例和主机\n\n同时收集 RDB / AOF 文件。\n\n分区时动态扩容或缩容可能非常复杂。Redis 集群在运行时增加或者删除 Redis 节点，能做\n\n到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这\n\n种特性。然而，有一种预分片的技术也可以较好的解决这个问题。\n\n## 36、Redis 持久化数据和缓存怎么做扩容？\n\n更多关注 Java 大后端公众号如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。\n\n如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数\n\n量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行\n\n时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。\n\n## 37、分布式 Redis 是前期做还是后期规模上来了再做好？为什么？\n\n既然 Redis 是如此的轻量（单实例只使用 1M 内存）,为防止以后的扩容，最好的办法就是一\n\n开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式\n\n运行，使用分区，在同一台服务器上启动多个实例。\n\n一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可\n\n能比较麻烦，但是从长久来看做这点牺牲是值得的。\n\n这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis\n\n实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了\n\n另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。\n\n## 38、Twemproxy 是什么？\n\nTwemproxy 是 Twitter 维护的（缓存）代理系统，代理 Memcached 的 ASCII 协议和 Redis 协\n\n议。它是单线程程序，使用 c 语言编写，运行起来非常快。它是采用 Apache 2.0 license 的开\n\n源软件。 Twemproxy 支持自动分区，如果其代理的其中一个 Redis 节点不可用时，会自动\n\n将该节点排除（这将改变原来的 keys-instances 的映射关系，所以你应该仅在把 Redis 当缓存\n\n时使用 Twemproxy)。 Twemproxy 本身不存在单点问题，因为你可以启动多个 Twemproxy 实\n\n例，然后让你的客户端去连接任意一个 Twemproxy 实例。 Twemproxy 是 Redis 客户端和服\n\n务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。\n\n## 39、支持一致性哈希的客户端有哪些？\n\nRedis-rb、Predis 等。\n\n## 40、Redis 与其他 key-value 存储有什么不同？\n\nRedis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库\n\n的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外\n\n的抽象。\n\nRedis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡\n\n更多关注 Java 大后端公众号更多关注 Java 大后端公众号\n\n内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上\n\n相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很\n\n强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要\n\n进行随机访问。\n\n## 41、Redis 的内存占用情况怎么样？\n\n给你举个例子： 100 万个键值对（键是 0 到 999999 值是字符串“hello world”）在我的 32\n\n位的 Mac 笔记本上 用了 100MB。同样的数据放到一个 key 里只需要 16MB，\n\n这是因为键值\n\n有一个很大的开销。 在 Memcached 上执行也是类似的结果，但是相对 Redis 的开销要小一\n\n点点，因为 Redis 会记录类型信息引用计数等等。\n\n当然，大键值对时两者的比例要好很多。\n\n64 位的系统比 32 位的需要更多的内存开销，尤其是键值对都较小时，这是因为 64 位的系\n\n统里指针占用了 8 个字节。 但是，当然，64 位系统支持更大的内存，所以为了运行大型的\n\nRedis 服务器或多或少的需要使用 64 位的系统。\n\n## 42、都有哪些办法可以降低 Redis 的内存使用情况呢？\n\n如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据，\n\n因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。\n\n43、查看 Redis 使用情况及状态信息用什么命令？\n\ninfo\n\n## 44、Redis 的内存用完了会发生什么？\n\n如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或者\n\n你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。\n\n## 45、Redis 是单线程的，如何提高多核 CPU 的利用率？\n\n可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时\n\n候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU，你可以考虑一下分片\n\n（shard）。\n\n## 46、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2\n\n亿 5 千万的 keys。我们正在测试一些较大的值。\n\n任何 list、set、和 sorted set 都可以放 232 个元素。\n\n换句话说，Redis 的存储极限是系统中的可用内存值。\n\n## 47、Redis 常见性能问题和解决方案？\n\n(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件\n\n(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次\n\n(3) 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内\n\n(4) 尽量避免在压力很大的主库上增加从库\n\n(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <-\n\nSlave3...\n\n这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以\n\n立刻启用 Slave1 做 Master，其他不变。\n\n## 48、Redis 提供了哪几种持久化方式？\n\nRDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储.\n\nAOF 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢\n\n复原始的数据,AOF 命令以 redis 协议追加保存每次写的操作到文件末尾.Redis 还能对 AOF 文\n\n件进行后台重写,使得 AOF 文件的体积不至于过大.\n\n如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.\n\n你也可以同时开启两种持久化方式, 在这种情况下, 当 redis 重启的时候会优先载入 AOF 文\n\n件来恢复原始的数据,因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集\n\n要完整.\n\n最重要的事情是了解 RDB 和 AOF 持久化方式的不同,让我们以 RDB 持久化方式开始。\n\n## 49、如何选择合适的持久化方式？\n\n一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化\n\n更多关注 Java 大后端公众号功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只\n\n使用 RDB 持久化。\n\n有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）\n\n非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除\n\n此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug。\n\n## 50、修改配置不重启 Redis 会实时生效吗？\n\n针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式\n\n的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要\n\n重启 Redis。检索 ‘CONFIG GET \\*’ 命令获取更多信息。\n\n但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前\n\nCONFIG 命令还不支持的配置参数的时候。\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n# 8.MySQL\n\n## 1\\***\\*、数据库的三范式是什么★★★★★**\n\n第一范式：列不可再分\n\n第二范式：行可以唯一区分，主键约束\n\n第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束\n\n且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。\n\n## **2\\*\\***、数据库引擎有哪些\\*\\*\n\n如何查看 mysql 提供的所有存储引擎\n\n![1709735857375](images/1、JAVA/1709735857375.png)\n\n`mysql> show engines;`\n\nmysql 常用引擎包括：MYISAM、Innodb、Memory、MERGE\n\n- MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对\n- 较小，对事务完整性没有要求，以 select、insert 为主的应用基本上可以使用这引擎\n- Innodb:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键\n- 约束，并发能力强，占用空间是 MYISAM 的 2.5 倍，处理效率相对会差一些\n- Memory:全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在 mysql 重\n- 启时会丢失，默认使用 HASH 索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变\n- 化不频繁的代码表\n- MERGE：是一组 MYISAM 表的组合\n\n## **3\\*\\***、\\***\\*InnoDB\\*\\***与\\***\\*MyISAM\\*\\***的区别\n\n1. InnoDB 支持事务，MyISAM 不支持，对于 InnoDB 每一条 SQL 语言都默认封装成事务，自动提交，\n\n这样会影响速度，所以最好把多条 SQL 语言放在 begin 和 commit 之间，组成一个事务；\n\n2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；\n3. InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但\n\n是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，\n\n因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的\n\n是数据文件的指针。主键索引和辅助索引是独立的。\n\n4. InnoDB 不保存表的具体行数，执行 select count(\\*) from table 时需要全表扫描。而 MyISAM 用一\n\n个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；\n\n5. Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；\n\nmysql> show engines;**如何选择引擎？**\n\n如果没有特别的需求，使用默认的 Innodb 即可。\n\nMyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。\n\nInnodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如\n\nOA 自动化办公系统。\n\n**4\\*\\***、数据库的事务\\*\\*\n\n## 4\\***\\*、数据库的事务★★★★★**\n\n**什么是事务？**\n\n**：** 多条 sql 语句，要么全部成功，要么全部失败。\n\n**事务的特性：**\n\n**数据库事务特性：原子性\\*\\***(Atomic)\\***\\*、一致性\\*\\***(Consistency)\\***\\*、隔离性\\*\\***(Isolation)\\***\\*、持久性\\*\\***(Durabiliy)\\***\\*。**\n\n**简称\\*\\***ACID\\***\\*。**\n\n原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功，整个\n\n事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。\n\n一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如 A\n\n转账 100 元给 B，不管操作是否成功，A 和 B 的账户总额是不变的。\n\n隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰\n\n持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。\n\n## 事务并发产生的三种问题\n\n## 脏读：一个事务读取到了另外一个事务没有提交的数据\n\n幻读：同一事务中，用同样的操作读取两次，得到的记录数不相同（数据条数）\n不可重复读：在同一事务中，两次读取同一数据，得到内容不同（数据内容）\n6.mysql的事务隔离级别\n读未提交 Read uncommitted：一个事务还没有提交时，它做的变更就能被别的事务看到。\n读提交 Read committed：一个事物提交之后，它做的变更才会被其他事务看到。\n可重复读 Repeatable read：一个事物执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。未提交变更对其他事务也是不可见的。\n串行化 serializable：对于同一行记录，写会加“写锁”，读会加“读锁”，当出现\n\n## .innodb和myisam区别\n\ninnodb支持事务；myisam不支持事务\ninnodb支持外键；myisam不支持外键\ninnodb是聚集索引，数据和索引是捆绑在一起的；myisam是非聚集索引，数据和索引分开的，这也导致他们底层B+树结构不同。\ninnodb每个表下两个文件：.frm文件中保存的是表的结构，.ibd文件中保存的是数据和索引方式\nmyisam每个表下三个文件：一个文件用来保存 表结构，一个文件用来保存 数据，一个文件用来保存 索引\n\n## **5**、索引问题\n\n索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于快速获取信息。\n\n你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，\n\n索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅\n\n速地找到表中的数据，而不必扫描整个数据库。\n\n.索引\n索引是帮助MySQL高效获取数据的数据结构，通俗来讲索引就好比书本的目录，加快数据库的查询速度。\n分类\n按功能逻辑分\n主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个\n唯一索引：加速查询 + 列值唯一（可以有null）\n普通索引：仅加速查询\n组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并\n全文索引：对文本的内容进行分词，进行搜索\n按物理结构分\n聚簇索引\n非聚簇索引★★★★★\n\nmysql 有 4 种不同的索引：\n\n1. 主键索引（PRIMARY）\n2. 数据列不允许重复，不允许为 NULL，一个表只能有一个主键。\n3. 唯一索引（UNIQUE）\n4. 数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。\n5. 可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引\n6. 可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索\n7. 引\n8. 普通索引（INDEX）\n9. 可以通过 ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引\n10. 可以通过 ALTER TABLE table_name ADD INDEX index_name(column1, column2,\n11. column3); 创建组合索引\n12. 全文索引（FULLTEXT）\n13. 可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引\n\n**索引并非是越多越好，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时**\n\n**要花费较多的时间维护索引**\n\n1. 索引加快数据库的检索速度\n2. 索引降低了插入、删除、修改等维护任务的速度\n3. 唯一索引可以确保每一行数据的唯一性\n4. 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能\n5. 索引需要占物理和数据空间\n\n## 6、SQL 优化\n\n1、查询语句中不要使用 select \\*\n\n2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代\n\n3、减少使用 IN 或者 NOT IN ,使用 exists，not exists 或者关联查询语句替代\n\n4、or 的查询尽量用 union 或者 union all 代替(在确认没有重复数据或者不用剔除重复数据时，union\n\nall 会更好)\n\n5、应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。\n\n6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫\n\n描，如： select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null\n\n值，然后这样查询： select id from t where num=0\n\n## **7\\*\\***、简单说一说\\***\\*drop\\*\\***、\\***\\*delete\\*\\***与\\***\\*truncate\\*\\***的区别\\*\\*\n\nSQL 中的 drop、delete、truncate 都表示删除，但是三者有一些差别\n\ndelete 和 truncate 只删除表的数据不删除表的结构\n\n速度,一般来说: drop> truncate >delete\n\ndelete 语句是 dml,这个操作会放到 rollback segement 中,事务提交之后才生效;\n\n如果有相应的 trigger,执行的时候将被触发. truncate,drop 是 ddl, 操作立即生效,原数据不放到 rollback\n\nsegment 中,不能回滚. 操作不触发 trigger.\n\n## **8\\*\\***、什么是视图\\*\\*\n\n视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一\n\n个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表\n\n查询。\n\n## **9\\*\\***、 什么是内联接、左外联接、右外联接？\\*\\*\n\n1. 内联接（Inner Join）：匹配 2 张表中相关联的记录。\n2. 左外联接（Left Outer Join）：除了匹配 2 张表中相关联的记录外，还会匹配左表中剩余的记录，\n3. 右表中未匹配到的字段用 NULL 表示。\n4. 右外联接（Right Outer Join）：除了匹配 2 张表中相关联的记录外，还会匹配右表中剩余的记录，\n5. 左表中未匹配到的字段用 NULL 表示。在判定左表和右表时，要根据表名出现在 Outer Join 的左右\n6. 位置关系。\n\n## **10\\*\\***、并发事务带来哪些问题\\***\\*?\\*\\***隔离级别\\*\\*\n\n**脏读**\n\n**不可重复读**\n\n**幻影读**\n\nREAD-UNCOMMITTED\n\n√\n\n√\n\n√\n\nREAD-COMMITTED\n\n×\n\n√\n\n√\n\nREPEATABLE-READ\n\n×\n\n×\n\n√\n\nSERIALIZABLE\n\n×\n\n×\n\n×\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一\n\n数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n\n**脏读（\\*\\***Dirty read\\***\\*）\\*\\***:\\*\\* 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到\n\n数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提\n\n交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确\n\n的。\n\n**丢失修改（\\*\\***Lost to modify\\***\\*）\\*\\***:\\*\\* 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那\n\n么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结\n\n果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事\n\n务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。\n\n**不可重复读（\\*\\***Unrepeatableread\\***\\*）\\*\\***:\\*\\* 指在一个事务内多次读同一数据。在这个事务还没有结束\n\n时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改\n\n导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样\n\n的情况，因此称为不可重复读。\n\n**幻读（\\*\\***Phantom read\\***\\*）\\*\\***:\\*\\* 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接\n\n着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了\n\n一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n**不可重复读和幻读区别：**\n\n不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者\n\n删除比如多次读取一条记录发现记录增多或减少了。\n\n## **11\\*\\***、事务隔离级别有哪些\\***\\*?MySQL\\*\\***的默认隔离级别是\\***\\*?**\n\n**SQL** **标准定义了四个隔离级别：**\n\n**READ-UNCOMMITTED(\\*\\***读取未提交\\***\\*)\\*\\***：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会\\*\\*\n\n**导致脏读、幻读或不可重复读**。\n\n**READ-COMMITTED(\\*\\***读取已提交\\***\\*)\\*\\***：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻\\*\\*\n\n**读或不可重复读仍有可能发生**。\n\n**REPEATABLE-READ(\\*\\***可重复读\\***\\*)\\*\\***：\\*\\* 对同一字段的多次读取结果都是一致的，除非数据是被本身事务\n\n自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。\n\n**SERIALIZABLE(\\*\\***可串行化\\***\\*)\\*\\***：\\*\\* 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执\n\n行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻**\n\n**读**。\n\nMySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ\\*\\***（可重读）\\*\\*。我们可以通过\n\nSELECT @@tx_isolation; 命令来查看这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ\\*\\***（可重读）\\*\\*\n\n事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如\n\nSQL Server) 是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ\\*\\***（可重\\*\\*\n\n**读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 **SERIALIZABLE(\\*\\***可串行化\\***\\*)** 隔离级\n\n别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ\u0002**\n\n**COMMITTED(\\*\\***读取提交内容\\***\\*)** ，但是你要知道的是 InnoDB 存储引擎默认使用 **REPEAaTABLE\u0002**\n\n**READ\\*\\***（可重读）\\*\\* 并不会有任何性能损失。\n\nInnoDB 存储引擎在 **分布式事务** 的情况下一般会用到 **SERIALIZABLE(\\*\\***可串行化\\***\\*)** 隔离级别。\n\n## **12\\*\\***、大表如何优化？\\*\\*\n\n当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：\n\n**1.** **限定数据的范围**\n\n务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以\n\n控制在一个月的范围内；\n\n**2.** **读\\*\\***/\\***\\*写分离**\n\n经典的数据库拆分方案，主库负责写，从库负责读；\n\n**3.** **垂直分区**\n\n**根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，\n\n可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。\n\n**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大\n\n家应该就更容易理解了。\n\n**垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的 Block 数，减少 I/O 次数。此外，垂\n\n直分区可以简化表的结构，易于维护。\n\n**垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起 Join 操作，可以通过在应用层进行\n\nJoin 来解决。此外，垂直分区会让事务变得更加复杂；\n\n**4.** **水平分区**\n\nmysql> SELECT @@tx_isolation;\n\n+-----------------+\n\n| @@tx_isolation |\n\n+-----------------+\n\n| REPEATABLE-READ |\n\n+-----------------+**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了**\n\n**分布式的目的。 水平拆分可以支撑非常大的数据量。**\n\n水平拆分是指数据表行的拆分，表的行数超过 200 万行时，就会变慢，这时可以把一张的表的数据拆成\n\n多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据\n\n量过大对性能造成影响。\n\n水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但\n\n由于表的数据还是在同一台机器上，其实对于提升 MySQL 并发能力没有什么意义，所以 **水平拆分最好**\n\n**分库** 。\n\n水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨节点 Join 性能较\n\n差，逻辑复杂。《Java 工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、**\n\n**部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题\n\n的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络 I/O。\n\n**下面补充一下数据库分片的两种常见方案：**\n\n**客户端代理： 分片逻辑在应用端，封装在\\*\\***jar\\***\\*包中，通过修改或者封装\\*\\***JDBC\\***\\*层来实现。** 当当网的\n\n**Sharding-JDBC** 、阿里的 TDDL 是两种比较常用的实现。\n\n**中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在\n\n谈的 **Mycat** 、360 的 Atlas、网易的 DDB 等等都是这种架构的实现。\n\n详细内容可以参考： MySQL 大表优化方案: https://segmentfault.com/a/1190000006158186\n\n## **13\\*\\***、分库分表之后\\***\\*,id** **主键如何处理？**\n\n因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来\n\n支持。\n\n生成全局 id 有下面这几种方式：\n\n**UUID**：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的\n\n名字的标示比如文件的名字。\n\n**数据库自增** **id** : 两台数据库分别设置不同步长，生成不重复 ID 的策略来实现高可用。这种方式生成\n\n的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。\n\n**利用** **redis** **生成** **id :** 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更\n\n加复杂，可用性降低，编码更加复杂，增加了系统成本。\n\n**Twitter\\*\\***的\\***\\*snowflake\\*\\***算法\\*\\* ：Github 地址：https://github.com/twitter-archive/snowflake。\n\n**美团的\\*\\***Leaf\\***\\*分布式\\*\\***ID\\***\\*生成系统** ：Leaf 是美团开源的分布式 ID 生成器，能保证全局唯一性、趋势递\n\n增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、\n\nZookeeper 等中间件。感觉还不错。美团技术团队的一篇文章：https://tech.meituan.com/2017/\n\n04/21/mt-leaf.html 。**14\\*\\***、\\***\\*mysql\\*\\***有关权限的表都有哪几个\\*\\*\n\nMySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里，由\n\nmysql_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和 host。下面分\n\n别介绍一下这些表的结构和内容：\n\nuser 权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。\n\ndb 权限表：记录各个帐号在各个数据库上的操作权限。\n\ntable_priv 权限表：记录数据表级的操作权限。\n\ncolumns_priv 权限表：记录数据列级的操作权限。\n\nhost 权限表：配合 db 权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受\n\nGRANT 和 REVOKE 语句的影响。\n\n## **15\\*\\***、\\***\\*mysql\\*\\***有哪些数据类型\\*\\*\n\n**1\\*\\***、整数类型\\*\\* ，包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示 1 字节、2 字节、3\n\n字节、4 字节、8 字节整数。任何整数类型都可以加上 UNSIGNED 属性，表示数据是无符号的，即非负整\n\n数。\n\n长度：整数类型可以被指定长度，例如：INT(11)表示长度为 11 的 INT 类型。长度在大多数场景是没有意\n\n义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和 UNSIGNED ZEROFILL 属性配\n\n合使用才有意义。\n\n例子，假定类型设定为 INT(5)，属性为 UNSIGNED ZEROFILL，如果用户插入的数据为 12 的话，那么数\n\n据库实际存储数据为 00012。\n\n**2\\*\\***、实数类型\\*\\*，包括 FLOAT、DOUBLE、DECIMAL。\n\nDECIMAL 可以用于存储比 BIGINT 还大的整型，能存储精确的小数。\n\n而 FLOAT 和 DOUBLE 是有取值范围的，并支持使用标准的浮点进行近似计算。\n\n计算时 FLOAT 和 DOUBLE 相比 DECIMAL 效率更高一些，DECIMAL 你可以理解成是用字符串进行处理。\n\n**3\\*\\***、字符串类型\\*\\*，包括 VARCHAR、CHAR、TEXT、BLOB\n\nVARCHAR 用于存储可变长字符串，它比定长类型更节省空间。\n\nVARCHAR 使用额外 1 或 2 个字节存储字符串长度。列长度小于 255 字节时，使用 1 字节表示，否则使用 2\n\n字节表示。\n\nVARCHAR 存储的内容超出设置的长度时，内容会被截断。\n\nCHAR 是定长的，根据定义的字符串长度分配足够的空间。\n\nCHAR 会根据需要使用空格进行填充方便比较。\n\nCHAR 适合存储很短的字符串，或者所有值都接近同一个长度。\n\nCHAR 存储的内容超出设置的长度时，内容同样会被截断。\n\n**使用策略：**\n\n对于经常变更的数据来说，CHAR 比 VARCHAR 更好，因为 CHAR 不容易产生碎片。\n\n对于非常短的列，CHAR 比 VARCHAR 在存储空间上更有效率。\n\n使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。\n\n尽量避免使用 TEXT/BLOB 类型，查询时会使用临时表，导致严重的性能开销。\n\n**4\\*\\***、枚举类型（\\***\\*ENUM\\*\\***）\\*\\*，把不重复的数据存储为一个预定义的集合。\n\n有时可以使用 ENUM 代替常用的字符串类型。\n\nENUM 存储非常紧凑，会把列表值压缩到一个或两个字节。\n\nENUM 在内部存储时，其实存的是整数。\n\n尽量避免使用数字作为 ENUM 枚举的常量，因为容易混乱。\n\n排序是按照内部存储的整数**5\\*\\***、日期和时间类型\\*\\*，尽量使用 timestamp，空间效率高于 datetime，\n\n用整数保存时间戳通常不方便处理。\n\n如果需要存储微妙，可以使用 bigint 存储。\n\n看到这里，这道真题是不是就比较容易回答了。\n\n## **16\\*\\***、创建索引的三种方式，删除索引\\*\\*\n\n第一种方式：在执行 CREATE TABLE 时创建索引\n\n第二种方式：使用 ALTER TABLE 命令去增加索引\n\nALTER TABLE 用来创建普通索引、UNIQUE 索引或 PRIMARY KEY 索引。\n\n其中 table_name 是要增加索引的表名，column_list 指出对哪些列进行索引，多列时各列之间用逗号分\n\n隔。\n\n索引名 index_name 可自己命名，缺省时，MySQL 将根据第一个索引列赋一个名称。另外，ALTER\n\nTABLE 允许在单个语句中更改多个表，因此可以在同时创建多个索引。\n\n第三种方式：使用 CREATE INDEX 命令创建\n\nCREATE INDEX 可对表增加普通索引或 UNIQUE 索引。（但是，不能创建 PRIMARY KEY 索引）\n\n删除索引\n\n根据索引名删除普通索引、唯一索引、全文索引： alter table 表名 drop KEY 索引名\n\n删除主键索引： alter table 表名 drop primary key （因为主键只有一个）。这里值得注意的是，\n\n如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：\n\nCREATE TABLE user_index2 (\n\nid INT auto_increment PRIMARY KEY,\n\nfirst_name VARCHAR (16),\n\nlast_name VARCHAR (16),\n\nid_card VARCHAR (18),\n\ninformation text,\n\nKEY name (first_name, last_name),\n\nFULLTEXT KEY (information),\n\nUNIQUE KEY (id_card)\n\n);\n\nALTER TABLE table_name ADD INDEX index_name (column_list);\n\nCREATE INDEX index_name ON table_name (column_list);\n\nalter table user_index drop KEY name;\n\nalter table user_index drop KEY id_card;\n\nalter table user_index drop KEY information;需要取消自增长再行删除：\n\n但通常不会删除主键，因为设计主键一定与业务逻辑无关。\n\n# 2、未分类\n\n## 1、你知道的 List 都有哪些？\n\nArrayList、LinkedList、Vector 等。\n\n## 2、List 和 Vector 有什么区别？\n\nVector 是 List 接口下线程安全的集合。\n\n## 3、List 是有序的吗？\n\nList 是有序的。\n\n## 4、ArrayList 和 LinkedList 的区别？分别用在什么场景？\n\nArrayList 和 LinkedList 数据结构不一样，前者用在查询较多的场合，后者适用于插入较多的\n\n场合。\n\n## 5、ArrayList 和 LinkedList 的底层数据结构是什么？\n\nArrayList 使用的是数组结构，LinkedList 使用的是链表结构。\n\n## 6、ArrayList 默认大小是多少，是如何扩容的？\n\nJdk1.7 之前 ArrayList 默认大小是 10，JDK1.7 之后是 0，JDK 差异，每次约按 1.5 倍扩容。\n\n## 7、List 是线程安全的吗？如果要线程安全要怎么做？\n\nList 中 的 Vector 才 是 线 程 安 全 的 ， 其 他 要 实 现 线 程 安 全 使 用 工 具 类\n\nCollections.synchronizedList(new ArrayList())方法。\n\n## 8、怎么给 List 排序？\n\n使用 List 自身的 sort 方法，或者使用 Collections.sort(list)方法;\n\n## 9、Arrays.asList 方法后的 List 可以扩容吗？\n\nArrays.asList 使用的是 final 数组，并且不支持 add 方法，不支持扩容。\n\n## 10、List 和 Array 之间如何互相转换？\n\nList>Array 使用 toArray 方法，Array>List 使用 Arrays.asList(array)方法，由于它是固定的，不固\n\n定的可以使用 new ArrayList(Arrays.asList(array))。\n","slug":"java八股文","published":1,"updated":"2024-03-20T04:06:09.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxx001ciou21mzneqw0","content":"<h1 id=\"1、JAVA\"><a href=\"#1、JAVA\" class=\"headerlink\" title=\"1、JAVA\"></a>1、JAVA</h1><h2 id=\"一、-Resource和-Autowire注解的区别\"><a href=\"#一、-Resource和-Autowire注解的区别\" class=\"headerlink\" title=\"一、@Resource和@Autowire注解的区别\"></a>一、@Resource和@Autowire注解的区别</h2><p>@Resource和@Autowired都是用来进行依赖注入的注解，但是它们有一些不同之处。</p>\n<p>@Autowired是Spring框架中的注解，它可以用来标注字段、构造函数、方法等，表示需要自动装配。它可以用来注入依赖的bean。如果有多个bean符合条件，可能会抛出异常。</p>\n<p>@Resource是Java自带的注解，它可以用来标注字段、方法等，表示需要自动装配。它可以用来注入依赖的bean。如果有多个bean符合条件，会按照名称进行匹配。</p>\n<p>总结:</p>\n<p>@Autowired 是 Spring 框架中的注解，用来标注需要自动装配的 bean。<br>@Resource 是 Java 自带的注解，用来标注需要自动装配的 bean。<br>@Autowired 是按类型装配，如果有多个同类型的 bean，会抛出异常； @Resource 是按名称装配，如果名称不存在，会使用类型装配。</p>\n<h2 id=\"2、重载与重写区别-难度系数：⭐\"><a href=\"#2、重载与重写区别-难度系数：⭐\" class=\"headerlink\" title=\"2、重载与重写区别    难度系数：⭐\"></a>2、重载与重写区别    难度系数：⭐</h2><ol>\n<li>重载发生在本类，重写发生在父类与子类之间</li>\n<li>重载的方法名必须相同，重写的方法名相同且返回值类型必须相同</li>\n<li>重载的参数列表不同，重写的参数列表必须相同</li>\n<li>重写的访问权限不能比父类中被重写的方法的访问权限更低</li>\n<li>构造方法不能被重写</li>\n</ol>\n<h2 id=\"12、普通类和抽象类有哪些区别？★★★★★\"><a href=\"#12、普通类和抽象类有哪些区别？★★★★★\" class=\"headerlink\" title=\"12、普通类和抽象类有哪些区别？★★★★★\"></a>12、普通类和抽象类有哪些区别？★★★★★</h2><p>抽象类不能被实例化；<br>抽象类可以有抽象方法，只需申明，无须实现；<br>有抽象方法的类一定是抽象类；<br>抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类；<br>抽象方法不能声明为静态、不能被static、final修饰。</p>\n<h2 id=\"13、接口和抽象类有什么区别？★★★★★\"><a href=\"#13、接口和抽象类有什么区别？★★★★★\" class=\"headerlink\" title=\"13、接口和抽象类有什么区别？★★★★★\"></a>13、接口和抽象类有什么区别？★★★★★</h2><p>（1）接口</p>\n<p>接口使用interface修饰；<br>接口不能实例化；<br>类可以实现多个接口；</p>\n<p>①java8之前，接口中的方法都是抽象方法，省略了public abstract。②java8之后；接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；</p>\n<p>（2）抽象类</p>\n<p>抽象类使用abstract修饰；<br>抽象类不能被实例化；<br>抽象类只能单继承；<br>抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体；<br>如果一个类继承了抽象类，①如果实现了所有的抽象方法，子类可以不是抽象类；②如果没有实现所有的抽象方法，子类仍然是抽象类。</p>\n<p>共同点 不能实例化；</p>\n<p>不同点 接口使用interface修饰；抽象类使用abstract修饰；</p>\n<h2 id=\"6、String、StringBuffer、StringBuilder-有什么区别？★★★★★\"><a href=\"#6、String、StringBuffer、StringBuilder-有什么区别？★★★★★\" class=\"headerlink\" title=\"6、String、StringBuffer、StringBuilder 有什么区别？★★★★★\"></a>6、String、StringBuffer、StringBuilder 有什么区别？★★★★★</h2><p>String、StringBuffer、StringBuilder 最大的不同是 String 不可变，后者可变。StringBuffer 是线</p>\n<p>程安全的，StringBuilder 线程不安全速度较快。</p>\n<h2 id=\"7、String-trim-方法去掉的是哪些字符？\"><a href=\"#7、String-trim-方法去掉的是哪些字符？\" class=\"headerlink\" title=\"7、String.trim()方法去掉的是哪些字符？\"></a>7、String.trim()方法去掉的是哪些字符？</h2><p>trim 去掉字符串首尾的空白字符。</p>\n<h2 id=\"8、String-可以被子类继承吗？\"><a href=\"#8、String-可以被子类继承吗？\" class=\"headerlink\" title=\"8、String 可以被子类继承吗？\"></a>8、String 可以被子类继承吗？</h2><p>既然 String 是 final 的，所以不能被继承。</p>\n<h2 id=\"9、可以自定义-java-lang-String-类并使用吗？\"><a href=\"#9、可以自定义-java-lang-String-类并使用吗？\" class=\"headerlink\" title=\"9、可以自定义 java.lang.String 类并使用吗？\"></a>9、可以自定义 java.lang.String 类并使用吗？</h2><p>可以自定义 java.lang.String 类并编译成功，但不能被加载使用，具体请学习类加载机制。</p>\n<h2 id=\"10、String-与-byte-两者相互之间如何转换？\"><a href=\"#10、String-与-byte-两者相互之间如何转换？\" class=\"headerlink\" title=\"10、String 与 byte[]两者相互之间如何转换？\"></a>10、String 与 byte[]两者相互之间如何转换？</h2><p>String &gt; byte[] 通过 String 类的 getBytes 方法；byte[] &gt; String 通过 new String(byte[])构造器。</p>\n<h2 id=\"11、-和-equals-⽅法的区别\"><a href=\"#11、-和-equals-⽅法的区别\" class=\"headerlink\" title=\"11、&#x3D;&#x3D;和 equals ⽅法的区别\"></a>11、&#x3D;&#x3D;和 equals ⽅法的区别</h2><p>&#x3D;&#x3D;：如果是基本数据类型，⽐较是值，如果是引⽤类型，⽐较的是引⽤地址</p>\n<p>equals：具体看各个类重写 equals ⽅法之后的⽐较逻辑，⽐如 String 类，虽然是引⽤类型，但是 String 类中重写了 equals ⽅法，⽅法内部⽐较的是字符串中的各个字符是否全部相等。</p>\n<h3 id=\"2、-和-equals-的区别是什么？\"><a href=\"#2、-和-equals-的区别是什么？\" class=\"headerlink\" title=\"2、&#x3D;&#x3D; 和 equals 的区别是什么？\"></a>2、&#x3D;&#x3D; 和 <a href=\"https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020\">equals</a> 的区别是什么？</h3><ol>\n<li>对于基本类型，&#x3D;&#x3D;比较的是值；</li>\n<li>对于引用类型，&#x3D;&#x3D;比较的是地址；</li>\n<li>equals不能用于基本类型的比较；</li>\n<li>如果没有重写equals，equals就相当于&#x3D;&#x3D;；</li>\n<li>如果重写了equals方法，equals比较的是对象的内容；</li>\n</ol>\n<h2 id=\"12、-hashCode-与-equals-之间的关系★★★★★\"><a href=\"#12、-hashCode-与-equals-之间的关系★★★★★\" class=\"headerlink\" title=\"12、 hashCode()与 equals()之间的关系★★★★★\"></a>12、 hashCode()与 equals()之间的关系★★★★★</h2><p>6 在 Java 中，每个对象都可以调⽤⾃⼰的 hashCode()⽅法得到⾃⼰的哈希值(hashCode)，相当于对象的 指纹信息，通常来说世界上没有完全相同的两个指纹，但是在 Java 中做不到这么绝对，但是我们仍然可 以利⽤ hashCode 来做⼀些提前的判断，⽐如： 如果两个对象的 hashCode 不相同，那么这两个对象肯定不同的两个对象 如果两个对象的 hashCode 相同，不代表这两个对象⼀定是同⼀个对象，也可能是两个对象 如果两个对象相等，那么他们的 hashCode 就⼀定相同 在 Java 的⼀些集合类的实现中，在⽐较两个对象是否相等时，会根据上⾯的原则，会先调⽤对象的 hashCode()⽅法得到 hashCode 进⾏⽐较，如果 hashCode 不相同，就可以直接认为这两个对象不相 同，如果 hashCode 相同，那么就会进⼀步调⽤ equals()⽅法进⾏⽐较。⽽ equals()⽅法，就是⽤来最终 确定两个对象是不是相等的，通常 equals ⽅法的实现会⽐较重，逻辑⽐较多，⽽ hashCode()主要就是得 到⼀个哈希值，实际上就⼀个数字，相对⽽⾔⽐较轻，所以在⽐较两个对象时，通常都会先根据 hashCode 想⽐较⼀下。 所以我们就需要注意，如果我们重写了 equals()⽅法，那么就要注意 hashCode()⽅法，⼀定要保证能遵 守上述规则。</p>\n<p>13、重载和重写的区别</p>\n<ul>\n<li>重载是指在一个类中定义了多个同名的方法，但他们的参数列表是不同的</li>\n<li>子<a href=\"https://so.csdn.net/so/search?q=%E7%B1%BB%E7%BB%A7%E6%89%BF&spm=1001.2101.3001.7020\">类继承</a>父类，子类重写父类中的所有公共方法，覆盖父类的方法并对其重写。</li>\n</ul>\n<p>重载</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static int add(int x, int y) &#123;\n        return x + y;\n    &#125;\n    public static double add(int x, int y) &#123;\n        return x + y;\n    &#125;</code></pre>\n\n<p>重写</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Animal &#123;\n    public void eat(String food) &#123;\n \t\t...\n    &#125;\n&#125;\n\nclass Bird extends Animal &#123;\n    @Override\n    public void eat(String food) &#123;\n\t\t...\n    &#125;</code></pre>\n\n<h2 id=\"13、String、StringBuffer-和-StringBuilder-的区别是什-么-★★★★★\"><a href=\"#13、String、StringBuffer-和-StringBuilder-的区别是什-么-★★★★★\" class=\"headerlink\" title=\"13、String、StringBuffer 和 StringBuilder 的区别是什 么?★★★★★\"></a>13、String、StringBuffer 和 StringBuilder 的区别是什 么?★★★★★</h2><p>string 不可变 线程安全 操作少量数据或不操作数据 是个对象 消耗内存性能底</p>\n<p>StringBuffer 不可变 线程不安全 频繁操作数据 不考虑线程安全</p>\n<p>StringBuilder 不可变 线程安全 频繁操作数据 考虑线程安全 +了 synchronizd(锁)</p>\n<h2 id=\"14、-Java-创建对象有几种方式？★★★★★\"><a href=\"#14、-Java-创建对象有几种方式？★★★★★\" class=\"headerlink\" title=\"14、 Java 创建对象有几种方式？★★★★★\"></a>14、 Java 创建对象有几种方式？★★★★★</h2><p>java 中提供了以下四种创建对象的方式:</p>\n<ol>\n<li>new 创建新对象</li>\n<li>通过反射机制</li>\n<li>采用 clone 机制</li>\n<li>通过序列化机制</li>\n</ol>\n<p>15、 有没有可能两个不相等的对象有相同的 hashcode</p>\n<p>有可能.在产生 hash 冲突时,两个不相等的对象就会有相同的 hashcode 值.当 hash 冲突产生时,一般有以 下几种方式来处理:</p>\n<p>拉链法:每个哈希表节点都有一个 next 指针,多个哈希表节点可以用 next 指针构成一个单向链表，被 分配到同一个索引上的多个节点可以用这个单向链表进行存储.</p>\n<p>开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找 到,并将记录存入</p>\n<p>再哈希:又叫双哈希法,有多个不同的 Hash 函数.当发生冲突时,使用第二个,第三个….等哈希函数计算 地址,直到无冲突</p>\n<h2 id=\"15、-深拷贝和浅拷贝的区别是什么-★★★★★\"><a href=\"#15、-深拷贝和浅拷贝的区别是什么-★★★★★\" class=\"headerlink\" title=\"15、 深拷贝和浅拷贝的区别是什么?★★★★★\"></a>15、 深拷贝和浅拷贝的区别是什么?★★★★★</h2><h3 id=\"深拷贝和浅拷贝\"><a href=\"#深拷贝和浅拷贝\" class=\"headerlink\" title=\"深拷贝和浅拷贝\"></a>深拷贝和浅拷贝</h3><p>深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。</p>\n<p>浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象<br>深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象<br>浅拷贝: 基本数据类型+实例对象的地址(这时浅拷贝的两个实例对象地址是同一个, 也就是同一个实例); 深拷贝: 基本数据类型+实例对象地址下的数据(也就是将实例对象也拷贝了一份)</p>\n<p>浅拷贝:被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向 原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.</p>\n<p>深拷贝:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被 复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都 复制了一遍.</p>\n<p>深拷⻉和浅拷⻉就是指对象的拷⻉，⼀个对象中存在两种类型的属性，⼀种是基本数据类型，⼀种是实 例对象的引⽤。 1. 浅拷⻉是指，只会拷⻉基本数据类型的值，以及实例对象的引⽤地址，并不会复制⼀份引⽤地址所 指向的对象，也就是浅拷⻉出来的对象，内部的类属性指向的是同⼀个对象 2. 深拷⻉是指，既会拷⻉基本数据类型的值，也会针对实例对象的引⽤地址所指向的对象进⾏复制， 深拷⻉出来的对象，内部的属性指向的不是同⼀个对象</p>\n<h2 id=\"16、-final-有哪些用法-★★★★★\"><a href=\"#16、-final-有哪些用法-★★★★★\" class=\"headerlink\" title=\"16、 final 有哪些用法? ★★★★★\"></a>16、 final 有哪些用法? ★★★★★</h2><p>被 final 修饰的类不可以被继承</p>\n<p>被 final 修饰的方法不可以被重写</p>\n<p>被 final 修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.</p>\n<p>被 final 修饰的方法,JVM 会尝试将其内联,以提高运行效率 被 final 修饰的常量,在编译阶段会存入常量池中.</p>\n<p>修饰类：表示类不可被继承 修饰方法：表示方法不可被子类覆盖，但是可以重载 修饰变量：表示变量一旦被赋值就不可以更改它的值。 （1）修饰成员变量 如果 final 修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。 如果 final 修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。</p>\n<p>final 在 java 中有什么作用？<br>（1）用来修饰一个引用</p>\n<p>如果引用为基本数据类型，则该引用为常量，该值无法修改；<br>如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。<br>如果引用时类的成员变量，则必须当场赋值，否则编译会报错。<br>（2）用来修饰一个方法</p>\n<p>当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。</p>\n<p>（3）用来修饰类</p>\n<p>当用final修改类时，该类成为最终类，无法被继承。</p>\n<p>比如常用的String类就是最终类。</p>\n<h2 id=\"7、如何将字符串反转？\"><a href=\"#7、如何将字符串反转？\" class=\"headerlink\" title=\"7、如何将字符串反转？\"></a>7、如何将字符串反转？</h2><p>将对象封装到stringBuilder中，调用reverse方法反转。</p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709658384085.png\" alt=\"1709658384085\"></p>\n<h2 id=\"16、-3-0-1-0-3-返回值是什么\"><a href=\"#16、-3-0-1-0-3-返回值是什么\" class=\"headerlink\" title=\"16、 3*0.1 &#x3D;&#x3D; 0.3 返回值是什么\"></a>16、 3*0.1 &#x3D;&#x3D; 0.3 返回值是什么</h2><p>false,因为有些浮点数不能完全精确的表示出来.</p>\n<h2 id=\"17-Java-中有哪些类加载器★★★★★\"><a href=\"#17-Java-中有哪些类加载器★★★★★\" class=\"headerlink\" title=\"17 Java 中有哪些类加载器★★★★★\"></a>17 Java 中有哪些类加载器★★★★★</h2><p>JDK ⾃带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。 BootStrapClassLoader 是 ExtClassLoader 的⽗类加载器，默认负责加载%JAVA_HOME%lib 下的 jar 包和 class ⽂件。 ExtClassLoader 是 AppClassLoader 的⽗类加载器，负责加载%JAVA_HOME%&#x2F;lib&#x2F;ext ⽂件夹下的 jar 包和 class 类。 AppClassLoader 是⾃定义类加载器的⽗类，负责加载 classpath 下的类⽂件</p>\n<h2 id=\"16-hashCode-和-equals-方法有何重要性？★★★★★\"><a href=\"#16-hashCode-和-equals-方法有何重要性？★★★★★\" class=\"headerlink\" title=\"16.hashCode()和 equals()方法有何重要性？★★★★★\"></a>16.hashCode()和 equals()方法有何重要性？★★★★★</h2><h3 id=\"★★★★★\"><a href=\"#★★★★★\" class=\"headerlink\" title=\"★★★★★\"></a>★★★★★</h3><p>HashMap 使用 Key 对象的 hashCode()和 equals()方法去决定 key-value 对的索引。点击这里一</p>\n<p>文搞懂它们之间的关系。</p>\n<p>当我们试着从 HashMap 中获取值的时候，这些方法也会被用到。如果这些方法没有被正确</p>\n<p>地实现，在这种情况下，两个不同 Key 也许会产生相同的 hashCode()和 equals()输出，HashMap</p>\n<p>将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。</p>\n<p>同样的，所有不允许存储重复数据的集合类都使用 hashCode()和 equals()去查找重复，所以</p>\n<p>正确实现它们非常重要。equals()和 hashCode()的实现应该遵循以下规则：</p>\n<p>1.如果 o1.equals(o2)，那么 o1.hashCode() &#x3D;&#x3D; o2.hashCode()总是为 true 的。</p>\n<p>2.如果 o1.hashCode() &#x3D;&#x3D; o2.hashCode()，并不意味着 o1.equals(o2)会为 true。</p>\n<h2 id=\"17-Map-接口提供了哪些不同的集合视图？\"><a href=\"#17-Map-接口提供了哪些不同的集合视图？\" class=\"headerlink\" title=\"17.Map 接口提供了哪些不同的集合视图？\"></a>17.Map 接口提供了哪些不同的集合视图？</h2><p>Map 接口提供三个集合视图：</p>\n<p>1）Set keyset()：返回 map 中包含的所有 key 的一个 Set 视图。集合是受 map 支持的，map</p>\n<p>的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若 map 被修</p>\n<p>改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过 Iterator</p>\n<p>更多关注 Java 大后端公众号的 Remove、Set.remove、removeAll、retainAll 和 clear 操作进行元素移除，从 map 中移除对</p>\n<p>应的映射。</p>\n<p>它不支持 add 和 addAll 操作。</p>\n<p>2）Collection values()：返回一个 map 中包含的所有 value 的一个 Collection 视图。这个 collection</p>\n<p>受 map 支持的，map 的变化会在 collection 中反映出来，反之亦然。当一个迭代器正在遍历</p>\n<p>一个 collection 时，若 map 被修改了（除迭代器自身的移除操作以外），迭代器的结果会变</p>\n<p>为未定义。集合支持通过 Iterator 的 Remove、Set.remove、removeAll、retainAll 和 clear 操作</p>\n<p>进行元素移除，从 map 中移除对应的映射。它不支持 add 和 addAll 操作。</p>\n<p>3）Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：返回一个 map 钟包含的所有映射的一个集合视图。这个</p>\n<p>集合受 map 支持的，map 的变化会在 collection 中反映出来，反之亦然。当一个迭代器正在</p>\n<p>遍历一个集合时，若 map 被修改了（除迭代器自身的移除操作，以及对迭代器返回的 entry</p>\n<p>进行 setValue 外），迭代器的结果会变为未定义。集合支持通过 Iterator 的 Remove、Set.remove、</p>\n<p>removeAll、retainAll 和 clear 操作进行元素移除，从 map 中移除对应的映射。它不支持 add</p>\n<p>和 addAll 操作。</p>\n<h2 id=\"hashCode与equals★★★★★\"><a href=\"#hashCode与equals★★★★★\" class=\"headerlink\" title=\"hashCode与equals★★★★★\"></a>hashCode与equals★★★★★</h2><p>hashCode介绍：<br>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是<br>确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有<br>hashCode() 函数。<br>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用<br>到了散列码！（可以快速找到所需要的对象）<br>为什么要有hashCode：<br>以“HashSet如何检查重复”为例子来说明为什么要有hashCode：<br>对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有<br>值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals（）方法来<br>检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会<br>重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。<br>如果两个对象相等，则hashcode一定也是相同的<br>两个对象相等,对两个对象分别调用equals方法都返回true<br>两个对象有相同的hashcode值，它们也不一定是相等的<br>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖<br><em><strong>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则</strong></em><em><strong>该class的两个<br>对象无论如何都不会相等（即使这两个对象指向相同的数据）</strong></em></p>\n<h2 id=\"18-HashMap-和-HashTable-有何不同？\"><a href=\"#18-HashMap-和-HashTable-有何不同？\" class=\"headerlink\" title=\"18.HashMap 和 HashTable 有何不同？\"></a>18.HashMap 和 HashTable 有何不同？</h2><p>（1）HashMap 允许 key 和 value 为 null，而 HashTable 不允许。</p>\n<p>（2）HashTable 是同步的，而 HashMap 不是。所以 HashMap 适合单线程环境，HashTable</p>\n<p>适合多线程环境。</p>\n<p>（3）在 Java1.4 中引入了 LinkedHashMap，HashMap 的一个子类，假如你想要遍历顺序，你</p>\n<p>很容易从 HashMap 转向 LinkedHashMap，但是 HashTable 不是这样的，它的顺序是不可预知</p>\n<p>的。</p>\n<p>（4）HashMap 提供对 key 的 Set 进行遍历，因此它是 fail-fast 的，但 HashTable 提供对 key</p>\n<p>的 Enumeration 进行遍历，它不支持 fail-fast。</p>\n<p>（5）HashTable 被认为是个遗留的类，如果你寻求在迭代的时候修改 Map，你应该使用</p>\n<p>CocurrentHashMap。</p>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><h2 id=\"java集合超详解-java集合使用-CSDN博客\"><a href=\"#java集合超详解-java集合使用-CSDN博客\" class=\"headerlink\" title=\"[java集合超详解_java集合使用-CSDN博客]\"></a>[<a href=\"https://blog.csdn.net/feiyanaffection/article/details/81394745\">java集合超详解_java集合使用-CSDN博客</a>]</h2><p><img src=\"/images/1%E3%80%81JAVA/1709657326301.png\" alt=\"1709657326301\"></p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709657362460.png\" alt=\"1709657362460\"></p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709657394941.png\" alt=\"1709657394941\"></p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709205810985.png\" alt=\"1709205810985\"></p>\n<p><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#set\">Set</a></p>\n<ul>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#treeset\">TreeSet</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#hashset\">HashSet</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#linkedhashset\">LinkedHashSet</a></li>\n</ul>\n<p><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#list\">List</a></p>\n<ul>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#arraylist\">ArrayList </a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#vector\">Vector</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#linkedlist\">LinkedList</a></li>\n</ul>\n<p><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#queue\">Queue</a></p>\n<ul>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#linkedlist-1\">LinkedList</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#priorityqueue\">PriorityQueue</a></li>\n</ul>\n<p><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#map\">Map</a></p>\n<ul>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#treemap\">TreeMap</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#hashmap\">HashMap</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#hashtable\">HashTable</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#linkedhashmap\">LinkedHashMap</a></li>\n</ul>\n<p>list</p>\n<p>ArrayList     底层数据结构是动态数组，查询快，增删慢。线程不安全，效率高</p>\n<p>Vector       底层数据结构是数组，查询快，增删慢。线程安全，效率低</p>\n<p>LinkedList 底层数据结构是链表，查询慢，增删快 线程不安全，效率高</p>\n<p>set</p>\n<p>Treeset 红黑树</p>\n<p>Hashset</p>\n<ul>\n<li>底层其实是包装了一个HashMap实现的</li>\n<li>底层数据结构是数组+链表 + 红黑树</li>\n<li>具有比较好的读取和查找性能， 可以有null 值</li>\n<li>通过equals和HashCode来判断两个元素是否相等</li>\n<li>非线程安全</li>\n</ul>\n<p>LinedHashkset</p>\n<ul>\n<li>继承HashSet，本质是LinkedHashMap实现</li>\n<li>底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。</li>\n<li>有序的，根据HashCode的值来决定元素的存储位置，同时使用一个链表来维护元素的插入顺序</li>\n<li>非线程安全，可以有null 值</li>\n</ul>\n<p>map</p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709208051453.png\" alt=\"1709208051453\"></p>\n<p>Hashmap 哈希表</p>\n<p>特点是访问速度快，遍历顺序不确定，线程不安全，最多允许一个key为null，允许多个value为null。</p>\n<ul>\n<li>可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap类。</li>\n</ul>\n<p>Treemap 红黑树</p>\n<ul>\n<li>TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。</li>\n</ul>\n<p>LinkedHashmap 双向链表</p>\n<ul>\n<li>LinkedHashMap继承了HashMap，是Map接口的哈希表和链接列表实现，它维护着一个双重链接列表，此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</li>\n</ul>\n<p>HashTable</p>\n<p>Hashmap底层原理</p>\n<p><strong>HashMap的底层是数组+链表+红黑树实现的。集合put时，通过计算key键的哈希值来放入元素。若有key值相同的哈希值时，会通过链表进行存放，链表长度达到8时会开辟红黑树进行存放，以此提高查询效率</strong>..</p>\n<h2 id=\"ArrayList-和-Vector-有何异同点？\"><a href=\"#ArrayList-和-Vector-有何异同点？\" class=\"headerlink\" title=\"ArrayList 和 Vector 有何异同点？\"></a>ArrayList 和 Vector 有何异同点？</h2><p><strong>ArrayList 和 Vector 在很多时候都很类似。</strong></p>\n<p>（1）两者都是基于索引的，内部由一个数组支持。</p>\n<p>（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。</p>\n<p>（3）ArrayList 和 Vector 的迭代器实现都是 fail-fast 的。</p>\n<p>（4）ArrayList 和 Vector 两者允许 null 值，也可以使用索引值对元素进行随机访问。</p>\n<p><strong>以下是 ArrayList 和 Vector 的不同点。</strong></p>\n<p>（1）Vector 是同步的，而 ArrayList 不是。然而，如果你寻求在迭代的时候对列表进行改变，</p>\n<p>你应该使用 CopyOnWriteArrayList。</p>\n<p>（2）ArrayList 比 Vector 快，它因为有同步，不会过载。</p>\n<p>（3）ArrayList 更加通用，因为我们可以使用 Collections 工具类轻易地获取同步列表和只读</p>\n<p>列表。</p>\n<h2 id=\"ArrayList-和-LinkedList-有何区别？\"><a href=\"#ArrayList-和-LinkedList-有何区别？\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 有何区别？\"></a>ArrayList 和 LinkedList 有何区别？</h2><p><img src=\"/images/1%E3%80%81JAVA/1709479433567.png\" alt=\"1709479433567\"></p>\n<p>ArrayList 和 LinkedList 两者都实现了 List 接口，但是它们之间有些不同。</p>\n<p>1）ArrayList 是由 Array 所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，</p>\n<p>复杂度为 O(1)，但 LinkedList 存储一系列的节点数据，每个节点都与前一个和下一个节点相</p>\n<p>连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引</p>\n<p>的节点然后返回元素，时间复杂度为 O(n)，比 ArrayList 要慢。</p>\n<p>2）与 ArrayList 相比，在 LinkedList 中插入、添加和删除一个元素会更快，因为在一个元素被</p>\n<p>插入到中间的时候，不会涉及改变数组的大小，或更新索引。</p>\n<p>3）LinkedList 比 ArrayList 消耗更多的内存，因为 LinkedList 中的每个节点存储了前后节点的</p>\n<p>引用。</p>\n<p>.哪些集合类提供对元素的随机访问？</p>\n<p>ArrayList、HashMap、TreeMap 和 HashTable 类提供对元素的随机访问。</p>\n<p>24.哪些集合类是线程安全的？</p>\n<p>Vector、HashTable、Properties 和 Stack 是同步类，所以它们是线程安全的，可以在多线程环</p>\n<p>境下使用。Java1.5 并发 API 包括一些集合类，允许迭代时修改，因为它们都工作在集合的</p>\n<p>克隆上，所以它们在多线程环境中是安全的。</p>\n<h2 id=\"HashMap-和-HashSet-区别\"><a href=\"#HashMap-和-HashSet-区别\" class=\"headerlink\" title=\"HashMap 和 HashSet 区别\"></a>HashMap 和 HashSet 区别</h2><p><img src=\"/images/1%E3%80%81JAVA/1709211409103.png\" alt=\"1709211409103\"></p>\n<h2 id=\"比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同\"><a href=\"#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同\" class=\"headerlink\" title=\"比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同\"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><p>HashSet 是 Set 接口的主要实现类 ，HashSet 的底层是 HashMap，线程不安全的，可以存储 null<br>值；<br>LinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历；<br>TreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p>\n<h1 id=\"2、多线程\"><a href=\"#2、多线程\" class=\"headerlink\" title=\"2、多线程\"></a>2、多线程</h1><h2 id=\"sleep-wait-join-yield-区别★★★★★\"><a href=\"#sleep-wait-join-yield-区别★★★★★\" class=\"headerlink\" title=\"sleep(), wait(), join(), yield()区别★★★★★\"></a>sleep(), wait(), join(), yield()区别★★★★★</h2><p>sleep()和wait<br>sleep()方法是Thread类的静态本地方法, wait()则是Object类的本地方法(where)<br>sleep一般用于当前线程休眠，或者轮循暂停操作，wait则多用于多线程之间的通信。(作用)<br>sleep方法不依赖于同步器synchronized, 但是wait需要依赖synchronized(依赖)<br>sleep方法不会释放锁, 但是wait会释放锁(锁)<br>sleep不需要被唤醒（休眠之后推出阻塞)，但是wait需要〈不指定时间需要被别人中断)。(醒)<br>where 作用 依赖 锁 醒</p>\n<p>yield<br>yield()执行后线程直接进入就绪状态, 马上释放cpu执行权, 但是依然保留cpu的执行资格, 所以cpu下次进行线程调度还可能会让这个线程去的执行权<br>join()执行后线程进入阻塞状态, 例如在线程B中调用线程A的join(), 那线程B会进入阻塞队列, 直到线程A结束或中断结束<br>例如t1线程正在执行, t2线程调用了t1.join(), 那线程B就会立即进入阻塞队列, 直到线程A结束或者中断线程</p>\n<h2 id=\"线程同步方式\"><a href=\"#线程同步方式\" class=\"headerlink\" title=\"线程同步方式\"></a>线程同步方式</h2><p>1、Java通过加锁实现线程同步,锁有两类：synchronized和Lock。  2、synchronized加在三个不同的位置,对应三种不同的使用方式,这三种方式的区别是锁对象不同：  （1.）加在普通方法上,则锁是当前的实例（this）。 （2.）加在静态方法上,锁是当前类的Class对象。 （3.）加在代码块上,则需要在关键字后面的小括号里,显式指定一个对象作为锁对象。</p>\n<h2 id=\"并发的三大特性\"><a href=\"#并发的三大特性\" class=\"headerlink\" title=\"并发的三大特性\"></a>并发的三大特性</h2><p>原子性 原子性是指在一个操作中 cpu 不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要 不都不执行。</p>\n<p>可见性 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>\n<p>有序性 虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按 照我们写的代码 的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，虽然对 变量的值没有造成影响，但有可能会出现线程安全问题。</p>\n<h2 id=\"线程有几种状态\"><a href=\"#线程有几种状态\" class=\"headerlink\" title=\"线程有几种状态\"></a>线程有几种状态</h2><p><img src=\"/images/1%E3%80%81JAVA/1709658004796.png\" alt=\"1709658004796\"></p>\n<p>1.线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。</p>\n<p>2.阻塞的情况又分为三种：</p>\n<p>(1)、等待阻塞：运行的线程执行 wait 方法，该线程会释放占用的所有资源，JVM 会把该线程放入“等待 池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用 notify 或 notifyAll 方法才能被唤 醒，wait 是 object 类的方法</p>\n<p>(2)、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放 入“锁池”中。</p>\n<p>(3)、其他阻塞：运行的线程执行 sleep 或 join 方法，或者发出了 I&#x2F;O 请求时，JVM 会把该线程置为阻塞状 态。当 sleep 状态超时、join 等待线程终止或者超时、或者 I&#x2F;O 处理完毕时，线程重新转入就绪状态。 sleep 是 Thread 类的方法 1.新建状态（New）：新创建了一个线程对象。 2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的 start 方法。该状态的线程位于 可运行线程池中，变得可运行，等待获取 CPU 的使用权。 3.运行状态（Running）：就绪状态的线程获取了 CPU，执行程序代码。</p>\n<p>4.阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进 入就绪状态，才有机会转到运行状态。 5.死亡状态（Dead）：线程执行完了或者因异常退出了 run 方法，该线程结束生命周期</p>\n<h2 id=\"juc是什么\"><a href=\"#juc是什么\" class=\"headerlink\" title=\"juc是什么\"></a>juc是什么</h2><p>JUC即java.util.concurrent,包含了支持并发操作的各种工具。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"></a>\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\</h2><h1 id=\"3、Nginx\"><a href=\"#3、Nginx\" class=\"headerlink\" title=\"3、Nginx\"></a>3、Nginx</h1><h2 id=\"1、请解释一下什么是-Nginx\"><a href=\"#1、请解释一下什么是-Nginx\" class=\"headerlink\" title=\"1、请解释一下什么是 Nginx?\"></a><strong>1、请解释一下什么是 Nginx?</strong></h2><p>Nginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3 和</p>\n<p>IMAP 协议。</p>\n<h2 id=\"2、请列举-Nginx-的一些特性。\"><a href=\"#2、请列举-Nginx-的一些特性。\" class=\"headerlink\" title=\"2、请列举 Nginx 的一些特性。\"></a><strong>2、请列举 Nginx 的一些特性。</strong></h2><p>Nginx 服务器的特性包括：</p>\n<p>反向代理&#x2F;L7 负载均衡器</p>\n<p>嵌入式 Perl 解释器</p>\n<p>动态二进制升级</p>\n<p>可用于重新编写 URL，具有非常好的 PCRE 支持</p>\n<h2 id=\"3、请列举-Nginx-和-Apache-之间的不同点\"><a href=\"#3、请列举-Nginx-和-Apache-之间的不同点\" class=\"headerlink\" title=\"3、请列举 Nginx 和 Apache 之间的不同点\"></a><strong>3、请列举 Nginx 和 Apache 之间的不同点</strong></h2><h2 id=\"4、请解释-Nginx-如何处理-HTTP-请求。\"><a href=\"#4、请解释-Nginx-如何处理-HTTP-请求。\" class=\"headerlink\" title=\"4、请解释 Nginx 如何处理 HTTP 请求。\"></a><strong>4、请解释 Nginx 如何处理 HTTP 请求。</strong></h2><p>Nginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数</p>\n<p>据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提</p>\n<p>供数万个并发连接。</p>\n<h2 id=\"5、在-Nginx-中，如何使用未定义的服务器名称来阻止处理请求\"><a href=\"#5、在-Nginx-中，如何使用未定义的服务器名称来阻止处理请求\" class=\"headerlink\" title=\"5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?\"></a><strong>5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?</strong></h2><p>只需将请求删除的服务器就可以定义为：</p>\n<p>Server {listen 80;server_name “ “ ;return 444;</p>\n<p>}</p>\n<p>这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下匹</p>\n<p>配请求，而一个特殊的 Nginx 的非标准代码 444 被返回，从而终止连接。</p>\n<h2 id=\"6、-使用“反向代理服务器”的优点是什么\"><a href=\"#6、-使用“反向代理服务器”的优点是什么\" class=\"headerlink\" title=\"6、 使用“反向代理服务器”的优点是什么?\"></a><strong>6、 使用“反向代理服务器”的优点是什么?</strong></h2><p>更多关注 Java 大后端公众号更多关注 Java 大后端公众号</p>\n<p>反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器</p>\n<p>之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服务时。</p>\n<h2 id=\"7、请列举-Nginx-服务器的最佳用途。\"><a href=\"#7、请列举-Nginx-服务器的最佳用途。\" class=\"headerlink\" title=\"7、请列举 Nginx 服务器的最佳用途。\"></a><strong>7、请列举 Nginx 服务器的最佳用途。</strong></h2><p>Nginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应用</p>\n<p>程序服务器、用于脚本的 FastCGI 处理程序。它还可以作为负载均衡器。</p>\n<h2 id=\"8、请解释-Nginx-服务器上的-Master-和-Worker-进程分别是什么\"><a href=\"#8、请解释-Nginx-服务器上的-Master-和-Worker-进程分别是什么\" class=\"headerlink\" title=\"8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?\"></a><strong>8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?</strong></h2><p>Master 进程：读取及评估配置和维持</p>\n<p>Worker 进程：处理请求</p>\n<h2 id=\"9、请解释你如何通过不同于-80-的端口开启-Nginx\"><a href=\"#9、请解释你如何通过不同于-80-的端口开启-Nginx\" class=\"headerlink\" title=\"9、请解释你如何通过不同于 80 的端口开启 Nginx?\"></a><strong>9、请解释你如何通过不同于 80 的端口开启 Nginx?</strong></h2><p>为了通过一个不同的端口开启 Nginx，你必须进入&#x2F;etc&#x2F;Nginx&#x2F;sites-enabled&#x2F;，</p>\n<p>如果这是默认文件，那么你必须打开名为“default”的文件。编辑文件，并放</p>\n<p>置在你想要的端口：</p>\n<p>Like server { listen 81; }</p>\n<h2 id=\"10、请解释是否有可能将-Nginx-的错误替换为-502-错误、503\"><a href=\"#10、请解释是否有可能将-Nginx-的错误替换为-502-错误、503\" class=\"headerlink\" title=\"10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?\"></a><strong>10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?</strong></h2><p>502 &#x3D;错误网关</p>\n<p>503 &#x3D;服务器超载</p>\n<p>有可能，但是您可以确保 fastcgi_intercept_errors 被设置为 ON，并使用错误</p>\n<p>页面指令。</p>\n<p>Location &#x2F; {fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors</p>\n<p>on;error_page 502 &#x3D;503&#x2F;error_page.html;#…}</p>\n<h2 id=\"11、在-Nginx-中，解释如何在-URL-中保留双斜线\"><a href=\"#11、在-Nginx-中，解释如何在-URL-中保留双斜线\" class=\"headerlink\" title=\"11、在 Nginx 中，解释如何在 URL 中保留双斜线?\"></a><strong>11、在 Nginx 中，解释如何在 URL 中保留双斜线?</strong></h2><p>要在 URL 中保留双斜线，就必须使用 merge_slashes_off;</p>\n<p>语法:merge_slashes [on&#x2F;off]更多关注 Java 大后端公众号</p>\n<p>默认值: merge_slashes on</p>\n<p>环境: http，server</p>\n<h2 id=\"12、请解释-ngx-http-upstream-module-的作用是什么\"><a href=\"#12、请解释-ngx-http-upstream-module-的作用是什么\" class=\"headerlink\" title=\"12、请解释 ngx_http_upstream_module 的作用是什么?\"></a><strong>12、请解释 ngx_http_upstream_module 的作用是什么?</strong></h2><p>ngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi</p>\n<p>传递、memcached 传递和 scgi 传递指令来引用的服务器组。</p>\n<h2 id=\"13、请解释什么是-C10K-问题\"><a href=\"#13、请解释什么是-C10K-问题\" class=\"headerlink\" title=\"13、请解释什么是 C10K 问题?\"></a><strong>13、请解释什么是 C10K 问题?</strong></h2><p>C10K 问题是指无法同时处理大量客户端(10,000)的网络套接字。</p>\n<h2 id=\"14、请陈述-stub-status-和-sub-filter-指令的作用是什么\"><a href=\"#14、请陈述-stub-status-和-sub-filter-指令的作用是什么\" class=\"headerlink\" title=\"14、请陈述 stub_status 和 sub_filter 指令的作用是什么?\"></a><strong>14、请陈述 stub_status 和 sub_filter 指令的作用是什么?</strong></h2><p>Stub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活动</p>\n<p>连接，接受和处理当前读&#x2F;写&#x2F;等待连接的总数</p>\n<p>Sub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据</p>\n<h2 id=\"15、解释-Nginx-是否支持将请求压缩到上游\"><a href=\"#15、解释-Nginx-是否支持将请求压缩到上游\" class=\"headerlink\" title=\"15、解释 Nginx 是否支持将请求压缩到上游?\"></a><strong>15、解释 Nginx 是否支持将请求压缩到上游?</strong></h2><p>您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤器，</p>\n<p>它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编码:gzip”来</p>\n<p>解压缩响应。</p>\n<h2 id=\"16、解释如何在-Nginx-中获得当前的时间\"><a href=\"#16、解释如何在-Nginx-中获得当前的时间\" class=\"headerlink\" title=\"16、解释如何在 Nginx 中获得当前的时间?\"></a><strong>16、解释如何在 Nginx 中获得当前的时间?</strong></h2><p>要获得 Nginx 的当前时间，必须使用 SSI 模块、$date_gmt 和$date_local 的变</p>\n<p>量。</p>\n<p>Proxy_set_header THE-TIME $date_gmt;</p>\n<h2 id=\"17、用-Nginx-服务器解释-s-的目的是什么\"><a href=\"#17、用-Nginx-服务器解释-s-的目的是什么\" class=\"headerlink\" title=\"17、用 Nginx 服务器解释-s 的目的是什么?\"></a><strong>17、用 Nginx 服务器解释-s 的目的是什么?</strong></h2><p>用于运行 Nginx -s 参数的可执行文件。</p>\n<h2 id=\"18、解释如何在-Nginx-服务器上添加模块\"><a href=\"#18、解释如何在-Nginx-服务器上添加模块\" class=\"headerlink\" title=\"18、解释如何在 Nginx 服务器上添加模块?\"></a><strong>18、解释如何在 Nginx 服务器上添加模块?</strong></h2><p>在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选择。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\\\\\\\\\"></a>\\\\\\\\</h2><p>1、请解释一下什么是 Nginx?</p>\n<p>Nginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3</p>\n<p>和 IMAP 协议。</p>\n<p>2、请列举 Nginx 的一些特性。</p>\n<p>Nginx 服务器的特性包括：</p>\n<p>反向代理&#x2F;L7 负载均衡器</p>\n<p>嵌入式 Perl 解释器</p>\n<p>动态二进制升级</p>\n<p>可用于重新编写 URL，具有非常好的 PCRE 支持</p>\n<p>3、请列举 Nginx 和 Apache 之间的不同点</p>\n<p>4、请解释 Nginx 如何处理 HTTP 请求。</p>\n<p>Nginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样</p>\n<p>数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可</p>\n<p>以提供数万个并发连接。</p>\n<p>5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?</p>\n<p>只需将请求删除的服务器就可以定义为：</p>\n<p>Server {listen 80;server_name “ “ ;return 444;</p>\n<p>}</p>\n<p>这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下</p>\n<p>匹配请求，而一个特殊的 Nginx 的非标准代码 444 被返回，从而终止连接。</p>\n<p>6、 使用“反向代理服务器”的优点是什么?</p>\n<p>反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务</p>\n<p>器之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服</p>\n<p>务时。</p>\n<p>7、请列举 Nginx 服务器的最佳用途。Nginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应</p>\n<p>用程序服务器、用于脚本的 FastCGI 处理程序。它还可以作为负载均衡器。</p>\n<p>8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?</p>\n<p>Master 进程：读取及评估配置和维持</p>\n<p>Worker 进程：处理请求</p>\n<p>9、请解释你如何通过不同于 80 的端口开启 Nginx?</p>\n<p>为了通过一个不同的端口开启 Nginx，你必须进入&#x2F;etc&#x2F;Nginx&#x2F;sites\u0002</p>\n<p>enabled&#x2F;，如果这是默认文件，那么你必须打开名为“default”的文件。编辑</p>\n<p>文件，并放置在你想要的端口：</p>\n<p>Like server { listen 81; }</p>\n<p>10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?</p>\n<p>502 &#x3D;错误网关</p>\n<p>503 &#x3D;服务器超载</p>\n<p>有可能，但是您可以确保 fastcgi_intercept_errors 被设置为 ON，并使用错</p>\n<p>误页面指令。</p>\n<p>Location &#x2F; {fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors</p>\n<p>on;error_page 502 &#x3D;503&#x2F;error_page.html;#…}</p>\n<p>11、在 Nginx 中，解释如何在 URL 中保留双斜线?</p>\n<p>要在 URL 中保留双斜线，就必须使用 merge_slashes_off;</p>\n<p>语法:merge_slashes [on&#x2F;off]</p>\n<p>默认值: merge_slashes on</p>\n<p>环境: http，server</p>\n<p>12、请解释 ngx_http_upstream_module 的作用是什么?</p>\n<p>ngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi</p>\n<p>传递、memcached 传递和 scgi 传递指令来引用的服务器组。</p>\n<p>13、请解释什么是 C10K 问题?C10K 问题是指无法同时处理大量客户端(10,000)的网络套接字。</p>\n<p>14、请陈述 stub_status 和 sub_filter 指令的作用是什么?</p>\n<p>Stub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活</p>\n<p>动连接，接受和处理当前读&#x2F;写&#x2F;等待连接的总数</p>\n<p>Sub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据</p>\n<p>15、解释 Nginx 是否支持将请求压缩到上游?</p>\n<p>您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤</p>\n<p>器，它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编</p>\n<p>码:gzip”来解压缩响应。</p>\n<p>16、解释如何在 Nginx 中获得当前的时间?</p>\n<p>要获得 Nginx 的当前时间，必须使用 SSI 模块、$date_gmt 和$date_local 的变</p>\n<p>量。</p>\n<p>Proxy_set_header THE-TIME $date_gmt;</p>\n<p>17、用 Nginx 服务器解释-s 的目的是什么?</p>\n<p>用于运行 Nginx -s 参数的可执行文件。</p>\n<p>18、解释如何在 Nginx 服务器上添加模块?</p>\n<p>在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选</p>\n<p>择。</p>\n<h1 id=\"4、spring\"><a href=\"#4、spring\" class=\"headerlink\" title=\"4、spring\"></a>4、spring</h1><h2 id=\"1、springboot\"><a href=\"#1、springboot\" class=\"headerlink\" title=\"1、springboot\"></a>1、springboot</h2><h3 id=\"1、什么是-Spring-Boot？\"><a href=\"#1、什么是-Spring-Boot？\" class=\"headerlink\" title=\"1、什么是 Spring Boot？\"></a><strong>1、什么是 Spring Boot？</strong></h3><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是</p>\n<p>简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p>\n<p>更多 Spring Boot 详细介绍请看这篇文章《什么是 Spring Boot?》。</p>\n<h3 id=\"2、为什么要用-Spring-Boot？\"><a href=\"#2、为什么要用-Spring-Boot？\" class=\"headerlink\" title=\"2、为什么要用 Spring Boot？\"></a><strong>2、为什么要用 Spring Boot？</strong></h3><p>Spring Boot 优点非常多，如：</p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709736051227.png\" alt=\"1709736051227\"></p>\n<p> 独立运行</p>\n<p> 简化配置</p>\n<p> 自动配置</p>\n<p> 无代码生成和 XML 配置</p>\n<p> 应用监控</p>\n<p> 上手容易</p>\n<p>Spring Boot 集这么多优点于一身，还有理由不使用它呢？</p>\n<h3 id=\"5、Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？\"><a href=\"#5、Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？\" class=\"headerlink\" title=\"5、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？\"></a><strong>5、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</strong></h3><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要</p>\n<p>组合包含了以下 3 个注解：</p>\n<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>\n<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，</p>\n<p>如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D;</p>\n<p>{ DataSourceAutoConfiguration.class })。</p>\n<p>@ComponentScan：Spring 组件扫描。</p>\n<h3 id=\"6、开启-Spring-Boot-特性有哪几种方式？\"><a href=\"#6、开启-Spring-Boot-特性有哪几种方式？\" class=\"headerlink\" title=\"6、开启 Spring Boot 特性有哪几种方式？\"></a><strong>6、开启 Spring Boot 特性有哪几种方式？</strong></h3><p>1）继承 spring-boot-starter-parent 项目</p>\n<p>2）导入 spring-boot-dependencies 项目依赖</p>\n<p>具体请参考这篇文章《Spring Boot 开启的 2 种方式》。</p>\n<p>更多关注 Java 大后端公众号<strong>7、Spring Boot 需要独立的容器运行吗？</strong></p>\n<p>可以不需要，内置了 Tomcat&#x2F; Jetty 等容器。</p>\n<h3 id=\"8、运行-Spring-Boot-有哪几种方式？\"><a href=\"#8、运行-Spring-Boot-有哪几种方式？\" class=\"headerlink\" title=\"8、运行 Spring Boot 有哪几种方式？\"></a><strong>8、运行 Spring Boot 有哪几种方式？</strong></h3><p>1）打包用命令或者放到容器中运行</p>\n<p>2）用 Maven&#x2F; Gradle 插件运行</p>\n<p>3）直接执行 main 方法运行</p>\n<h3 id=\"9、Spring-Boot-自动配置原理是什么？\"><a href=\"#9、Spring-Boot-自动配置原理是什么？\" class=\"headerlink\" title=\"9、Spring Boot 自动配置原理是什么？\"></a><strong>9、Spring Boot 自动配置原理是什么？</strong></h3><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动</p>\n<p>配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。</p>\n<p>Spring Boot 自动配置原理？</p>\n<p>@Import + @Configuration + Spring spi 图灵学院 自动配置类由各个 starter 提供，使用@Configuration + @Bean 定义配置类，放到 META\u0002INF&#x2F;spring.factories 下 使用 Spring spi 扫描 META-INF&#x2F;spring.factories 下的配置类 使用@Import 导入自动配置类具体看这篇文章《Spring Boot 自动配置原理、实战》。</p>\n<h2 id=\"2、spring-MVC\"><a href=\"#2、spring-MVC\" class=\"headerlink\" title=\"2、spring MVC\"></a>2、spring MVC</h2><h3 id=\"1、什么是-SpringMvc？\"><a href=\"#1、什么是-SpringMvc？\" class=\"headerlink\" title=\"1、什么是 SpringMvc？\"></a>1、什么是 SpringMvc？</h3><p>答：SpringMvc 是 spring 的一个模块，基于 MVC 的一个框架，无需中间整合层来整合。</p>\n<h3 id=\"2、Spring-MVC-的优点：\"><a href=\"#2、Spring-MVC-的优点：\" class=\"headerlink\" title=\"2、Spring MVC 的优点：\"></a>2、Spring MVC 的优点：</h3><p>答：</p>\n<p>1）它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java</p>\n<p>组件.并且和 Spring 提供的其他基础结构紧密集成.</p>\n<p>2）不依赖于 Servlet API(目标虽是如此,但是在实现的时候确实是依赖于 Servlet 的)</p>\n<p>3）可以任意使用各种视图技术,而不仅仅局限于 JSP</p>\n<p>4）支持各种请求资源的映射策略</p>\n<p>5）它应是易于扩展的</p>\n<h3 id=\"3、SpringMVC-工作原理？\"><a href=\"#3、SpringMVC-工作原理？\" class=\"headerlink\" title=\"3、SpringMVC 工作原理？\"></a>3、SpringMVC 工作原理？</h3><p>答：</p>\n<p>1）客户端发送请求到 DispatcherServlet</p>\n<p>2）DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller</p>\n<p>3）Controller 调用业务逻辑后，返回 ModelAndView</p>\n<p>4）DispatcherServlet 查询 ModelAndView，找到指定视图</p>\n<p>5）视图将结果返回到客户端</p>\n<h3 id=\"4、SpringMVC-流程？★★★★★\"><a href=\"#4、SpringMVC-流程？★★★★★\" class=\"headerlink\" title=\"4、SpringMVC 流程？★★★★★\"></a>4、SpringMVC 流程？★★★★★</h3><p>1）用户发送请求至前端控制器 DispatcherServlet。</p>\n<p>2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。</p>\n<p>3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器对象</p>\n<p>及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。</p>\n<p>更多关注 Java 大后端公众号 4）DispatcherServlet 调用 HandlerAdapter 处理器适配器。</p>\n<p>5）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)。</p>\n<p>6）Controller 执行完成返回 ModelAndView。</p>\n<p>7）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。</p>\n<p>8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。</p>\n<p>9）ViewReslover 解析后返回具体 View。</p>\n<p>10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</p>\n<p>11）DispatcherServlet 响应用户。</p>\n<h2 id=\"3、spring\"><a href=\"#3、spring\" class=\"headerlink\" title=\"3、spring\"></a>3、spring</h2><p><img src=\"/images/1%E3%80%81JAVA/1709742703501.png\" alt=\"1709742703501\"></p>\n<h2 id=\"BeanFactory和ApplicationContext有什么区别-不熟\"><a href=\"#BeanFactory和ApplicationContext有什么区别-不熟\" class=\"headerlink\" title=\"BeanFactory和ApplicationContext有什么区别(不熟)\"></a>BeanFactory和ApplicationContext有什么区别(不熟)</h2><p>ApplicationContext接口作为BeanFactory的子类,除了提供BeanFactory所具有的功能外,还提供了更完整的框架功能:<br>①继承MessageSource,因此支持国际化<br>②资源文件访问，如URL和文件（ResourceLoader）<br>③载入多个（有继承关系）上下文（及同时加载多个配置文件），使得每一个上下文都专注于一个特定的层次<br>④提供在监听器中注册bean的事件；</p>\n<h2 id=\"Spring是什么\"><a href=\"#Spring是什么\" class=\"headerlink\" title=\"Spring是什么\"></a>Spring是什么</h2><p>Spring 是一个轻量级的控制翻转(IOC)和面向切面(AOP)的容器框架</p>\n<p>从大小与开销两方面而言Spring都是轻量级的</p>\n<p>包含并且管理Bean的配置和生命周期,又通过控制反转和依赖注入来达到松耦合, 在这个意义上是一个Bean容器,</p>\n<p>提供了面向切面编程的丰富支持, 允许通过分离应用的业务逻辑和系统级 服务进行内聚性的开发<br>将简单的组件配置, 组合为复杂的应用, 这个意义上是一个框架<br>谈谈你对AOP的理解<br>系统是由许多不同的组件所组成的, 每一个组件各负责着一些功能, 除了主要业务功能之外, 有些组件比如日志, 事务管理和安全等服务会水平散布到所有对象层次中去,<br>OOP运行从上到下的关系但是并不适合定义从左到右的关系, 所以如果仍然按照OOP设计就会有大量代码的重复; 如果使用AOP就会将这些功能封装为一个切面, 然后注入到目标对象中, 而且AOP还可以对对象进行增强, 去做一些额外的事情.<br>谈谈你对IOC的理解<br>容器概念, 控制翻转, 依赖注入</p>\n<p>(容器概念)IOC容器中存有自己配置获取的一些Bean(比如@Repository, @Service, @Controller), 在项目启动时使用反射创建对应的对象放到map中 ;(依赖注入) 这时候map中就有各种对象了, 接下来通过bean的配置文件中去获取xml文件中该bean节点下的, 根据其ref属性进行依赖注入, 注入到对应的注解下(@Autowired或者@Resource)<br>控制翻转: 控制翻转就是一个概念, 就是对象通过IOC容器和依赖注入自动进行装配, 就相当于原本属于程序员对对象创建的控制权交给了IOC<br>总结来说, 就是IOC通过容器概念, 控制翻转和依赖注入成为了整个系统的关键核心, 它起到一种类似”粘合剂”的作用, 把系统中的所有对象粘合起来一起发挥作用.</p>\n<h2 id=\"12-spring用了哪些设计模式\"><a href=\"#12-spring用了哪些设计模式\" class=\"headerlink\" title=\"12.spring用了哪些设计模式\"></a>12.spring用了哪些设计模式</h2><p>BeanFactory用了工厂模式，AOP用了动态代理模式，RestTemplate用来模板方法模式，SpringMVC中handlerAdaper用来适配器模式，Spring里的监听器用了观察者模式</p>\n<h2 id=\"14-SpringMV工作原理★★★★★\"><a href=\"#14-SpringMV工作原理★★★★★\" class=\"headerlink\" title=\"14.SpringMV工作原理★★★★★\"></a>14.SpringMV工作原理★★★★★</h2><p>SpringMVC工作过程围绕着前端控制器DispatchServerlet，几个重要组件有HandleMapping（处理器映射器）、HandleAdapter（处理器适配器）、ViewReslover（试图解析器）</p>\n<p>工作流程：</p>\n<p>（1）DispatchServerlet接收用户请求将请求发送给HandleMapping</p>\n<p>（2）HandleMapping根据请求url找到具体的handle和拦截器，返回给DispatchServerlet</p>\n<p>（3）DispatchServerlet调用HandleAdapter,HandleAdapter执行具体的controller，并将controller返回的ModelAndView返回给DispatchServler</p>\n<p>（4）DispatchServerlet将ModelAndView传给ViewReslover,ViewReslover解析后返回具体view</p>\n<p>（5）DispatchServerlet根据view进行视图渲染，返回给用户</p>\n<h2 id=\"谈谈你对AOP的理解★★★★★\"><a href=\"#谈谈你对AOP的理解★★★★★\" class=\"headerlink\" title=\"谈谈你对AOP的理解★★★★★\"></a>谈谈你对AOP的理解★★★★★</h2><p>系统是由许多不同的组件所组成的, 每一个组件各负责着一些功能, 除了主要业务功能之外, 有些组件比如日志, 事务管理和安全等服务会水平散布到所有对象层次中去,<br>OOP运行从上到下的关系但是并不适合定义从左到右的关系, 所以如果仍然按照OOP设计就会有大量代码的重复; 如果使用AOP就会将这些功能封装为一个切面, 然后注入到目标对象中, 而且AOP还可以对对象进行增强, 去做一些额外的事情.</p>\n<h2 id=\"谈谈你对IOC的理解★★★★★\"><a href=\"#谈谈你对IOC的理解★★★★★\" class=\"headerlink\" title=\"谈谈你对IOC的理解★★★★★\"></a>谈谈你对IOC的理解★★★★★</h2><p>容器概念, 控制翻转, 依赖注入</p>\n<p>(容器概念)IOC容器中存有自己配置获取的一些Bean(比如@Repository, @Service, @Controller), 在项目启动时使用反射创建对应的对象放到map中 ;(依赖注入) 这时候map中就有各种对象了, 接下来通过bean的配置文件中去获取xml文件中该bean节点下的, 根据其ref属性进行依赖注入, 注入到对应的注解下(@Autowired或者@Resource)<br>控制翻转: 控制翻转就是一个概念, 就是对象通过IOC容器和依赖注入自动进行装配, 就相当于原本属于程序员对对象创建的控制权交给了IOC<br>总结来说, 就是IOC通过容器概念, 控制翻转和依赖注入成为了整个系统的关键核心, 它起到一种类似”粘合剂”的作用, 把系统中的所有对象粘合起来一起发挥作用.</p>\n<h2 id=\"bean的作用域\"><a href=\"#bean的作用域\" class=\"headerlink\" title=\"bean的作用域\"></a>bean的作用域</h2><p>singleton：在Spring容器中仅存在一个实例，即Bean以单例的形式存在。<br>prototype：为每一个bean请求提供一个实例。<br>request ：每次HTTP请求都会创建一个新的Bean。<br>session：同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。<br>globalSession：同一个全局的Session共享一个Bean，一般用于Portlet环境</p>\n<h2 id=\"bean的自动装配\"><a href=\"#bean的自动装配\" class=\"headerlink\" title=\".bean的自动装配\"></a>.bean的自动装配</h2><ul>\n<li>@Autowried：通过byType方式实现，并且要求这个对象存在</li>\n<li>@Resouce：默认通过byName方式实现，如果name找不到再通过byType实现</li>\n</ul>\n<h3 id=\"1、什么是-Spring-框架？Spring-框架有哪些主要模块？\"><a href=\"#1、什么是-Spring-框架？Spring-框架有哪些主要模块？\" class=\"headerlink\" title=\"1、什么是 Spring 框架？Spring 框架有哪些主要模块？\"></a>1、什么是 Spring 框架？Spring 框架有哪些主要模块？</h3><p>轻量级的开源的 J2EE 框架。它是一个容器框架，用来装 javabean（java 对象），中间层框架（万能胶） 可以起一个连接作用，比如说把 Struts 和 hibernate 粘合在一起运用，可以让我们的企业开发更快、更简 洁 Spring 是一个轻量级的控制反转（IoC)和面向切面（AOP）的容器框架</p>\n<p>谈谈你对AOP的理解<br>AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象<br>（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增<br>强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情</p>\n<h2 id=\"依赖注入的三种方式\"><a href=\"#依赖注入的三种方式\" class=\"headerlink\" title=\"依赖注入的三种方式\"></a>依赖注入的三种方式</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>常用的注入方式主要有三种：构造方法注入（Construct注入），setter注入，基于注解的注入（接口注入）</p></blockquote>\n<h3 id=\"3、什么是控制反转-IOC-？什么是依赖注入？\"><a href=\"#3、什么是控制反转-IOC-？什么是依赖注入？\" class=\"headerlink\" title=\"3、什么是控制反转(IOC)？什么是依赖注入？\"></a>3、什么是控制反转(IOC)？什么是依赖注入？</h3><p>控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象</p>\n<p>之间耦合关系在编译时通常是未知的。在传统的编程方式中，业 务逻辑的流程是由应用程序中的早</p>\n<p>已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来</p>\n<p>决定的，该对象关系图由装配 器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽</p>\n<p>象化。而绑定的过程是通过“依赖注入”实现的。</p>\n<p>控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了</p>\n<p>有效的作用。</p>\n<p>依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实</p>\n<p>例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的</p>\n<p>基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？</p>\n<h2 id=\"在-Java-中依然注入有以下三种实现方式：★★★★★\"><a href=\"#在-Java-中依然注入有以下三种实现方式：★★★★★\" class=\"headerlink\" title=\"在 Java 中依然注入有以下三种实现方式：★★★★★\"></a>在 Java 中依然注入有以下三种实现方式：★★★★★</h2><ol>\n<li>构造器注入</li>\n<li>Setter 方法注入</li>\n<li>接口注入</li>\n</ol>\n<h3 id=\"4、请解释下-Spring-框架中的-IoC？\"><a href=\"#4、请解释下-Spring-框架中的-IoC？\" class=\"headerlink\" title=\"4、请解释下 Spring 框架中的 IoC？\"></a>4、请解释下 Spring 框架中的 IoC？</h3><p>Spring 中的 org.springframework.beans 包和 org.springframework.context 包</p>\n<p>构成了 Spring 框架 IoC 容器的基础。</p>\n<p>BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。</p>\n<p>ApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory</p>\n<p>的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource</p>\n<p>的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的</p>\n<p>WebApplicationContext。</p>\n<p>org.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现，</p>\n<p>用来包装和管理前面提到的各种 bean。BeanFactory 接口是 Spring IoC 容器的核心接口。</p>\n<p>IOC:把对象的创建、初始化、销毁交给 spring 来管理，而不是由开发者控制，实现控制反转。</p>\n<h3 id=\"5、BeanFactory-和-ApplicationContext-有什么区别？\"><a href=\"#5、BeanFactory-和-ApplicationContext-有什么区别？\" class=\"headerlink\" title=\"5、BeanFactory 和 ApplicationContext 有什么区别？\"></a>5、BeanFactory 和 ApplicationContext 有什么区别？</h3><p><img src=\"/images/1%E3%80%81JAVA/1709478839382.png\" alt=\"1709478839382\"></p>\n<p>BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在</p>\n<p>接收到客户端请求时将对应的 bean 实例化。</p>\n<p>BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的</p>\n<p>配置中解放出来。BeanFactory 还包含 了 bean 生命周期的控制，调用客户端的初始化方法</p>\n<p>（initialization methods）和销毁方法（destruction methods）。</p>\n<p>从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，</p>\n<p>根据请求分发 bean 的功能。但 applicationcontext 在此基础上还提供了其他的功能。</p>\n<ol>\n<li>提供了支持国际化的文本消息</li>\n<li>统一的资源文件读取方式</li>\n<li>已在监听器中注册的 bean 的事件</li>\n</ol>\n<p>以下是三种较常见的 ApplicationContext 实现方式：</p>\n<p>1、ClassPathXmlApplicationContext：从 classpath 的 XML 配置文件中读取上下文，并生成上</p>\n<p>下文定义。应用程序上下文从程序环境变量中</p>\n<p>ApplicationContext context &#x3D; new</p>\n<p>ClassPathXmlApplicationContext(“bean.xml”);</p>\n<p>2、FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。</p>\n<p>ApplicationContext context &#x3D; new</p>\n<p>FileSystemXmlApplicationContext(“bean.xml”);</p>\n<p>3、XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。</p>\n<p>4.AnnotationConfigApplicationContext(基于 Java 配置启动容器)</p>\n<p><img src=\"/images/1%E3%80%81JAVA/1708002876939.png\" alt=\"1708002876939\"></p>\n<h3 id=\"6、Spring-有几种配置方式？\"><a href=\"#6、Spring-有几种配置方式？\" class=\"headerlink\" title=\"6、Spring 有几种配置方式？\"></a>6、Spring 有几种配置方式？</h3><p>将 Spring 配置到应用开发中有以下三种方式：</p>\n<ol>\n<li>基于 XML 的配置</li>\n<li>基于注解的配置</li>\n<li>基于 Java 的配置</li>\n</ol>\n<p>1.什么是 spring?</p>\n<p>Spring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用，但是有些</p>\n<p>扩展是针对构建 J2EE 平台的 web 应用。Spring 框架目标是简化 Java 企业级应用开发，并</p>\n<p>通过 POJO 为基础的编程模型促进良好的编程习惯。</p>\n<h3 id=\"2-使用-Spring-框架的好处是什么？★★★★★\"><a href=\"#2-使用-Spring-框架的好处是什么？★★★★★\" class=\"headerlink\" title=\"2.使用 Spring 框架的好处是什么？★★★★★\"></a>2.使用 Spring 框架的好处是什么？★★★★★</h3><p> 轻量：Spring 是轻量的，基本的版本大约 2MB。</p>\n<p> 控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建</p>\n<p>或查找依赖的对象们。</p>\n<p> 面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务</p>\n<p>分开。</p>\n<p> 容器：Spring 包含并管理应用中对象的生命周期和配置。</p>\n<p> MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。</p>\n<p> 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事</p>\n<p>务（JTA）。</p>\n<p> 异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，HibernateorJDO</p>\n<p>抛出的）转化为一致的 unchecked 异常。</p>\n<h3 id=\"14-IOC-的优点是什么？\"><a href=\"#14-IOC-的优点是什么？\" class=\"headerlink\" title=\"14.IOC 的优点是什么？\"></a>14.IOC 的优点是什么？</h3><p>IOC 或依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和</p>\n<p>JNDI 查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC 容器支持加载服务时</p>\n<p>的饿汉式初始化和懒加载。</p>\n<h3 id=\"15-ApplicationContext-通常的实现是什么\"><a href=\"#15-ApplicationContext-通常的实现是什么\" class=\"headerlink\" title=\"15.ApplicationContext 通常的实现是什么?\"></a>15.ApplicationContext 通常的实现是什么?</h3><p> FileSystemXmlApplicationContext：此容器从一个 XML 文件中加载 beans 的定义，</p>\n<p>XMLBean 配置文件的全路径名必须提供给它的构造函数。</p>\n<p> ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans 的定义，这</p>\n<p>里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。</p>\n<p> WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个 WEB 应用的</p>\n<p>所有 bean。</p>\n<h3 id=\"16-Bean-工厂和-Applicationcontexts-有什么区别？\"><a href=\"#16-Bean-工厂和-Applicationcontexts-有什么区别？\" class=\"headerlink\" title=\"16.Bean 工厂和 Applicationcontexts 有什么区别？\"></a>16.Bean 工厂和 Applicationcontexts 有什么区别？</h3><p>Applicationcontexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如</p>\n<p>镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内的对象上执行</p>\n<p>的那些不得不由 bean 工厂以程序化方式处理的操作，可以在 Applicationcontexts 中以声</p>\n<p>明的方式处理。Applicationcontexts 实现了 MessageSource 接口，该接口的实现以可插拔</p>\n<p>的方式提供获取本地化消息的方法。</p>\n<h3 id=\"19-有哪些不同类型的-IOC（依赖注入）方式？\"><a href=\"#19-有哪些不同类型的-IOC（依赖注入）方式？\" class=\"headerlink\" title=\"19.有哪些不同类型的 IOC（依赖注入）方式？\"></a>19.有哪些不同类型的 IOC（依赖注入）方式？</h3><p>更多关注 Java 大后端公众号  构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系</p>\n<p>列参数，每个参数代表一个对其他类的依赖。</p>\n<p> Setter 方法注入：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂方法</p>\n<p>实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注入。</p>\n<h3 id=\"11、-解释-Spring-支持的几种-bean-的作用域。\"><a href=\"#11、-解释-Spring-支持的几种-bean-的作用域。\" class=\"headerlink\" title=\"11、 解释 Spring 支持的几种 bean 的作用域。\"></a>11、 解释 Spring 支持的几种 bean 的作用域。</h3><p>Spring 容器中的 bean 可以分为 5 个范围：</p>\n<p>（1）singleton：默认，每个容器中只有一个 bean 的实例，单例的模式由 BeanFactory 自身来维护。</p>\n<p>（2）prototype：为每一个 bean 请求提供一个实例。</p>\n<p>（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回 收。</p>\n<p>（4）session：与 request 范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。</p>\n<p>（5）global-session：全局作用域，global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器 中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局 变量需要存储在 global-session 中。全局作用域与 Servlet 中的 session 作用域效果相同。25.解释 Spring 支持的几种 bean 的作用域。★★★★★</p>\n<h2 id=\"★★★★★Spring-基于-xml-注入-bean-的几种方式：\"><a href=\"#★★★★★Spring-基于-xml-注入-bean-的几种方式：\" class=\"headerlink\" title=\"★★★★★Spring 基于 xml 注入 bean 的几种方式：\"></a>★★★★★Spring 基于 xml 注入 bean 的几种方式：</h2><p>（1）Set 方法注入；</p>\n<p>（2）构造器注入：① 通过 index 设置参数的位置；② 通过 type 设置参数类型； （3）静态工厂注入； （4）实例工厂；</p>\n<h2 id=\"Spring-Boot、Spring-MVC-和-Spring-有什么区别\"><a href=\"#Spring-Boot、Spring-MVC-和-Spring-有什么区别\" class=\"headerlink\" title=\"Spring Boot、Spring MVC 和 Spring 有什么区别\"></a>Spring Boot、Spring MVC 和 Spring 有什么区别</h2><p>spring 是一个 IOC 容器，用来管理 Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提 供 AOP 机制弥补 OOP 的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给 方法执行，比如日志、异常等 springmvc 是 spring 对 web 框架的一个解决方案，提供了一个总的前端控制器 Servlet，用来接收请求， 然后定义了一套路由策略（url 到 handle 的映射）及适配执行 handle，将 handle 结果使用视图解析技术 生成视图展现给前端 springboot 是 spring 提供的一个快速开发工具包，让程序员能更方便、更快速的开发 spring+springmvc 应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter 机制）、redis、 mongodb、es，可以开箱即用</p>\n<h2 id=\"和-的区别是什么？★★★★★\"><a href=\"#和-的区别是什么？★★★★★\" class=\"headerlink\" title=\"#{}和${}的区别是什么？★★★★★\"></a>#{}和${}的区别是什么？★★★★★</h2><p>#{}是预编译处理、是占位符， ${}是字符串替换、是拼接符。 Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 来赋值； Mybatis 在处理${}时， 就是把${}替换成变量的值，调用 Statement 来赋值； #{} 的变量替换是在 DBMS 中、变量替换后，#{} 对应的变量自动加上单引号 ${} 的变量替换是在 DBMS 外、变量替换后，${} 对应的变量不会加上单引号 使用#{}可以有效的防止 SQL 注入， 提高系统安全性。</p>\n<h2 id=\"缓存雪崩、缓存穿透、缓存击穿★★★★★\"><a href=\"#缓存雪崩、缓存穿透、缓存击穿★★★★★\" class=\"headerlink\" title=\"缓存雪崩、缓存穿透、缓存击穿★★★★★\"></a>缓存雪崩、缓存穿透、缓存击穿★★★★★</h2><p>4.缓存穿透、缓存击穿、缓存雪崩<br>缓存穿透：客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数据。<br>解决方案：缓存空对象；布隆过滤器<br>缓存击穿：一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。<br>解决方案：热点数据永不过期；加互斥锁<br>缓存雪崩<br>解决方案：设置过期时间时，附加一个随机数，避免数据同时过期；</p>\n<p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内 承受大量请求而崩掉。 解决方案：</p>\n<ul>\n<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>\n<li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓 存。</li>\n<li>缓存预热</li>\n<li>互斥锁</li>\n</ul>\n<p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承 受大量请求而崩掉。</p>\n<ul>\n<li>解决方案： 接口层增加校验，如用户鉴权校验，id 做基础校验，id&lt;&#x3D;0 的直接拦截；</li>\n<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有 效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户 反复用同一个 id 暴力攻击</li>\n<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据 会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li>\n</ul>\n<p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同 时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪 崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查 数据库。</p>\n<p>解决方案</p>\n<ul>\n<li>设置热点数据永远不过期。</li>\n<li>加互斥锁</li>\n</ul>\n<h1 id=\"Mybatis\"><a href=\"#Mybatis\" class=\"headerlink\" title=\"Mybatis\"></a>Mybatis</h1><p>2、MyBatis 的优点和缺点 优点：</p>\n<ol>\n<li>（1）基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重 用。</li>\n<li>（2）与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；</li>\n<li>（3）很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。</li>\n<li>（4）能够与 Spring 很好的集成； （5）提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系 组件维护。</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>（1）SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定 要求。</li>\n<li>（2）SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>\n</ol>\n<h2 id=\"和-的区别是什么？\"><a href=\"#和-的区别是什么？\" class=\"headerlink\" title=\"#{}和${}的区别是什么？\"></a>#{}和${}的区别是什么？</h2><p>#{}是预编译处理，${}是字符串替换。 Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值； Mybatis 在处理${}时，就是把${}替换成变量的值。 使用#{}可以有效的防止 SQL 注入，提高系统安全性。</p>\n<h1 id=\"5、ES\"><a href=\"#5、ES\" class=\"headerlink\" title=\"5、ES\"></a>5、ES</h1><h3 id=\"1-为什么要使用-ES？\"><a href=\"#1-为什么要使用-ES？\" class=\"headerlink\" title=\"1.为什么要使用 ES？\"></a>1.为什么要使用 ES？</h3><p>虽然 lucene 是性能最先进的、功能完善的搜索引擎，但是它只能有一个库，而且使用它需</p>\n<p>要集成到 java 项目才能使用，配置还特别复杂,而 ES 语法简单、是基于 Resultful api 风格的,</p>\n<p>它在 lucene 所有功能基础上还能集成多台服务器进行搜索，也就是集群;</p>\n<h3 id=\"2-ES-和-lucene-的区别是什么？\"><a href=\"#2-ES-和-lucene-的区别是什么？\" class=\"headerlink\" title=\"2. ES 和 lucene 的区别是什么？\"></a>2. ES 和 lucene 的区别是什么？</h3><p>lucene 是现存功能最强大、最先进搜索库，直接基于 lucene 开发，api 非常复杂大量的 java</p>\n<p>代码、需要深入了解原理</p>\n<p>对比处:</p>\n<p>只有一个索引库、</p>\n<p>传统的遍历搜索方式</p>\n<p>采用 B+树索引;</p>\n<p>Es 是基于 lucene 的，隐藏了 lucene 复杂部分的一个分布式全文检索框架</p>\n<p>对比处:</p>\n<p>一个 es 的集群包含多个索引库、</p>\n<p>分布式搜索</p>\n<p>Es 是采用倒排式索引</p>\n<p>es 没有事物概念,删除不能恢复</p>\n<p>es 开源免费</p>\n<p>正排索引：id —&gt; value</p>\n<p>倒排索引：value —&gt; id</p>\n<h3 id=\"3-你还了解哪些全文检索工具？\"><a href=\"#3-你还了解哪些全文检索工具？\" class=\"headerlink\" title=\"3.你还了解哪些全文检索工具？\"></a>3.你还了解哪些全文检索工具？</h3><p>Lucene，Solr，HadoopContrib，Katta</p>\n<h3 id=\"4-Bulk-一次最大处理多少数据量？\"><a href=\"#4-Bulk-一次最大处理多少数据量？\" class=\"headerlink\" title=\"4.Bulk 一次最大处理多少数据量？\"></a>4.Bulk 一次最大处理多少数据量？</h3><p>bulk 会把将要处理的数据载入内存中，所以数据量是有限制的</p>\n<p>最佳的数据量不是一个确定的数值，它取决于你的硬件，你的文档大小以及复杂性，你的索</p>\n<p>更多关注 Java 大后端公众号引以及搜索的负载。</p>\n<p>一般建议是 1000-5000 个文档，如果你的文档很大，可以适当减少队列,大小建议是 5-15MB，</p>\n<p>默认不能超过 100M，可以在 es 的配置文件中修改这个值 http.max_content_length: 100mb</p>\n<h3 id=\"5-ES-在高并发的情况下如何保证数据线程安全问题？\"><a href=\"#5-ES-在高并发的情况下如何保证数据线程安全问题？\" class=\"headerlink\" title=\"5.ES 在高并发的情况下如何保证数据线程安全问题？\"></a>5.ES 在高并发的情况下如何保证数据线程安全问题？</h3><p>在读数据与写数据之间如果有其他线程进行写操作，就会出问题，es 使用版本控制才避免</p>\n<p>这种问题</p>\n<p>在修改数据的时候指定版本号，操作一次版本号加 1</p>\n<h3 id=\"6-ES-管理的工具有哪些？\"><a href=\"#6-ES-管理的工具有哪些？\" class=\"headerlink\" title=\"6.ES 管理的工具有哪些？\"></a>6.ES 管理的工具有哪些？</h3><p>1）BigDesk Plugin (作者 Luká? Vl?ek)：监控 es 状态的插件,推荐！主要提供的是节点的实时</p>\n<p>状态监控，包括 jvm 的情况，linux 的情况，elasticsearch 的情况</p>\n<p>2）Elasticsearch Head Plugin (作者 Ben Birch)：很方便对 es 进行各种操作的客户端。?</p>\n<p>3）Kibana(ES 官方推荐)：Es 基于?RestAPI 调试、数据报表、数据搜索</p>\n<h3 id=\"7-ES-自动映射的规则？\"><a href=\"#7-ES-自动映射的规则？\" class=\"headerlink\" title=\"7.ES 自动映射的规则？\"></a>7.ES 自动映射的规则？</h3><p>Es 映射是用于确定字段类型，将新增的每个字段数据类型映射后确定的字段类型，常见的</p>\n<p>映射类型有基本数据类型、复杂数据类型映射有数组对象(但对象映射扁平化后相关性会丢</p>\n<p>失，不能确定哪个是哪个属性)、</p>\n<p>全局映射的方式默认映射继承_default_的配置、动态模板映射：dynamic_templates，使用动</p>\n<p>态模板映射会覆盖默认模板，可设置关键字分词，默认模板是 string 类型的。</p>\n<h1 id=\"6、面试\"><a href=\"#6、面试\" class=\"headerlink\" title=\"6、面试\"></a>6、面试</h1><h2 id=\"1、请你自我介绍一下你自己？\"><a href=\"#1、请你自我介绍一下你自己？\" class=\"headerlink\" title=\"1、请你自我介绍一下你自己？\"></a>1、请你自我介绍一下你自己？</h2><p>回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历</p>\n<p>上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究</p>\n<p>的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习</p>\n<p>无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。</p>\n<p>企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”，企</p>\n<p>业喜欢有礼貌的求职者。</p>\n<h2 id=\"2、你觉得你个性上最大的优点是什么？\"><a href=\"#2、你觉得你个性上最大的优点是什么？\" class=\"headerlink\" title=\"2、你觉得你个性上最大的优点是什么？\"></a>2、你觉得你个性上最大的优点是什么？</h2><p>回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和</p>\n<p>幽默感、乐观和友爱。</p>\n<h2 id=\"3、说说你最大的缺点？\"><a href=\"#3、说说你最大的缺点？\" class=\"headerlink\" title=\"3、说说你最大的缺点？\"></a>3、说说你最大的缺点？</h2><p>回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求</p>\n<p>职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对</p>\n<p>不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比</p>\n<p>较出色，但事实上，他已经岌岌可危了。业喜欢求职者从自己的优点说起，中间加一些小缺</p>\n<p>点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者。</p>\n<h2 id=\"4、你对加班的看法？\"><a href=\"#4、你对加班的看法？\" class=\"headerlink\" title=\"4、你对加班的看法？\"></a>4、你对加班的看法？</h2><p>回答提示：实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公</p>\n<p>司奉献。</p>\n<p>回答样本：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身</p>\n<p>心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。</p>\n<h2 id=\"5、你对薪资的要求？\"><a href=\"#5、你对薪资的要求？\" class=\"headerlink\" title=\"5、你对薪资的要求？\"></a>5、你对薪资的要求？</h2><p>回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，</p>\n<p>那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，</p>\n<p>因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这</p>\n<p>笔钱是否足以引起你对该工作的兴趣。如果你自己必须说出具体数目，请不要说一个宽泛的</p>\n<p>范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当</p>\n<p>今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。</p>\n<p>回答样本一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重</p>\n<p>的是找对工作机会，所以只要条件公平，我则不会计较太多。</p>\n<p>回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程</p>\n<p>特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。</p>\n<h2 id=\"6、你的职业规划？\"><a href=\"#6、你的职业规划？\" class=\"headerlink\" title=\"6、你的职业规划？\"></a>6、你的职业规划？</h2><p>回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多</p>\n<p>的答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地</p>\n<p>位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感</p>\n<p>兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的</p>\n<p>工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧</p>\n<p>失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司</p>\n<p>的管理思路发展”。</p>\n<h2 id=\"7、你还有什么问题要问吗？\"><a href=\"#7、你还有什么问题要问吗？\" class=\"headerlink\" title=\"7、你还有什么问题要问吗？\"></a>7、你还有什么问题要问吗？</h2><p>回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，</p>\n<p>因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人</p>\n<p>这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋</p>\n<p>升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的</p>\n<p>上进心。</p>\n<h2 id=\"8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，\"><a href=\"#8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，\" class=\"headerlink\" title=\"8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，\"></a>8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，</h2><p>你怎么办？</p>\n<p>回答提示：一段时间发现工作不适合我，有两种情况：① 如果你确实热爱这个职业，那你就</p>\n<p>要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业</p>\n<p>要求，力争减少差距；② 你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，</p>\n<p>你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</p>\n<h2 id=\"9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该\"><a href=\"#9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该\" class=\"headerlink\" title=\"9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该\"></a>9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该</h2><p>怎么做？</p>\n<p>回答提示：①.原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，</p>\n<p>婉转地表达自己的想法，看看领导是否能改变想法。② 如果领导没有采纳我的建议，我也同</p>\n<p>样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原</p>\n<p>则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</p>\n<h2 id=\"10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？\"><a href=\"#10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？\" class=\"headerlink\" title=\"10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？\"></a>10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</h2><p>回答提示：① 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法</p>\n<p>去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。② 分清责任，各负其责，</p>\n<p>如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，</p>\n<p>作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。</p>\n<p>③ 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中</p>\n<p>吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的</p>\n<p>深度和力度是否不够，以致出现了本可以避免的错误。</p>\n<p>更多关注 Java 大后端公众号 11、谈谈你对跳槽的看法？</p>\n<p>回答提示：① 正常的“跳槽”能促进人才合理流动，应该支持。② 频繁的跳槽对单位和个人</p>\n<p>双方都不利，应该反对。</p>\n<h2 id=\"12、工作中你难以和同事、上司相处，你该怎么办？\"><a href=\"#12、工作中你难以和同事、上司相处，你该怎么办？\" class=\"headerlink\" title=\"12、工作中你难以和同事、上司相处，你该怎么办？\"></a>12、工作中你难以和同事、上司相处，你该怎么办？</h2><p>回答提示：① 我会服从领导的指挥，配合同事的工作。② 我会从自身找原因，仔细分析是不</p>\n<p>是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，</p>\n<p>如果是这样的话 我会努力改正。③ 如果我找不到原因，我会找机会跟他们沟通，请他们指</p>\n<p>出我的不足，有问题就及时改正。④ 作为优秀的员工，应该时刻以大局为重，即使在一段时</p>\n<p>间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看</p>\n<p>见我在努力，总有一天会对我微笑的。</p>\n<h2 id=\"13、你对于我们公司了解多少？\"><a href=\"#13、你对于我们公司了解多少？\" class=\"headerlink\" title=\"13、你对于我们公司了解多少？\"></a>13、你对于我们公司了解多少？</h2><p>回答提示：在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加</p>\n<p>强与国外大厂的 OEM 合作，自有品牌的部分则透过海外经销商。</p>\n<h2 id=\"14、请说出你选择这份工作的动机？\"><a href=\"#14、请说出你选择这份工作的动机？\" class=\"headerlink\" title=\"14、请说出你选择这份工作的动机？\"></a>14、请说出你选择这份工作的动机？</h2><p>回答提示：这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，</p>\n<p>如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。</p>\n<h2 id=\"15、你最擅长的技术方向是什么？\"><a href=\"#15、你最擅长的技术方向是什么？\" class=\"headerlink\" title=\"15、你最擅长的技术方向是什么？\"></a>15、你最擅长的技术方向是什么？</h2><p>回答提示：说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。</p>\n<h2 id=\"16、你能为我们公司带来什么呢？\"><a href=\"#16、你能为我们公司带来什么呢？\" class=\"headerlink\" title=\"16、你能为我们公司带来什么呢？\"></a>16、你能为我们公司带来什么呢？</h2><p>回答提示：企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后</p>\n<p>说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多</p>\n<p>的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以</p>\n<p>说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需</p>\n<p>求和消费。”等等。</p>\n<h2 id=\"17、最能概括你自己的三个词是什么？\"><a href=\"#17、最能概括你自己的三个词是什么？\" class=\"headerlink\" title=\"17、最能概括你自己的三个词是什么？\"></a>17、最能概括你自己的三个词是什么？</h2><p>回答提示：我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主</p>\n<p>考官解释，</p>\n<h2 id=\"18、为什么要离职\"><a href=\"#18、为什么要离职\" class=\"headerlink\" title=\"18、为什么要离职?\"></a>18、为什么要离职?</h2><p>回答提示：回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少</p>\n<p>的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪</p>\n<p>及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的</p>\n<p>更多关注 Java 大后端公众号空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等</p>\n<p>等，回答的答案最好是积极正面的。</p>\n<p>回答样本：我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，</p>\n<p>已经达到顶峰，即沒有升迁机会。</p>\n<h2 id=\"19、对工作的期望与目标何在？\"><a href=\"#19、对工作的期望与目标何在？\" class=\"headerlink\" title=\"19、对工作的期望与目标何在？\"></a>19、对工作的期望与目标何在？</h2><p>回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解</p>\n<p>的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这</p>\n<p>时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我</p>\n<p>的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为</p>\n<p>了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目</p>\n<p>标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。</p>\n<h2 id=\"20、就你申请的这个职位，你认为你还欠缺什么？\"><a href=\"#20、就你申请的这个职位，你认为你还欠缺什么？\" class=\"headerlink\" title=\"20、就你申请的这个职位，你认为你还欠缺什么？\"></a>20、就你申请的这个职位，你认为你还欠缺什么？</h2><p>回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的</p>\n<p>求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可</p>\n<p>以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学</p>\n<p>习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地</p>\n<p>躲过难题的求职者。</p>\n<h2 id=\"21、你通常如何处理別人的批评？\"><a href=\"#21、你通常如何处理別人的批评？\" class=\"headerlink\" title=\"21、你通常如何处理別人的批评？\"></a>21、你通常如何处理別人的批评？</h2><p>回答提示：① 沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。② 我会</p>\n<p>等大家冷靜下来再讨论。</p>\n<h2 id=\"22、怎样对待自己的失敗？\"><a href=\"#22、怎样对待自己的失敗？\" class=\"headerlink\" title=\"22、怎样对待自己的失敗？\"></a>22、怎样对待自己的失敗？</h2><p>回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。</p>\n<h2 id=\"23、什么会让你有成就感？\"><a href=\"#23、什么会让你有成就感？\" class=\"headerlink\" title=\"23、什么会让你有成就感？\"></a>23、什么会让你有成就感？</h2><p>回答提示：为贵公司竭力效劳，尽我所能，完成一个项目。</p>\n<h2 id=\"24、你为什么愿意到我们公司来工作？\"><a href=\"#24、你为什么愿意到我们公司来工作？\" class=\"headerlink\" title=\"24、你为什么愿意到我们公司来工作？\"></a>24、你为什么愿意到我们公司来工作？</h2><p>回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些</p>\n<p>详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，</p>\n<p>我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市</p>\n<p>场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你</p>\n<p>已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。</p>\n<h2 id=\"25、你和别人发生过争执吗？你是怎样解决的？\"><a href=\"#25、你和别人发生过争执吗？你是怎样解决的？\" class=\"headerlink\" title=\"25、你和别人发生过争执吗？你是怎样解决的？\"></a>25、你和别人发生过争执吗？你是怎样解决的？</h2><p>更多关注 Java 大后端公众号回答提示：这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过</p>\n<p>错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，</p>\n<p>这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。</p>\n<p>考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没</p>\n<p>有外界干涉的情况下，通过妥协的方式来解决才是正确答案。</p>\n<h2 id=\"26、对这项工作，你有哪些可预见的困难？\"><a href=\"#26、对这项工作，你有哪些可预见的困难？\" class=\"headerlink\" title=\"26、对这项工作，你有哪些可预见的困难？\"></a>26、对这项工作，你有哪些可预见的困难？</h2><p>回答提示：① 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。② 可以尝试迂回</p>\n<p>战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但</p>\n<p>是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以</p>\n<p>克服。</p>\n<p>分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中</p>\n<p>的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。第一，看看应</p>\n<p>聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一</p>\n<p>下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难</p>\n<p>的态度。</p>\n<h2 id=\"27、如果我录用你，你将怎样开展工作？\"><a href=\"#27、如果我录用你，你将怎样开展工作？\" class=\"headerlink\" title=\"27、如果我录用你，你将怎样开展工作？\"></a>27、如果我录用你，你将怎样开展工作？</h2><p>回答提示： ① 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工</p>\n<p>作的具体办法。② 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就</p>\n<p>有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开</p>\n<p>展工作。”。</p>\n<p>分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知</p>\n<p>道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回</p>\n<p>避的话，此人绝对不会录用了。</p>\n<h2 id=\"28、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应\"><a href=\"#28、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应\" class=\"headerlink\" title=\"28、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应\"></a>28、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应</h2><p>该怎么做？与上级意见不一是，你将怎么办？</p>\n<p>回答提示：①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，</p>\n<p>婉转地表达自己的想法，看看领导是否能改变想法。② 如果领导没有采纳我的建议，我也同</p>\n<p>样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原</p>\n<p>则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</p>\n<h2 id=\"29、你工作经验欠缺，如何能胜任这项工作？\"><a href=\"#29、你工作经验欠缺，如何能胜任这项工作？\" class=\"headerlink\" title=\"29、你工作经验欠缺，如何能胜任这项工作？\"></a>29、你工作经验欠缺，如何能胜任这项工作？</h2><p>常规思路：① 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在</p>\n<p>乎“经验”，关键看应聘者怎样回答。② 对这个问题的回答最好要体现出应聘者的诚恳、机</p>\n<p>智、果敢及敬业。③ 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期</p>\n<p>间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。</p>\n<p>更多关注 Java 大后端公众号但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各</p>\n<p>项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我</p>\n<p>一定能胜任这个职位。”</p>\n<p>点评：这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习</p>\n<p>成绩）为好。</p>\n<h2 id=\"30、您在前一家公司的离职原因是什么？\"><a href=\"#30、您在前一家公司的离职原因是什么？\" class=\"headerlink\" title=\"30、您在前一家公司的离职原因是什么？\"></a>30、您在前一家公司的离职原因是什么？</h2><p>回答提示：① 最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”</p>\n<p>在此家招聘单位里不存在。② 避免把“离职原因”说得太详细、太具体。③ 不能掺杂主观的</p>\n<p>负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥</p>\n<p>我们某某的员工”等。④ 但也不能躲闪、回避，如“想换换环境”、“个人原因”等。⑤ 不能</p>\n<p>涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等。⑥ 尽量使解释的理由</p>\n<p>为应聘者个人形象添彩。⑦ 相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三</p>\n<p>年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步</p>\n<p>我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只</p>\n<p>有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对</p>\n<p>面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。</p>\n<p>分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考</p>\n<p>官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真</p>\n<p>诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能</p>\n<p>准假，所以辞职，这个答案一般面试官还能接受。</p>\n<h2 id=\"31、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？\"><a href=\"#31、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？\" class=\"headerlink\" title=\"31、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？\"></a>31、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</h2><p>回答提示：每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得</p>\n<p>到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重</p>\n<p>要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。</p>\n<h2 id=\"32、果你在这次面试中没有被录用，你怎么打算？\"><a href=\"#32、果你在这次面试中没有被录用，你怎么打算？\" class=\"headerlink\" title=\"32、果你在这次面试中没有被录用，你怎么打算？\"></a>32、果你在这次面试中没有被录用，你怎么打算？</h2><p>回答提示：现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有</p>\n<p>优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅</p>\n<p>仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方</p>\n<p>面来正确看待这次失败：① 要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就</p>\n<p>不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己</p>\n<p>经历了这次之后经过努力一定能行，能够超越自我。② 善于反思，对于这次面试经验要认真</p>\n<p>总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的</p>\n<p>看待自己的长短得失，做一个明白人。③ 走出阴影，要克服这一次失败带给自己的心理压力，</p>\n<p>时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④ 认真工作，回到原单位岗位</p>\n<p>上后，要实实在在、踏踏实实地工作，三十六行、行行出状元，争取在本岗位上做出一定的</p>\n<p>更多关注 Java 大后端公众号成绩。⑤ 再接再厉，成为国家公务员一直是我的梦想，以后如果有机会我仍然后再次参加竞</p>\n<p>争。</p>\n<h2 id=\"33、谈谈你过去做过的成功案例？-工作中遇到什么问题\"><a href=\"#33、谈谈你过去做过的成功案例？-工作中遇到什么问题\" class=\"headerlink\" title=\"33、谈谈你过去做过的成功案例？(工作中遇到什么问题)\"></a>33、谈谈你过去做过的成功案例？(工作中遇到什么问题)</h2><p>回答提示：举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。切</p>\n<p>忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电</p>\n<p>话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。</p>\n<h2 id=\"34、如何安排自己的时间？会不会排斥加班？\"><a href=\"#34、如何安排自己的时间？会不会排斥加班？\" class=\"headerlink\" title=\"34、如何安排自己的时间？会不会排斥加班？\"></a>34、如何安排自己的时间？会不会排斥加班？</h2><p>回答提示：基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也</p>\n<p>知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配</p>\n<p>合。</p>\n<p>分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。</p>\n<h2 id=\"35、这个职务的期许？\"><a href=\"#35、这个职务的期许？\" class=\"headerlink\" title=\"35、这个职务的期许？\"></a>35、这个职务的期许？</h2><p>回答提示：希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、</p>\n<p>我个人而言，缔造“双赢”的局面。</p>\n<p>分析：回答前不妨先询问该公司对这项职务的责任认定及归属，因为每一家公司的状况不尽</p>\n<p>相同，以免说了一堆理想抱负却发现牛头不对马嘴。</p>\n<h2 id=\"36、什么选择我们这家公司？\"><a href=\"#36、什么选择我们这家公司？\" class=\"headerlink\" title=\"36、什么选择我们这家公司？\"></a>36、什么选择我们这家公司？</h2><p>回答提示：曾经在报章杂志看过关于贵公司的报道，与自己所追求的理念有志一同。而贵公</p>\n<p>司在业界的成绩也是有目共睹的，而且对员工的教育训练、升迁等也都很有制度。</p>\n<p>分析：去面试前先做功课，了解一下该公司的背景，让对方觉得你真的很有心想得到这份工</p>\n<p>作，而不只是探探路。</p>\n<h2 id=\"37、谈谈如何适应办公室工作的新环境？\"><a href=\"#37、谈谈如何适应办公室工作的新环境？\" class=\"headerlink\" title=\"37、谈谈如何适应办公室工作的新环境？\"></a>37、谈谈如何适应办公室工作的新环境？</h2><p>回答提示：① 办公室里每个人有各自的岗位与职责，不得擅离岗位。② 根据领导指示和工作</p>\n<p>安排，制定工作计划，提前预备，并按计划完成。③ 多请示并及时汇报，遇到不明白的要虚</p>\n<p>心请教。④ 抓间隙时间，多学习，努力提高自己的政治素质和业务水平。</p>\n<h2 id=\"38、工作中学习到了些什么？\"><a href=\"#38、工作中学习到了些什么？\" class=\"headerlink\" title=\"38、工作中学习到了些什么？\"></a>38、工作中学习到了些什么？</h2><p>回答提示：这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来</p>\n<p>回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学</p>\n<p>习到哪些经验，把握这些要点做陈述，就可以轻易过关了。</p>\n<h2 id=\"39、除了本公司外，还应聘了哪些公司？\"><a href=\"#39、除了本公司外，还应聘了哪些公司？\" class=\"headerlink\" title=\"39、除了本公司外，还应聘了哪些公司？\"></a>39、除了本公司外，还应聘了哪些公司？</h2><p>回答提示：很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，</p>\n<p>更多关注 Java 大后端公众号所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，</p>\n<p>如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。</p>\n<h2 id=\"40、何时可以到职？\"><a href=\"#40、何时可以到职？\" class=\"headerlink\" title=\"40、何时可以到职？\"></a>40、何时可以到职？</h2><p>回答提示：大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司规</p>\n<p>定上班”，但如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至</p>\n<p>少要一个月的时间，应进一步说明原因，录取公司应该会通融的。</p>\n<h1 id=\"7、redis\"><a href=\"#7、redis\" class=\"headerlink\" title=\"7、redis\"></a>7、redis</h1><h2 id=\"1-redis为什么快？\"><a href=\"#1-redis为什么快？\" class=\"headerlink\" title=\"1.redis为什么快？\"></a>1.redis为什么快？</h2><p>（1）完全基于内存操作</p>\n<p>（2）数据结构简单，对数据操作简单</p>\n<p>（3）redis执行命令是单线程的，避免了上下文切换带来的性能问题，也不用考虑锁的问题</p>\n<p>(4) 采用了非阻塞的io多路复用机制，使用了单线程来处理并发的连接;内部采用的epoll+自己实现的事件分离器</p>\n<p>其实Redis不是完全多线程的，在核心的网络模型中是多线程的用来处理并发连接，但是数据的操作都是单线程。Redis坚持单线程是因为Redis是的性能瓶颈是网络延迟而不是CPU，多线程对数据读取不会带来性能提升。</p>\n<h2 id=\"Redis如何实现key的过期删除？★★★★★\"><a href=\"#Redis如何实现key的过期删除？★★★★★\" class=\"headerlink\" title=\"Redis如何实现key的过期删除？★★★★★\"></a>Redis如何实现key的过期删除？★★★★★</h2><p>采用的定期过期+惰性过期</p>\n<p>定期删除 ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。<br>惰性删除 ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。</p>\n<h2 id=\"11-Redis缓存一致性解决方案\"><a href=\"#11-Redis缓存一致性解决方案\" class=\"headerlink\" title=\"11.Redis缓存一致性解决方案\"></a>11.Redis缓存一致性解决方案</h2><p>Redis缓存一致性解决方案主要思考的是删除缓存和更新数据库的先后顺序</p>\n<p>先删除缓存后更新数据库存在的问题是可能会数据不一致，一般使用延时双删来解决，即先删除缓存，再更新数据库，休眠X秒后再次淘汰缓存。第二次删除可能导致吞吐率降低，可以考虑进行异步删除。</p>\n<p>先更新数据库后删除缓存存在的问题是会可能会更新失败，可以采用延时删除。但由于读比写快，发生这一情况概率较小。</p>\n<p>但是无论哪种策略，都可能存在删除失败的问题，解决方案是用中间件canal订阅binlog日志提取需要删除的key，然后另写一段非业务代码去获取key并尝试删除，若删除失败就把删除失败的key发送到消息队列，然后进行删除重试。</p>\n<h2 id=\"12-Redis内存淘汰策略\"><a href=\"#12-Redis内存淘汰策略\" class=\"headerlink\" title=\"12.Redis内存淘汰策略\"></a>12.Redis内存淘汰策略</h2><p>当内存不足时按设定好的策略进行淘汰，策略有(1)淘汰最久没使用的（2）淘汰一段时间内最少使用的（3）淘汰快要过期的</p>\n<h2 id=\"1、什么是-Redis？\"><a href=\"#1、什么是-Redis？\" class=\"headerlink\" title=\"1、什么是 Redis？\"></a>1、什么是 Redis？</h2><p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载</p>\n<p>在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。因为是纯</p>\n<p>内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快</p>\n<p>的 Key-Value DB。</p>\n<p>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结</p>\n<p>构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis</p>\n<p>可以用来实现很多有用的功能，比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的</p>\n<p>高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。另外 Redis 也可以对存入</p>\n<p>的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。</p>\n<p>Redis</p>\n<p>的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis</p>\n<p>适合的场景主要局限在较小数据量的高性能操作和运算上。</p>\n<h2 id=\"2、Redis-相比-memcached-有哪些优势？\"><a href=\"#2、Redis-相比-memcached-有哪些优势？\" class=\"headerlink\" title=\"2、Redis 相比 memcached 有哪些优势？\"></a>2、Redis 相比 memcached 有哪些优势？</h2><p>(1) memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型</p>\n<p>(2) redis 的速度比 memcached 快很多</p>\n<p>(3) redis 可以持久化其数据</p>\n<h2 id=\"3、Redis-支持哪几种数据类型？\"><a href=\"#3、Redis-支持哪几种数据类型？\" class=\"headerlink\" title=\"3、Redis 支持哪几种数据类型？\"></a>3、Redis 支持哪几种数据类型？</h2><p>String、List、Set、Sorted Set、hashes</p>\n<p>字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。如果是高级用户，那</p>\n<p>么还会有，如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、</p>\n<p>Geo、Pub&#x2F;Sub。</p>\n<h2 id=\"4、Redis-主要消耗什么物理资源？\"><a href=\"#4、Redis-主要消耗什么物理资源？\" class=\"headerlink\" title=\"4、Redis 主要消耗什么物理资源？\"></a>4、Redis 主要消耗什么物理资源？</h2><p>内存。</p>\n<h2 id=\"5、Redis-的全称是什么？\"><a href=\"#5、Redis-的全称是什么？\" class=\"headerlink\" title=\"5、Redis 的全称是什么？\"></a>5、Redis 的全称是什么？</h2><p>Remote Dictionary Server。</p>\n<h2 id=\"6、Redis-有哪几种数据淘汰策略？\"><a href=\"#6、Redis-有哪几种数据淘汰策略？\" class=\"headerlink\" title=\"6、Redis 有哪几种数据淘汰策略？\"></a>6、Redis 有哪几种数据淘汰策略？</h2><p>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部</p>\n<p>分的写入指令，但 DEL 和几个例外）</p>\n<p>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</p>\n<p>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有</p>\n<p>空间存放。</p>\n<p>allkeys-random: 回收随机的键使得新添加的数据有空间存放。</p>\n<p>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</p>\n<p>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数</p>\n<p>据有空间存放。</p>\n<h2 id=\"7、Redis-官方为什么不提供-Windows-版本？\"><a href=\"#7、Redis-官方为什么不提供-Windows-版本？\" class=\"headerlink\" title=\"7、Redis 官方为什么不提供 Windows 版本？\"></a>7、Redis 官方为什么不提供 Windows 版本？</h2><p>因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来</p>\n<p>兼容性等问题。</p>\n<h2 id=\"8、一个字符串类型的值能存储最大容量是多少？\"><a href=\"#8、一个字符串类型的值能存储最大容量是多少？\" class=\"headerlink\" title=\"8、一个字符串类型的值能存储最大容量是多少？\"></a>8、一个字符串类型的值能存储最大容量是多少？</h2><p>512M</p>\n<p>更多关注 Java 大后端公众号 9、为什么 Redis 需要把所有数据放到内存中？</p>\n<p>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。</p>\n<p>所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I&#x2F;O 速度为严重</p>\n<p>影响 redis 的性能。在内存越来越便宜的今天，redis 将会越来越受欢迎。 如果设置了最大</p>\n<p>使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>\n<h2 id=\"10、Redis-集群方案应该怎么做？都有哪些方案？\"><a href=\"#10、Redis-集群方案应该怎么做？都有哪些方案？\" class=\"headerlink\" title=\"10、Redis 集群方案应该怎么做？都有哪些方案？\"></a>10、Redis 集群方案应该怎么做？都有哪些方案？</h2><p>1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通 redis 无任何区别，设</p>\n<p>置好它下属的多个 redis 实例后，使用时在本需要连接 redis 的地方改为连接 twemproxy，它</p>\n<p>会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再</p>\n<p>返回 twemproxy。使用方式简便(相对 redis 只需修改连接端口)，对旧项目扩展的首选。 问</p>\n<p>题：twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的</p>\n<p>计算值的改变，数据无法自动移动到新的节点。</p>\n<p>2.codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量</p>\n<p>改变情况下，旧节点数据可恢复到新 hash 节点。</p>\n<p>3.redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概</p>\n<p>念，以及自身支持节点设置从节点。具体看官方文档介绍。</p>\n<p>4.在业务代码层实现，起几个毫无关联的 redis 实例，在代码层，对 key 进行 hash 计算，然</p>\n<p>后去对应的 redis 实例操作数据。 这种方式对 hash 层代码要求比较高，考虑部分包括，节</p>\n<p>点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>\n<h2 id=\"11、Redis-集群方案什么情况下会导致整个集群不可用？\"><a href=\"#11、Redis-集群方案什么情况下会导致整个集群不可用？\" class=\"headerlink\" title=\"11、Redis 集群方案什么情况下会导致整个集群不可用？\"></a>11、Redis 集群方案什么情况下会导致整个集群不可用？</h2><p>有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就</p>\n<p>会以为缺少 5501-11000 这个范围的槽而不可用。</p>\n<h2 id=\"12、MySQL-里有-2000w-数据，redis-中只存-20w-的数据，如何保证-redis-中的数据都是热点\"><a href=\"#12、MySQL-里有-2000w-数据，redis-中只存-20w-的数据，如何保证-redis-中的数据都是热点\" class=\"headerlink\" title=\"12、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点\"></a>12、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点</h2><p>数据？</p>\n<p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>\n<h2 id=\"13、Redis-有哪些适合的场景？\"><a href=\"#13、Redis-有哪些适合的场景？\" class=\"headerlink\" title=\"13、Redis 有哪些适合的场景？\"></a>13、Redis 有哪些适合的场景？</h2><p>更多关注 Java 大后端公众号（1）、会话缓存（Session Cache）</p>\n<p>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储</p>\n<p>（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存</p>\n<p>时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p>\n<p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。</p>\n<p>甚至广为人知的商业平台 Magento 也提供 Redis 的插件。</p>\n<p>（2）、全页缓存（FPC）</p>\n<p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了</p>\n<p>Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改</p>\n<p>进，类似 PHP 本地 FPC。</p>\n<p>再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。</p>\n<p>此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助</p>\n<p>你以最快速度加载你曾浏览过的页面。</p>\n<p>（3）、队列</p>\n<p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很</p>\n<p>好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）</p>\n<p>对 list 的 push&#x2F;pop 操作。</p>\n<p>如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项</p>\n<p>目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一</p>\n<p>个后台就是使用 Redis 作为 broker，你可以从这里去查看。</p>\n<p>（4），排行榜&#x2F;计数器</p>\n<p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted</p>\n<p>Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结</p>\n<p>构。所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，</p>\n<p>我们只需要像下面一样执行即可：</p>\n<p>更多关注 Java 大后端公众号当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你</p>\n<p>需要这样执行：</p>\n<p>ZRANGE user_scores 0 10 WITHSCORES</p>\n<p>Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据</p>\n<p>的，你可以在这里看到。</p>\n<p>（5）、发布&#x2F;订阅</p>\n<p>最后（但肯定不是最不重要的）是 Redis 的发布&#x2F;订阅功能。发布&#x2F;订阅的使用场景确实非常</p>\n<p>多。我已看见人们在社交网络连接中使用，还可作为基于发布&#x2F;订阅的脚本触发器，甚至用</p>\n<p>Redis 的发布&#x2F;订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。</p>\n<h2 id=\"14、Redis-支持的-Java-客户端都有哪些？官方推荐用哪个？\"><a href=\"#14、Redis-支持的-Java-客户端都有哪些？官方推荐用哪个？\" class=\"headerlink\" title=\"14、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？\"></a>14、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？</h2><p>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</p>\n<h2 id=\"15、Redis-和-Redisson-有什么关系？\"><a href=\"#15、Redis-和-Redisson-有什么关系？\" class=\"headerlink\" title=\"15、Redis 和 Redisson 有什么关系？\"></a>15、Redis 和 Redisson 有什么关系？</h2><p>Redisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些</p>\n<p>Java 的 对 象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map,</p>\n<p>ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore,</p>\n<p>Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, HyperLogLog)。</p>\n<h2 id=\"16、Jedis-与-Redisson-对比有什么优缺点？\"><a href=\"#16、Jedis-与-Redisson-对比有什么优缺点？\" class=\"headerlink\" title=\"16、Jedis 与 Redisson 对比有什么优缺点？\"></a>16、Jedis 与 Redisson 对比有什么优缺点？</h2><p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；Redisson</p>\n<p>实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，</p>\n<p>不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关</p>\n<p>注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>\n<h2 id=\"17、Redis-如何设置密码及验证密码？\"><a href=\"#17、Redis-如何设置密码及验证密码？\" class=\"headerlink\" title=\"17、Redis 如何设置密码及验证密码？\"></a>17、Redis 如何设置密码及验证密码？</h2><p>设置密码：config set requirepass 123456</p>\n<p>授权密码：auth 123456</p>\n<p>更多关注 Java 大后端公众号 18、说说 Redis 哈希槽的概念？</p>\n<p>Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，</p>\n<p>每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分</p>\n<p>hash 槽。</p>\n<h2 id=\"19、Redis-集群的主从复制模型是怎样的？\"><a href=\"#19、Redis-集群的主从复制模型是怎样的？\" class=\"headerlink\" title=\"19、Redis 集群的主从复制模型是怎样的？\"></a>19、Redis 集群的主从复制模型是怎样的？</h2><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主</p>\n<p>从复制模型,每个节点都会有 N-1 个复制品.</p>\n<h2 id=\"20、Redis-集群会有写操作丢失吗？为什么？\"><a href=\"#20、Redis-集群会有写操作丢失吗？为什么？\" class=\"headerlink\" title=\"20、Redis 集群会有写操作丢失吗？为什么？\"></a>20、Redis 集群会有写操作丢失吗？为什么？</h2><p>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操</p>\n<p>作。</p>\n<h2 id=\"21、Redis-集群之间是如何复制的？\"><a href=\"#21、Redis-集群之间是如何复制的？\" class=\"headerlink\" title=\"21、Redis 集群之间是如何复制的？\"></a>21、Redis 集群之间是如何复制的？</h2><p>异步复制</p>\n<h2 id=\"22、Redis-集群最大节点个数是多少？\"><a href=\"#22、Redis-集群最大节点个数是多少？\" class=\"headerlink\" title=\"22、Redis 集群最大节点个数是多少？\"></a>22、Redis 集群最大节点个数是多少？</h2><p>16384 个。</p>\n<h2 id=\"23、Redis-集群如何选择数据库？\"><a href=\"#23、Redis-集群如何选择数据库？\" class=\"headerlink\" title=\"23、Redis 集群如何选择数据库？\"></a>23、Redis 集群如何选择数据库？</h2><p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p>\n<h2 id=\"24、怎么测试-Redis-的连通性？\"><a href=\"#24、怎么测试-Redis-的连通性？\" class=\"headerlink\" title=\"24、怎么测试 Redis 的连通性？\"></a>24、怎么测试 Redis 的连通性？</h2><p>ping</p>\n<h2 id=\"25、Redis-中的管道有什么用？\"><a href=\"#25、Redis-中的管道有什么用？\" class=\"headerlink\" title=\"25、Redis 中的管道有什么用？\"></a>25、Redis 中的管道有什么用？</h2><p>一次请求&#x2F;响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命</p>\n<p>令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>\n<p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现</p>\n<p>更多关注 Java 大后端公众号支持这个功能，大大加快了从服务器下载新邮件的过程。</p>\n<h2 id=\"26、怎么理解-Redis-事务？\"><a href=\"#26、怎么理解-Redis-事务？\" class=\"headerlink\" title=\"26、怎么理解 Redis 事务？\"></a>26、怎么理解 Redis 事务？</h2><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的</p>\n<p>过程中，不会被其他客户端发送来的命令请求所打断。</p>\n<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>\n<h2 id=\"27、Redis-事务相关的命令有哪几个？\"><a href=\"#27、Redis-事务相关的命令有哪几个？\" class=\"headerlink\" title=\"27、Redis 事务相关的命令有哪几个？\"></a>27、Redis 事务相关的命令有哪几个？</h2><p>MULTI、EXEC、DISCARD、WATCH</p>\n<h2 id=\"28、Redis-key-的过期时间和永久有效分别怎么设置？\"><a href=\"#28、Redis-key-的过期时间和永久有效分别怎么设置？\" class=\"headerlink\" title=\"28、Redis key 的过期时间和永久有效分别怎么设置？\"></a>28、Redis key 的过期时间和永久有效分别怎么设置？</h2><p>EXPIRE 和 PERSIST 命令。</p>\n<h2 id=\"29、Redis-如何做内存优化？\"><a href=\"#29、Redis-如何做内存优化？\" class=\"headerlink\" title=\"29、Redis 如何做内存优化？\"></a>29、Redis 如何做内存优化？</h2><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，</p>\n<p>所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个</p>\n<p>用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户</p>\n<p>的所有信息存储到一张散列表里面.</p>\n<h2 id=\"30、Redis-回收进程如何工作的？\"><a href=\"#30、Redis-回收进程如何工作的？\" class=\"headerlink\" title=\"30、Redis 回收进程如何工作的？\"></a>30、Redis 回收进程如何工作的？</h2><p>一个客户端运行了新的命令，添加了新的数据。</p>\n<p>Redi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。</p>\n<p>一个新的命令被执行，等等。</p>\n<p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</p>\n<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不</p>\n<p>用多久内存限制就会被这个内存使用量超越。</p>\n<h2 id=\"31、Redis-回收使用的是什么算法？\"><a href=\"#31、Redis-回收使用的是什么算法？\" class=\"headerlink\" title=\"31、Redis 回收使用的是什么算法？\"></a>31、Redis 回收使用的是什么算法？</h2><p>LRU 算法</p>\n<h2 id=\"32、Redis-如何做大量数据插入？\"><a href=\"#32、Redis-如何做大量数据插入？\" class=\"headerlink\" title=\"32、Redis 如何做大量数据插入？\"></a>32、Redis 如何做大量数据插入？</h2><p>更多关注 Java 大后端公众号 Redis2.6 开始 redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工</p>\n<p>作。</p>\n<h2 id=\"33、为什么要做-Redis-分区？\"><a href=\"#33、为什么要做-Redis-分区？\" class=\"headerlink\" title=\"33、为什么要做 Redis 分区？\"></a>33、为什么要做 Redis 分区？</h2><p>分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，你</p>\n<p>最多只能使用一台机器的内存。分区使 Redis 的计算能力通过简单地增加计算机得到成倍提</p>\n<p>升,Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>\n<h2 id=\"34、你知道有哪些-Redis-分区实现方案？\"><a href=\"#34、你知道有哪些-Redis-分区实现方案？\" class=\"headerlink\" title=\"34、你知道有哪些 Redis 分区实现方案？\"></a>34、你知道有哪些 Redis 分区实现方案？</h2><p>客户端分区就是在客户端就已经决定数据会被存储到哪个 redis 节点或者从哪个 redis 节点读</p>\n<p>取。大多数客户端已经实现了客户端分区。</p>\n<p>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。</p>\n<p>代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。redis</p>\n<p>和 memcached 的一种代理实现就是 Twemproxy</p>\n<p>查询路由(Query routing) 的意思是客户端随机地请求任意一个 redis 实例，然后由 Redis 将请</p>\n<p>求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接</p>\n<p>将请求从一个 redis 节点转发到另一个 redis 节点，而是在客户端的帮助下直接 redirected 到</p>\n<p>正确的 redis 节点。</p>\n<h2 id=\"35、Redis-分区有什么缺点？\"><a href=\"#35、Redis-分区有什么缺点？\" class=\"headerlink\" title=\"35、Redis 分区有什么缺点？\"></a>35、Redis 分区有什么缺点？</h2><p>涉及多个 key 的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储</p>\n<p>到不同的 Redis 实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</p>\n<p>同时操作多个 key,则不能使用 Redis 事务.</p>\n<p>分区使用的粒度是 key，不能使用一个非常长的排序 key 存储一个数据集（The partitioning</p>\n<p>granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big</p>\n<p>sorted set）.</p>\n<p>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的 Redis 实例和主机</p>\n<p>同时收集 RDB &#x2F; AOF 文件。</p>\n<p>分区时动态扩容或缩容可能非常复杂。Redis 集群在运行时增加或者删除 Redis 节点，能做</p>\n<p>到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这</p>\n<p>种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</p>\n<h2 id=\"36、Redis-持久化数据和缓存怎么做扩容？\"><a href=\"#36、Redis-持久化数据和缓存怎么做扩容？\" class=\"headerlink\" title=\"36、Redis 持久化数据和缓存怎么做扩容？\"></a>36、Redis 持久化数据和缓存怎么做扩容？</h2><p>更多关注 Java 大后端公众号如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。</p>\n<p>如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数</p>\n<p>量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行</p>\n<p>时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。</p>\n<h2 id=\"37、分布式-Redis-是前期做还是后期规模上来了再做好？为什么？\"><a href=\"#37、分布式-Redis-是前期做还是后期规模上来了再做好？为什么？\" class=\"headerlink\" title=\"37、分布式 Redis 是前期做还是后期规模上来了再做好？为什么？\"></a>37、分布式 Redis 是前期做还是后期规模上来了再做好？为什么？</h2><p>既然 Redis 是如此的轻量（单实例只使用 1M 内存）,为防止以后的扩容，最好的办法就是一</p>\n<p>开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式</p>\n<p>运行，使用分区，在同一台服务器上启动多个实例。</p>\n<p>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可</p>\n<p>能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>\n<p>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis</p>\n<p>实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了</p>\n<p>另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</p>\n<h2 id=\"38、Twemproxy-是什么？\"><a href=\"#38、Twemproxy-是什么？\" class=\"headerlink\" title=\"38、Twemproxy 是什么？\"></a>38、Twemproxy 是什么？</h2><p>Twemproxy 是 Twitter 维护的（缓存）代理系统，代理 Memcached 的 ASCII 协议和 Redis 协</p>\n<p>议。它是单线程程序，使用 c 语言编写，运行起来非常快。它是采用 Apache 2.0 license 的开</p>\n<p>源软件。 Twemproxy 支持自动分区，如果其代理的其中一个 Redis 节点不可用时，会自动</p>\n<p>将该节点排除（这将改变原来的 keys-instances 的映射关系，所以你应该仅在把 Redis 当缓存</p>\n<p>时使用 Twemproxy)。 Twemproxy 本身不存在单点问题，因为你可以启动多个 Twemproxy 实</p>\n<p>例，然后让你的客户端去连接任意一个 Twemproxy 实例。 Twemproxy 是 Redis 客户端和服</p>\n<p>务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。</p>\n<h2 id=\"39、支持一致性哈希的客户端有哪些？\"><a href=\"#39、支持一致性哈希的客户端有哪些？\" class=\"headerlink\" title=\"39、支持一致性哈希的客户端有哪些？\"></a>39、支持一致性哈希的客户端有哪些？</h2><p>Redis-rb、Predis 等。</p>\n<h2 id=\"40、Redis-与其他-key-value-存储有什么不同？\"><a href=\"#40、Redis-与其他-key-value-存储有什么不同？\" class=\"headerlink\" title=\"40、Redis 与其他 key-value 存储有什么不同？\"></a>40、Redis 与其他 key-value 存储有什么不同？</h2><p>Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库</p>\n<p>的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外</p>\n<p>的抽象。</p>\n<p>Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡</p>\n<p>更多关注 Java 大后端公众号更多关注 Java 大后端公众号</p>\n<p>内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上</p>\n<p>相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很</p>\n<p>强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要</p>\n<p>进行随机访问。</p>\n<h2 id=\"41、Redis-的内存占用情况怎么样？\"><a href=\"#41、Redis-的内存占用情况怎么样？\" class=\"headerlink\" title=\"41、Redis 的内存占用情况怎么样？\"></a>41、Redis 的内存占用情况怎么样？</h2><p>给你举个例子： 100 万个键值对（键是 0 到 999999 值是字符串“hello world”）在我的 32</p>\n<p>位的 Mac 笔记本上 用了 100MB。同样的数据放到一个 key 里只需要 16MB，</p>\n<p>这是因为键值</p>\n<p>有一个很大的开销。 在 Memcached 上执行也是类似的结果，但是相对 Redis 的开销要小一</p>\n<p>点点，因为 Redis 会记录类型信息引用计数等等。</p>\n<p>当然，大键值对时两者的比例要好很多。</p>\n<p>64 位的系统比 32 位的需要更多的内存开销，尤其是键值对都较小时，这是因为 64 位的系</p>\n<p>统里指针占用了 8 个字节。 但是，当然，64 位系统支持更大的内存，所以为了运行大型的</p>\n<p>Redis 服务器或多或少的需要使用 64 位的系统。</p>\n<h2 id=\"42、都有哪些办法可以降低-Redis-的内存使用情况呢？\"><a href=\"#42、都有哪些办法可以降低-Redis-的内存使用情况呢？\" class=\"headerlink\" title=\"42、都有哪些办法可以降低 Redis 的内存使用情况呢？\"></a>42、都有哪些办法可以降低 Redis 的内存使用情况呢？</h2><p>如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据，</p>\n<p>因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。</p>\n<p>43、查看 Redis 使用情况及状态信息用什么命令？</p>\n<p>info</p>\n<h2 id=\"44、Redis-的内存用完了会发生什么？\"><a href=\"#44、Redis-的内存用完了会发生什么？\" class=\"headerlink\" title=\"44、Redis 的内存用完了会发生什么？\"></a>44、Redis 的内存用完了会发生什么？</h2><p>如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或者</p>\n<p>你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。</p>\n<h2 id=\"45、Redis-是单线程的，如何提高多核-CPU-的利用率？\"><a href=\"#45、Redis-是单线程的，如何提高多核-CPU-的利用率？\" class=\"headerlink\" title=\"45、Redis 是单线程的，如何提高多核 CPU 的利用率？\"></a>45、Redis 是单线程的，如何提高多核 CPU 的利用率？</h2><p>可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时</p>\n<p>候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU，你可以考虑一下分片</p>\n<p>（shard）。</p>\n<h2 id=\"46、一个-Redis-实例最多能存放多少的-keys？List、Set、Sorted-Set-他们最多能存放多少元素？理论上-Redis-可以处理多达-232-的-keys，并且在实际中进行了测试，每个实例至少存放了-2\"><a href=\"#46、一个-Redis-实例最多能存放多少的-keys？List、Set、Sorted-Set-他们最多能存放多少元素？理论上-Redis-可以处理多达-232-的-keys，并且在实际中进行了测试，每个实例至少存放了-2\" class=\"headerlink\" title=\"46、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2\"></a>46、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2</h2><p>亿 5 千万的 keys。我们正在测试一些较大的值。</p>\n<p>任何 list、set、和 sorted set 都可以放 232 个元素。</p>\n<p>换句话说，Redis 的存储极限是系统中的可用内存值。</p>\n<h2 id=\"47、Redis-常见性能问题和解决方案？\"><a href=\"#47、Redis-常见性能问题和解决方案？\" class=\"headerlink\" title=\"47、Redis 常见性能问题和解决方案？\"></a>47、Redis 常见性能问题和解决方案？</h2><p>(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件</p>\n<p>(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次</p>\n<p>(3) 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内</p>\n<p>(4) 尽量避免在压力很大的主库上增加从库</p>\n<p>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;-</p>\n<p>Slave3…</p>\n<p>这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以</p>\n<p>立刻启用 Slave1 做 Master，其他不变。</p>\n<h2 id=\"48、Redis-提供了哪几种持久化方式？\"><a href=\"#48、Redis-提供了哪几种持久化方式？\" class=\"headerlink\" title=\"48、Redis 提供了哪几种持久化方式？\"></a>48、Redis 提供了哪几种持久化方式？</h2><p>RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</p>\n<p>AOF 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢</p>\n<p>复原始的数据,AOF 命令以 redis 协议追加保存每次写的操作到文件末尾.Redis 还能对 AOF 文</p>\n<p>件进行后台重写,使得 AOF 文件的体积不至于过大.</p>\n<p>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p>\n<p>你也可以同时开启两种持久化方式, 在这种情况下, 当 redis 重启的时候会优先载入 AOF 文</p>\n<p>件来恢复原始的数据,因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集</p>\n<p>要完整.</p>\n<p>最重要的事情是了解 RDB 和 AOF 持久化方式的不同,让我们以 RDB 持久化方式开始。</p>\n<h2 id=\"49、如何选择合适的持久化方式？\"><a href=\"#49、如何选择合适的持久化方式？\" class=\"headerlink\" title=\"49、如何选择合适的持久化方式？\"></a>49、如何选择合适的持久化方式？</h2><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化</p>\n<p>更多关注 Java 大后端公众号功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只</p>\n<p>使用 RDB 持久化。</p>\n<p>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）</p>\n<p>非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除</p>\n<p>此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug。</p>\n<h2 id=\"50、修改配置不重启-Redis-会实时生效吗？\"><a href=\"#50、修改配置不重启-Redis-会实时生效吗？\" class=\"headerlink\" title=\"50、修改配置不重启 Redis 会实时生效吗？\"></a>50、修改配置不重启 Redis 会实时生效吗？</h2><p>针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式</p>\n<p>的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要</p>\n<p>重启 Redis。检索 ‘CONFIG GET *’ 命令获取更多信息。</p>\n<p>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前</p>\n<p>CONFIG 命令还不支持的配置参数的时候。</p>\n<p>\\\\\\\\\\\\\\\\</p>\n<h1 id=\"8-MySQL\"><a href=\"#8-MySQL\" class=\"headerlink\" title=\"8.MySQL\"></a>8.MySQL</h1><h2 id=\"1-、数据库的三范式是什么★★★★★\"><a href=\"#1-、数据库的三范式是什么★★★★★\" class=\"headerlink\" title=\"1**、数据库的三范式是什么★★★★★\"></a>1*<strong>*、数据库的三范式是什么★★★★★</strong></h2><p>第一范式：列不可再分</p>\n<p>第二范式：行可以唯一区分，主键约束</p>\n<p>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束</p>\n<p>且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。</p>\n<h2 id=\"2-、数据库引擎有哪些\"><a href=\"#2-、数据库引擎有哪些\" class=\"headerlink\" title=\"**2****、数据库引擎有哪些**\"></a>**2****、数据库引擎有哪些**</h2><p>如何查看 mysql 提供的所有存储引擎</p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709735857375.png\" alt=\"1709735857375\"></p>\n<p><code>mysql&gt; show engines;</code></p>\n<p>mysql 常用引擎包括：MYISAM、Innodb、Memory、MERGE</p>\n<ul>\n<li>MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对</li>\n<li>较小，对事务完整性没有要求，以 select、insert 为主的应用基本上可以使用这引擎</li>\n<li>Innodb:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键</li>\n<li>约束，并发能力强，占用空间是 MYISAM 的 2.5 倍，处理效率相对会差一些</li>\n<li>Memory:全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在 mysql 重</li>\n<li>启时会丢失，默认使用 HASH 索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变</li>\n<li>化不频繁的代码表</li>\n<li>MERGE：是一组 MYISAM 表的组合</li>\n</ul>\n<h2 id=\"3-、-InnoDB-与-MyISAM-的区别\"><a href=\"#3-、-InnoDB-与-MyISAM-的区别\" class=\"headerlink\" title=\"**3**、**InnoDB**与**MyISAM****的区别\"></a>**3**<strong>、*</strong>*InnoDB**<strong>与*</strong>*MyISAM****的区别</h2><ol>\n<li>InnoDB 支持事务，MyISAM 不支持，对于 InnoDB 每一条 SQL 语言都默认封装成事务，自动提交，</li>\n</ol>\n<p>这样会影响速度，所以最好把多条 SQL 语言放在 begin 和 commit 之间，组成一个事务；</p>\n<ol start=\"2\">\n<li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li>\n<li>InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但</li>\n</ol>\n<p>是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，</p>\n<p>因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的</p>\n<p>是数据文件的指针。主键索引和辅助索引是独立的。</p>\n<ol start=\"4\">\n<li>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而 MyISAM 用一</li>\n</ol>\n<p>个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p>\n<ol start=\"5\">\n<li>Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；</li>\n</ol>\n<p>mysql&gt; show engines;<strong>如何选择引擎？</strong></p>\n<p>如果没有特别的需求，使用默认的 Innodb 即可。</p>\n<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>\n<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如</p>\n<p>OA 自动化办公系统。</p>\n<p>**4****、数据库的事务**</p>\n<h2 id=\"4-、数据库的事务★★★★★\"><a href=\"#4-、数据库的事务★★★★★\" class=\"headerlink\" title=\"4**、数据库的事务★★★★★\"></a>4*<strong>*、数据库的事务★★★★★</strong></h2><p><strong>什么是事务？</strong></p>\n<p><strong>：</strong> 多条 sql 语句，要么全部成功，要么全部失败。</p>\n<p><strong>事务的特性：</strong></p>\n<p><strong>数据库事务特性：原子性**</strong>(Atomic)*<strong>*、一致性**</strong>(Consistency)*<strong>*、隔离性**</strong>(Isolation)*<strong>*、持久性**</strong>(Durabiliy)*<strong>*。</strong></p>\n<p><strong>简称**<strong>ACID*</strong>*。</strong></p>\n<p>原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功，整个</p>\n<p>事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。</p>\n<p>一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如 A</p>\n<p>转账 100 元给 B，不管操作是否成功，A 和 B 的账户总额是不变的。</p>\n<p>隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰</p>\n<p>持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。</p>\n<h2 id=\"事务并发产生的三种问题\"><a href=\"#事务并发产生的三种问题\" class=\"headerlink\" title=\"事务并发产生的三种问题\"></a>事务并发产生的三种问题</h2><h2 id=\"脏读：一个事务读取到了另外一个事务没有提交的数据\"><a href=\"#脏读：一个事务读取到了另外一个事务没有提交的数据\" class=\"headerlink\" title=\"脏读：一个事务读取到了另外一个事务没有提交的数据\"></a>脏读：一个事务读取到了另外一个事务没有提交的数据</h2><p>幻读：同一事务中，用同样的操作读取两次，得到的记录数不相同（数据条数）<br>不可重复读：在同一事务中，两次读取同一数据，得到内容不同（数据内容）<br>6.mysql的事务隔离级别<br>读未提交 Read uncommitted：一个事务还没有提交时，它做的变更就能被别的事务看到。<br>读提交 Read committed：一个事物提交之后，它做的变更才会被其他事务看到。<br>可重复读 Repeatable read：一个事物执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。未提交变更对其他事务也是不可见的。<br>串行化 serializable：对于同一行记录，写会加“写锁”，读会加“读锁”，当出现</p>\n<h2 id=\"innodb和myisam区别\"><a href=\"#innodb和myisam区别\" class=\"headerlink\" title=\".innodb和myisam区别\"></a>.innodb和myisam区别</h2><p>innodb支持事务；myisam不支持事务<br>innodb支持外键；myisam不支持外键<br>innodb是聚集索引，数据和索引是捆绑在一起的；myisam是非聚集索引，数据和索引分开的，这也导致他们底层B+树结构不同。<br>innodb每个表下两个文件：.frm文件中保存的是表的结构，.ibd文件中保存的是数据和索引方式<br>myisam每个表下三个文件：一个文件用来保存 表结构，一个文件用来保存 数据，一个文件用来保存 索引</p>\n<h2 id=\"5、索引问题\"><a href=\"#5、索引问题\" class=\"headerlink\" title=\"5、索引问题\"></a><strong>5</strong>、索引问题</h2><p>索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于快速获取信息。</p>\n<p>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，</p>\n<p>索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅</p>\n<p>速地找到表中的数据，而不必扫描整个数据库。</p>\n<p>.索引<br>索引是帮助MySQL高效获取数据的数据结构，通俗来讲索引就好比书本的目录，加快数据库的查询速度。<br>分类<br>按功能逻辑分<br>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个<br>唯一索引：加速查询 + 列值唯一（可以有null）<br>普通索引：仅加速查询<br>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并<br>全文索引：对文本的内容进行分词，进行搜索<br>按物理结构分<br>聚簇索引<br>非聚簇索引★★★★★</p>\n<p>mysql 有 4 种不同的索引：</p>\n<ol>\n<li>主键索引（PRIMARY）</li>\n<li>数据列不允许重复，不允许为 NULL，一个表只能有一个主键。</li>\n<li>唯一索引（UNIQUE）</li>\n<li>数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。</li>\n<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引</li>\n<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索</li>\n<li>引</li>\n<li>普通索引（INDEX）</li>\n<li>可以通过 ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引</li>\n<li>可以通过 ALTER TABLE table_name ADD INDEX index_name(column1, column2,</li>\n<li>column3); 创建组合索引</li>\n<li>全文索引（FULLTEXT）</li>\n<li>可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引</li>\n</ol>\n<p><strong>索引并非是越多越好，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时</strong></p>\n<p><strong>要花费较多的时间维护索引</strong></p>\n<ol>\n<li>索引加快数据库的检索速度</li>\n<li>索引降低了插入、删除、修改等维护任务的速度</li>\n<li>唯一索引可以确保每一行数据的唯一性</li>\n<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li>\n<li>索引需要占物理和数据空间</li>\n</ol>\n<h2 id=\"6、SQL-优化\"><a href=\"#6、SQL-优化\" class=\"headerlink\" title=\"6、SQL 优化\"></a>6、SQL 优化</h2><p>1、查询语句中不要使用 select *</p>\n<p>2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代</p>\n<p>3、减少使用 IN 或者 NOT IN ,使用 exists，not exists 或者关联查询语句替代</p>\n<p>4、or 的查询尽量用 union 或者 union all 代替(在确认没有重复数据或者不用剔除重复数据时，union</p>\n<p>all 会更好)</p>\n<p>5、应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>\n<p>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫</p>\n<p>描，如： select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null</p>\n<p>值，然后这样查询： select id from t where num&#x3D;0</p>\n<h2 id=\"7-、简单说一说-drop-、-delete-与-truncate-的区别\"><a href=\"#7-、简单说一说-drop-、-delete-与-truncate-的区别\" class=\"headerlink\" title=\"**7**、简单说一说**drop**、**delete**与**truncate****的区别**\"></a>**7**<strong>、简单说一说*</strong>*drop**<strong>、*</strong>*delete**<strong>与*</strong>*truncate****的区别**</h2><p>SQL 中的 drop、delete、truncate 都表示删除，但是三者有一些差别</p>\n<p>delete 和 truncate 只删除表的数据不删除表的结构</p>\n<p>速度,一般来说: drop&gt; truncate &gt;delete</p>\n<p>delete 语句是 dml,这个操作会放到 rollback segement 中,事务提交之后才生效;</p>\n<p>如果有相应的 trigger,执行的时候将被触发. truncate,drop 是 ddl, 操作立即生效,原数据不放到 rollback</p>\n<p>segment 中,不能回滚. 操作不触发 trigger.</p>\n<h2 id=\"8-、什么是视图\"><a href=\"#8-、什么是视图\" class=\"headerlink\" title=\"**8****、什么是视图**\"></a>**8****、什么是视图**</h2><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一</p>\n<p>个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表</p>\n<p>查询。</p>\n<h2 id=\"9-、-什么是内联接、左外联接、右外联接？\"><a href=\"#9-、-什么是内联接、左外联接、右外联接？\" class=\"headerlink\" title=\"**9****、 什么是内联接、左外联接、右外联接？**\"></a>**9****、 什么是内联接、左外联接、右外联接？**</h2><ol>\n<li>内联接（Inner Join）：匹配 2 张表中相关联的记录。</li>\n<li>左外联接（Left Outer Join）：除了匹配 2 张表中相关联的记录外，还会匹配左表中剩余的记录，</li>\n<li>右表中未匹配到的字段用 NULL 表示。</li>\n<li>右外联接（Right Outer Join）：除了匹配 2 张表中相关联的记录外，还会匹配右表中剩余的记录，</li>\n<li>左表中未匹配到的字段用 NULL 表示。在判定左表和右表时，要根据表名出现在 Outer Join 的左右</li>\n<li>位置关系。</li>\n</ol>\n<h2 id=\"10-、并发事务带来哪些问题-隔离级别\"><a href=\"#10-、并发事务带来哪些问题-隔离级别\" class=\"headerlink\" title=\"**10**、并发事务带来哪些问题**?****隔离级别**\"></a>**10**<strong>、并发事务带来哪些问题*</strong>*?****隔离级别**</h2><p><strong>脏读</strong></p>\n<p><strong>不可重复读</strong></p>\n<p><strong>幻影读</strong></p>\n<p>READ-UNCOMMITTED</p>\n<p>√</p>\n<p>√</p>\n<p>√</p>\n<p>READ-COMMITTED</p>\n<p>×</p>\n<p>√</p>\n<p>√</p>\n<p>REPEATABLE-READ</p>\n<p>×</p>\n<p>×</p>\n<p>√</p>\n<p>SERIALIZABLE</p>\n<p>×</p>\n<p>×</p>\n<p>×</p>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一</p>\n<p>数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<p><strong>脏读（**<strong>Dirty read*</strong>*）**</strong>:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到</p>\n<p>数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提</p>\n<p>交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确</p>\n<p>的。</p>\n<p><strong>丢失修改（**<strong>Lost to modify*</strong>*）**</strong>:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那</p>\n<p>么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结</p>\n<p>果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事</p>\n<p>务 1 修改 A&#x3D;A-1，事务 2 也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</p>\n<p><strong>不可重复读（**<strong>Unrepeatableread*</strong>*）**</strong>:** 指在一个事务内多次读同一数据。在这个事务还没有结束</p>\n<p>时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改</p>\n<p>导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样</p>\n<p>的情况，因此称为不可重复读。</p>\n<p><strong>幻读（**<strong>Phantom read*</strong>*）**</strong>:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接</p>\n<p>着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了</p>\n<p>一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<p><strong>不可重复读和幻读区别：</strong></p>\n<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者</p>\n<p>删除比如多次读取一条记录发现记录增多或减少了。</p>\n<h2 id=\"11-、事务隔离级别有哪些-MySQL-的默认隔离级别是\"><a href=\"#11-、事务隔离级别有哪些-MySQL-的默认隔离级别是\" class=\"headerlink\" title=\"11**、事务隔离级别有哪些**?MySQL**的默认隔离级别是**?\"></a><strong>11**<strong>、事务隔离级别有哪些*</strong>*?MySQL**<strong>的默认隔离级别是*</strong>*?</strong></h2><p><strong>SQL</strong> <strong>标准定义了四个隔离级别：</strong></p>\n<p><strong>READ-UNCOMMITTED(**<strong>读取未提交*</strong>*)**<strong>：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，</strong>可能会**</p>\n<p><strong>导致脏读、幻读或不可重复读</strong>。</p>\n<p><strong>READ-COMMITTED(**<strong>读取已提交*</strong>*)**<strong>：</strong> 允许读取并发事务已经提交的数据，</strong>可以阻止脏读，但是幻**</p>\n<p><strong>读或不可重复读仍有可能发生</strong>。</p>\n<p>**REPEATABLE-READ(**<strong>可重复读*</strong>*)****：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务</p>\n<p>自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</p>\n<p>**SERIALIZABLE(**<strong>可串行化*</strong>*)****：** 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执</p>\n<p>行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻</strong></p>\n<p><strong>读</strong>。</p>\n<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ****（可重读）**。我们可以通过</p>\n<p>SELECT @@tx_isolation; 命令来查看这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ****（可重读）**</p>\n<p>事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如</p>\n<p>SQL Server) 是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ****（可重**</p>\n<p><strong>读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 <strong>SERIALIZABLE(**<strong>可串行化*</strong>*)</strong> 隔离级</p>\n<p>别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ\u0002</strong></p>\n<p><strong>COMMITTED(**<strong>读取提交内容*</strong>*)</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEAaTABLE\u0002</strong></p>\n<p>**READ****（可重读）** 并不会有任何性能损失。</p>\n<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(**<strong>可串行化*</strong>*)</strong> 隔离级别。</p>\n<h2 id=\"12-、大表如何优化？\"><a href=\"#12-、大表如何优化？\" class=\"headerlink\" title=\"**12****、大表如何优化？**\"></a>**12****、大表如何优化？**</h2><p>当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：</p>\n<p><strong>1.</strong> <strong>限定数据的范围</strong></p>\n<p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以</p>\n<p>控制在一个月的范围内；</p>\n<p><strong>2.</strong> <strong>读**</strong>&#x2F;*<strong>*写分离</strong></p>\n<p>经典的数据库拆分方案，主库负责写，从库负责读；</p>\n<p><strong>3.</strong> <strong>垂直分区</strong></p>\n<p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，</p>\n<p>可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>\n<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大</p>\n<p>家应该就更容易理解了。</p>\n<p><strong>垂直拆分的优点：</strong> 可以使得列数据变小，在查询时减少读取的 Block 数，减少 I&#x2F;O 次数。此外，垂</p>\n<p>直分区可以简化表的结构，易于维护。</p>\n<p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起 Join 操作，可以通过在应用层进行</p>\n<p>Join 来解决。此外，垂直分区会让事务变得更加复杂；</p>\n<p><strong>4.</strong> <strong>水平分区</strong></p>\n<p>mysql&gt; SELECT @@tx_isolation;</p>\n<p>+—————–+</p>\n<p>| @@tx_isolation |</p>\n<p>+—————–+</p>\n<p>| REPEATABLE-READ |</p>\n<p>+—————–+<strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了</strong></p>\n<p><strong>分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>\n<p>水平拆分是指数据表行的拆分，表的行数超过 200 万行时，就会变慢，这时可以把一张的表的数据拆成</p>\n<p>多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据</p>\n<p>量过大对性能造成影响。</p>\n<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但</p>\n<p>由于表的数据还是在同一台机器上，其实对于提升 MySQL 并发能力没有什么意义，所以 <strong>水平拆分最好</strong></p>\n<p><strong>分库</strong> 。</p>\n<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨节点 Join 性能较</p>\n<p>差，逻辑复杂。《Java 工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、</strong></p>\n<p><strong>部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题</p>\n<p>的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络 I&#x2F;O。</p>\n<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>\n<p><strong>客户端代理： 分片逻辑在应用端，封装在**<strong>jar*</strong>*包中，通过修改或者封装**<strong>JDBC*</strong>*层来实现。</strong> 当当网的</p>\n<p><strong>Sharding-JDBC</strong> 、阿里的 TDDL 是两种比较常用的实现。</p>\n<p><strong>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在</p>\n<p>谈的 <strong>Mycat</strong> 、360 的 Atlas、网易的 DDB 等等都是这种架构的实现。</p>\n<p>详细内容可以参考： MySQL 大表优化方案: <a href=\"https://segmentfault.com/a/1190000006158186\">https://segmentfault.com/a/1190000006158186</a></p>\n<h2 id=\"13-、分库分表之后-id-主键如何处理？\"><a href=\"#13-、分库分表之后-id-主键如何处理？\" class=\"headerlink\" title=\"13**、分库分表之后**,id 主键如何处理？\"></a><strong>13**<strong>、分库分表之后*</strong>*,id</strong> <strong>主键如何处理？</strong></h2><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来</p>\n<p>支持。</p>\n<p>生成全局 id 有下面这几种方式：</p>\n<p><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的</p>\n<p>名字的标示比如文件的名字。</p>\n<p><strong>数据库自增</strong> <strong>id</strong> : 两台数据库分别设置不同步长，生成不重复 ID 的策略来实现高可用。这种方式生成</p>\n<p>的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</p>\n<p><strong>利用</strong> <strong>redis</strong> <strong>生成</strong> <strong>id :</strong> 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更</p>\n<p>加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>\n<p>**Twitter**<strong>的*</strong>*snowflake****算法** ：Github 地址：<a href=\"https://github.com/twitter-archive/snowflake%E3%80%82\">https://github.com/twitter-archive/snowflake。</a></p>\n<p><strong>美团的**<strong>Leaf*</strong>*分布式**<strong>ID*</strong>*生成系统</strong> ：Leaf 是美团开源的分布式 ID 生成器，能保证全局唯一性、趋势递</p>\n<p>增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、</p>\n<p>Zookeeper 等中间件。感觉还不错。美团技术团队的一篇文章：<a href=\"https://tech.meituan.com/2017/\">https://tech.meituan.com/2017/</a></p>\n<p>04&#x2F;21&#x2F;mt-leaf.html 。**14**<strong>、*</strong>*mysql****有关权限的表都有哪几个**</p>\n<p>MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里，由</p>\n<p>mysql_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和 host。下面分</p>\n<p>别介绍一下这些表的结构和内容：</p>\n<p>user 权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</p>\n<p>db 权限表：记录各个帐号在各个数据库上的操作权限。</p>\n<p>table_priv 权限表：记录数据表级的操作权限。</p>\n<p>columns_priv 权限表：记录数据列级的操作权限。</p>\n<p>host 权限表：配合 db 权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受</p>\n<p>GRANT 和 REVOKE 语句的影响。</p>\n<h2 id=\"15-、-mysql-有哪些数据类型\"><a href=\"#15-、-mysql-有哪些数据类型\" class=\"headerlink\" title=\"**15**、**mysql****有哪些数据类型**\"></a>**15**<strong>、*</strong>*mysql****有哪些数据类型**</h2><p>**1****、整数类型** ，包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示 1 字节、2 字节、3</p>\n<p>字节、4 字节、8 字节整数。任何整数类型都可以加上 UNSIGNED 属性，表示数据是无符号的，即非负整</p>\n<p>数。</p>\n<p>长度：整数类型可以被指定长度，例如：INT(11)表示长度为 11 的 INT 类型。长度在大多数场景是没有意</p>\n<p>义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和 UNSIGNED ZEROFILL 属性配</p>\n<p>合使用才有意义。</p>\n<p>例子，假定类型设定为 INT(5)，属性为 UNSIGNED ZEROFILL，如果用户插入的数据为 12 的话，那么数</p>\n<p>据库实际存储数据为 00012。</p>\n<p>**2****、实数类型**，包括 FLOAT、DOUBLE、DECIMAL。</p>\n<p>DECIMAL 可以用于存储比 BIGINT 还大的整型，能存储精确的小数。</p>\n<p>而 FLOAT 和 DOUBLE 是有取值范围的，并支持使用标准的浮点进行近似计算。</p>\n<p>计算时 FLOAT 和 DOUBLE 相比 DECIMAL 效率更高一些，DECIMAL 你可以理解成是用字符串进行处理。</p>\n<p>**3****、字符串类型**，包括 VARCHAR、CHAR、TEXT、BLOB</p>\n<p>VARCHAR 用于存储可变长字符串，它比定长类型更节省空间。</p>\n<p>VARCHAR 使用额外 1 或 2 个字节存储字符串长度。列长度小于 255 字节时，使用 1 字节表示，否则使用 2</p>\n<p>字节表示。</p>\n<p>VARCHAR 存储的内容超出设置的长度时，内容会被截断。</p>\n<p>CHAR 是定长的，根据定义的字符串长度分配足够的空间。</p>\n<p>CHAR 会根据需要使用空格进行填充方便比较。</p>\n<p>CHAR 适合存储很短的字符串，或者所有值都接近同一个长度。</p>\n<p>CHAR 存储的内容超出设置的长度时，内容同样会被截断。</p>\n<p><strong>使用策略：</strong></p>\n<p>对于经常变更的数据来说，CHAR 比 VARCHAR 更好，因为 CHAR 不容易产生碎片。</p>\n<p>对于非常短的列，CHAR 比 VARCHAR 在存储空间上更有效率。</p>\n<p>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。</p>\n<p>尽量避免使用 TEXT&#x2F;BLOB 类型，查询时会使用临时表，导致严重的性能开销。</p>\n<p>**4**<strong>、枚举类型（*</strong>*ENUM****）**，把不重复的数据存储为一个预定义的集合。</p>\n<p>有时可以使用 ENUM 代替常用的字符串类型。</p>\n<p>ENUM 存储非常紧凑，会把列表值压缩到一个或两个字节。</p>\n<p>ENUM 在内部存储时，其实存的是整数。</p>\n<p>尽量避免使用数字作为 ENUM 枚举的常量，因为容易混乱。</p>\n<p>排序是按照内部存储的整数**5****、日期和时间类型**，尽量使用 timestamp，空间效率高于 datetime，</p>\n<p>用整数保存时间戳通常不方便处理。</p>\n<p>如果需要存储微妙，可以使用 bigint 存储。</p>\n<p>看到这里，这道真题是不是就比较容易回答了。</p>\n<h2 id=\"16-、创建索引的三种方式，删除索引\"><a href=\"#16-、创建索引的三种方式，删除索引\" class=\"headerlink\" title=\"**16****、创建索引的三种方式，删除索引**\"></a>**16****、创建索引的三种方式，删除索引**</h2><p>第一种方式：在执行 CREATE TABLE 时创建索引</p>\n<p>第二种方式：使用 ALTER TABLE 命令去增加索引</p>\n<p>ALTER TABLE 用来创建普通索引、UNIQUE 索引或 PRIMARY KEY 索引。</p>\n<p>其中 table_name 是要增加索引的表名，column_list 指出对哪些列进行索引，多列时各列之间用逗号分</p>\n<p>隔。</p>\n<p>索引名 index_name 可自己命名，缺省时，MySQL 将根据第一个索引列赋一个名称。另外，ALTER</p>\n<p>TABLE 允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>\n<p>第三种方式：使用 CREATE INDEX 命令创建</p>\n<p>CREATE INDEX 可对表增加普通索引或 UNIQUE 索引。（但是，不能创建 PRIMARY KEY 索引）</p>\n<p>删除索引</p>\n<p>根据索引名删除普通索引、唯一索引、全文索引： alter table 表名 drop KEY 索引名</p>\n<p>删除主键索引： alter table 表名 drop primary key （因为主键只有一个）。这里值得注意的是，</p>\n<p>如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>\n<p>CREATE TABLE user_index2 (</p>\n<p>id INT auto_increment PRIMARY KEY,</p>\n<p>first_name VARCHAR (16),</p>\n<p>last_name VARCHAR (16),</p>\n<p>id_card VARCHAR (18),</p>\n<p>information text,</p>\n<p>KEY name (first_name, last_name),</p>\n<p>FULLTEXT KEY (information),</p>\n<p>UNIQUE KEY (id_card)</p>\n<p>);</p>\n<p>ALTER TABLE table_name ADD INDEX index_name (column_list);</p>\n<p>CREATE INDEX index_name ON table_name (column_list);</p>\n<p>alter table user_index drop KEY name;</p>\n<p>alter table user_index drop KEY id_card;</p>\n<p>alter table user_index drop KEY information;需要取消自增长再行删除：</p>\n<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>\n<h1 id=\"2、未分类\"><a href=\"#2、未分类\" class=\"headerlink\" title=\"2、未分类\"></a>2、未分类</h1><h2 id=\"1、你知道的-List-都有哪些？\"><a href=\"#1、你知道的-List-都有哪些？\" class=\"headerlink\" title=\"1、你知道的 List 都有哪些？\"></a>1、你知道的 List 都有哪些？</h2><p>ArrayList、LinkedList、Vector 等。</p>\n<h2 id=\"2、List-和-Vector-有什么区别？\"><a href=\"#2、List-和-Vector-有什么区别？\" class=\"headerlink\" title=\"2、List 和 Vector 有什么区别？\"></a>2、List 和 Vector 有什么区别？</h2><p>Vector 是 List 接口下线程安全的集合。</p>\n<h2 id=\"3、List-是有序的吗？\"><a href=\"#3、List-是有序的吗？\" class=\"headerlink\" title=\"3、List 是有序的吗？\"></a>3、List 是有序的吗？</h2><p>List 是有序的。</p>\n<h2 id=\"4、ArrayList-和-LinkedList-的区别？分别用在什么场景？\"><a href=\"#4、ArrayList-和-LinkedList-的区别？分别用在什么场景？\" class=\"headerlink\" title=\"4、ArrayList 和 LinkedList 的区别？分别用在什么场景？\"></a>4、ArrayList 和 LinkedList 的区别？分别用在什么场景？</h2><p>ArrayList 和 LinkedList 数据结构不一样，前者用在查询较多的场合，后者适用于插入较多的</p>\n<p>场合。</p>\n<h2 id=\"5、ArrayList-和-LinkedList-的底层数据结构是什么？\"><a href=\"#5、ArrayList-和-LinkedList-的底层数据结构是什么？\" class=\"headerlink\" title=\"5、ArrayList 和 LinkedList 的底层数据结构是什么？\"></a>5、ArrayList 和 LinkedList 的底层数据结构是什么？</h2><p>ArrayList 使用的是数组结构，LinkedList 使用的是链表结构。</p>\n<h2 id=\"6、ArrayList-默认大小是多少，是如何扩容的？\"><a href=\"#6、ArrayList-默认大小是多少，是如何扩容的？\" class=\"headerlink\" title=\"6、ArrayList 默认大小是多少，是如何扩容的？\"></a>6、ArrayList 默认大小是多少，是如何扩容的？</h2><p>Jdk1.7 之前 ArrayList 默认大小是 10，JDK1.7 之后是 0，JDK 差异，每次约按 1.5 倍扩容。</p>\n<h2 id=\"7、List-是线程安全的吗？如果要线程安全要怎么做？\"><a href=\"#7、List-是线程安全的吗？如果要线程安全要怎么做？\" class=\"headerlink\" title=\"7、List 是线程安全的吗？如果要线程安全要怎么做？\"></a>7、List 是线程安全的吗？如果要线程安全要怎么做？</h2><p>List 中 的 Vector 才 是 线 程 安 全 的 ， 其 他 要 实 现 线 程 安 全 使 用 工 具 类</p>\n<p>Collections.synchronizedList(new ArrayList())方法。</p>\n<h2 id=\"8、怎么给-List-排序？\"><a href=\"#8、怎么给-List-排序？\" class=\"headerlink\" title=\"8、怎么给 List 排序？\"></a>8、怎么给 List 排序？</h2><p>使用 List 自身的 sort 方法，或者使用 Collections.sort(list)方法;</p>\n<h2 id=\"9、Arrays-asList-方法后的-List-可以扩容吗？\"><a href=\"#9、Arrays-asList-方法后的-List-可以扩容吗？\" class=\"headerlink\" title=\"9、Arrays.asList 方法后的 List 可以扩容吗？\"></a>9、Arrays.asList 方法后的 List 可以扩容吗？</h2><p>Arrays.asList 使用的是 final 数组，并且不支持 add 方法，不支持扩容。</p>\n<h2 id=\"10、List-和-Array-之间如何互相转换？\"><a href=\"#10、List-和-Array-之间如何互相转换？\" class=\"headerlink\" title=\"10、List 和 Array 之间如何互相转换？\"></a>10、List 和 Array 之间如何互相转换？</h2><p>List&gt;Array 使用 toArray 方法，Array&gt;List 使用 Arrays.asList(array)方法，由于它是固定的，不固</p>\n<p>定的可以使用 new ArrayList(Arrays.asList(array))。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1、JAVA\"><a href=\"#1、JAVA\" class=\"headerlink\" title=\"1、JAVA\"></a>1、JAVA</h1><h2 id=\"一、-Resource和-Autowire注解的区别\"><a href=\"#一、-Resource和-Autowire注解的区别\" class=\"headerlink\" title=\"一、@Resource和@Autowire注解的区别\"></a>一、@Resource和@Autowire注解的区别</h2><p>@Resource和@Autowired都是用来进行依赖注入的注解，但是它们有一些不同之处。</p>\n<p>@Autowired是Spring框架中的注解，它可以用来标注字段、构造函数、方法等，表示需要自动装配。它可以用来注入依赖的bean。如果有多个bean符合条件，可能会抛出异常。</p>\n<p>@Resource是Java自带的注解，它可以用来标注字段、方法等，表示需要自动装配。它可以用来注入依赖的bean。如果有多个bean符合条件，会按照名称进行匹配。</p>\n<p>总结:</p>\n<p>@Autowired 是 Spring 框架中的注解，用来标注需要自动装配的 bean。<br>@Resource 是 Java 自带的注解，用来标注需要自动装配的 bean。<br>@Autowired 是按类型装配，如果有多个同类型的 bean，会抛出异常； @Resource 是按名称装配，如果名称不存在，会使用类型装配。</p>\n<h2 id=\"2、重载与重写区别-难度系数：⭐\"><a href=\"#2、重载与重写区别-难度系数：⭐\" class=\"headerlink\" title=\"2、重载与重写区别    难度系数：⭐\"></a>2、重载与重写区别    难度系数：⭐</h2><ol>\n<li>重载发生在本类，重写发生在父类与子类之间</li>\n<li>重载的方法名必须相同，重写的方法名相同且返回值类型必须相同</li>\n<li>重载的参数列表不同，重写的参数列表必须相同</li>\n<li>重写的访问权限不能比父类中被重写的方法的访问权限更低</li>\n<li>构造方法不能被重写</li>\n</ol>\n<h2 id=\"12、普通类和抽象类有哪些区别？★★★★★\"><a href=\"#12、普通类和抽象类有哪些区别？★★★★★\" class=\"headerlink\" title=\"12、普通类和抽象类有哪些区别？★★★★★\"></a>12、普通类和抽象类有哪些区别？★★★★★</h2><p>抽象类不能被实例化；<br>抽象类可以有抽象方法，只需申明，无须实现；<br>有抽象方法的类一定是抽象类；<br>抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类；<br>抽象方法不能声明为静态、不能被static、final修饰。</p>\n<h2 id=\"13、接口和抽象类有什么区别？★★★★★\"><a href=\"#13、接口和抽象类有什么区别？★★★★★\" class=\"headerlink\" title=\"13、接口和抽象类有什么区别？★★★★★\"></a>13、接口和抽象类有什么区别？★★★★★</h2><p>（1）接口</p>\n<p>接口使用interface修饰；<br>接口不能实例化；<br>类可以实现多个接口；</p>\n<p>①java8之前，接口中的方法都是抽象方法，省略了public abstract。②java8之后；接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；</p>\n<p>（2）抽象类</p>\n<p>抽象类使用abstract修饰；<br>抽象类不能被实例化；<br>抽象类只能单继承；<br>抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体；<br>如果一个类继承了抽象类，①如果实现了所有的抽象方法，子类可以不是抽象类；②如果没有实现所有的抽象方法，子类仍然是抽象类。</p>\n<p>共同点 不能实例化；</p>\n<p>不同点 接口使用interface修饰；抽象类使用abstract修饰；</p>\n<h2 id=\"6、String、StringBuffer、StringBuilder-有什么区别？★★★★★\"><a href=\"#6、String、StringBuffer、StringBuilder-有什么区别？★★★★★\" class=\"headerlink\" title=\"6、String、StringBuffer、StringBuilder 有什么区别？★★★★★\"></a>6、String、StringBuffer、StringBuilder 有什么区别？★★★★★</h2><p>String、StringBuffer、StringBuilder 最大的不同是 String 不可变，后者可变。StringBuffer 是线</p>\n<p>程安全的，StringBuilder 线程不安全速度较快。</p>\n<h2 id=\"7、String-trim-方法去掉的是哪些字符？\"><a href=\"#7、String-trim-方法去掉的是哪些字符？\" class=\"headerlink\" title=\"7、String.trim()方法去掉的是哪些字符？\"></a>7、String.trim()方法去掉的是哪些字符？</h2><p>trim 去掉字符串首尾的空白字符。</p>\n<h2 id=\"8、String-可以被子类继承吗？\"><a href=\"#8、String-可以被子类继承吗？\" class=\"headerlink\" title=\"8、String 可以被子类继承吗？\"></a>8、String 可以被子类继承吗？</h2><p>既然 String 是 final 的，所以不能被继承。</p>\n<h2 id=\"9、可以自定义-java-lang-String-类并使用吗？\"><a href=\"#9、可以自定义-java-lang-String-类并使用吗？\" class=\"headerlink\" title=\"9、可以自定义 java.lang.String 类并使用吗？\"></a>9、可以自定义 java.lang.String 类并使用吗？</h2><p>可以自定义 java.lang.String 类并编译成功，但不能被加载使用，具体请学习类加载机制。</p>\n<h2 id=\"10、String-与-byte-两者相互之间如何转换？\"><a href=\"#10、String-与-byte-两者相互之间如何转换？\" class=\"headerlink\" title=\"10、String 与 byte[]两者相互之间如何转换？\"></a>10、String 与 byte[]两者相互之间如何转换？</h2><p>String &gt; byte[] 通过 String 类的 getBytes 方法；byte[] &gt; String 通过 new String(byte[])构造器。</p>\n<h2 id=\"11、-和-equals-⽅法的区别\"><a href=\"#11、-和-equals-⽅法的区别\" class=\"headerlink\" title=\"11、&#x3D;&#x3D;和 equals ⽅法的区别\"></a>11、&#x3D;&#x3D;和 equals ⽅法的区别</h2><p>&#x3D;&#x3D;：如果是基本数据类型，⽐较是值，如果是引⽤类型，⽐较的是引⽤地址</p>\n<p>equals：具体看各个类重写 equals ⽅法之后的⽐较逻辑，⽐如 String 类，虽然是引⽤类型，但是 String 类中重写了 equals ⽅法，⽅法内部⽐较的是字符串中的各个字符是否全部相等。</p>\n<h3 id=\"2、-和-equals-的区别是什么？\"><a href=\"#2、-和-equals-的区别是什么？\" class=\"headerlink\" title=\"2、&#x3D;&#x3D; 和 equals 的区别是什么？\"></a>2、&#x3D;&#x3D; 和 <a href=\"https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020\">equals</a> 的区别是什么？</h3><ol>\n<li>对于基本类型，&#x3D;&#x3D;比较的是值；</li>\n<li>对于引用类型，&#x3D;&#x3D;比较的是地址；</li>\n<li>equals不能用于基本类型的比较；</li>\n<li>如果没有重写equals，equals就相当于&#x3D;&#x3D;；</li>\n<li>如果重写了equals方法，equals比较的是对象的内容；</li>\n</ol>\n<h2 id=\"12、-hashCode-与-equals-之间的关系★★★★★\"><a href=\"#12、-hashCode-与-equals-之间的关系★★★★★\" class=\"headerlink\" title=\"12、 hashCode()与 equals()之间的关系★★★★★\"></a>12、 hashCode()与 equals()之间的关系★★★★★</h2><p>6 在 Java 中，每个对象都可以调⽤⾃⼰的 hashCode()⽅法得到⾃⼰的哈希值(hashCode)，相当于对象的 指纹信息，通常来说世界上没有完全相同的两个指纹，但是在 Java 中做不到这么绝对，但是我们仍然可 以利⽤ hashCode 来做⼀些提前的判断，⽐如： 如果两个对象的 hashCode 不相同，那么这两个对象肯定不同的两个对象 如果两个对象的 hashCode 相同，不代表这两个对象⼀定是同⼀个对象，也可能是两个对象 如果两个对象相等，那么他们的 hashCode 就⼀定相同 在 Java 的⼀些集合类的实现中，在⽐较两个对象是否相等时，会根据上⾯的原则，会先调⽤对象的 hashCode()⽅法得到 hashCode 进⾏⽐较，如果 hashCode 不相同，就可以直接认为这两个对象不相 同，如果 hashCode 相同，那么就会进⼀步调⽤ equals()⽅法进⾏⽐较。⽽ equals()⽅法，就是⽤来最终 确定两个对象是不是相等的，通常 equals ⽅法的实现会⽐较重，逻辑⽐较多，⽽ hashCode()主要就是得 到⼀个哈希值，实际上就⼀个数字，相对⽽⾔⽐较轻，所以在⽐较两个对象时，通常都会先根据 hashCode 想⽐较⼀下。 所以我们就需要注意，如果我们重写了 equals()⽅法，那么就要注意 hashCode()⽅法，⼀定要保证能遵 守上述规则。</p>\n<p>13、重载和重写的区别</p>\n<ul>\n<li>重载是指在一个类中定义了多个同名的方法，但他们的参数列表是不同的</li>\n<li>子<a href=\"https://so.csdn.net/so/search?q=%E7%B1%BB%E7%BB%A7%E6%89%BF&spm=1001.2101.3001.7020\">类继承</a>父类，子类重写父类中的所有公共方法，覆盖父类的方法并对其重写。</li>\n</ul>\n<p>重载</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static int add(int x, int y) &#123;\n        return x + y;\n    &#125;\n    public static double add(int x, int y) &#123;\n        return x + y;\n    &#125;</code></pre>\n\n<p>重写</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Animal &#123;\n    public void eat(String food) &#123;\n \t\t...\n    &#125;\n&#125;\n\nclass Bird extends Animal &#123;\n    @Override\n    public void eat(String food) &#123;\n\t\t...\n    &#125;</code></pre>\n\n<h2 id=\"13、String、StringBuffer-和-StringBuilder-的区别是什-么-★★★★★\"><a href=\"#13、String、StringBuffer-和-StringBuilder-的区别是什-么-★★★★★\" class=\"headerlink\" title=\"13、String、StringBuffer 和 StringBuilder 的区别是什 么?★★★★★\"></a>13、String、StringBuffer 和 StringBuilder 的区别是什 么?★★★★★</h2><p>string 不可变 线程安全 操作少量数据或不操作数据 是个对象 消耗内存性能底</p>\n<p>StringBuffer 不可变 线程不安全 频繁操作数据 不考虑线程安全</p>\n<p>StringBuilder 不可变 线程安全 频繁操作数据 考虑线程安全 +了 synchronizd(锁)</p>\n<h2 id=\"14、-Java-创建对象有几种方式？★★★★★\"><a href=\"#14、-Java-创建对象有几种方式？★★★★★\" class=\"headerlink\" title=\"14、 Java 创建对象有几种方式？★★★★★\"></a>14、 Java 创建对象有几种方式？★★★★★</h2><p>java 中提供了以下四种创建对象的方式:</p>\n<ol>\n<li>new 创建新对象</li>\n<li>通过反射机制</li>\n<li>采用 clone 机制</li>\n<li>通过序列化机制</li>\n</ol>\n<p>15、 有没有可能两个不相等的对象有相同的 hashcode</p>\n<p>有可能.在产生 hash 冲突时,两个不相等的对象就会有相同的 hashcode 值.当 hash 冲突产生时,一般有以 下几种方式来处理:</p>\n<p>拉链法:每个哈希表节点都有一个 next 指针,多个哈希表节点可以用 next 指针构成一个单向链表，被 分配到同一个索引上的多个节点可以用这个单向链表进行存储.</p>\n<p>开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找 到,并将记录存入</p>\n<p>再哈希:又叫双哈希法,有多个不同的 Hash 函数.当发生冲突时,使用第二个,第三个….等哈希函数计算 地址,直到无冲突</p>\n<h2 id=\"15、-深拷贝和浅拷贝的区别是什么-★★★★★\"><a href=\"#15、-深拷贝和浅拷贝的区别是什么-★★★★★\" class=\"headerlink\" title=\"15、 深拷贝和浅拷贝的区别是什么?★★★★★\"></a>15、 深拷贝和浅拷贝的区别是什么?★★★★★</h2><h3 id=\"深拷贝和浅拷贝\"><a href=\"#深拷贝和浅拷贝\" class=\"headerlink\" title=\"深拷贝和浅拷贝\"></a>深拷贝和浅拷贝</h3><p>深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。</p>\n<p>浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象<br>深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象<br>浅拷贝: 基本数据类型+实例对象的地址(这时浅拷贝的两个实例对象地址是同一个, 也就是同一个实例); 深拷贝: 基本数据类型+实例对象地址下的数据(也就是将实例对象也拷贝了一份)</p>\n<p>浅拷贝:被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向 原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.</p>\n<p>深拷贝:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被 复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都 复制了一遍.</p>\n<p>深拷⻉和浅拷⻉就是指对象的拷⻉，⼀个对象中存在两种类型的属性，⼀种是基本数据类型，⼀种是实 例对象的引⽤。 1. 浅拷⻉是指，只会拷⻉基本数据类型的值，以及实例对象的引⽤地址，并不会复制⼀份引⽤地址所 指向的对象，也就是浅拷⻉出来的对象，内部的类属性指向的是同⼀个对象 2. 深拷⻉是指，既会拷⻉基本数据类型的值，也会针对实例对象的引⽤地址所指向的对象进⾏复制， 深拷⻉出来的对象，内部的属性指向的不是同⼀个对象</p>\n<h2 id=\"16、-final-有哪些用法-★★★★★\"><a href=\"#16、-final-有哪些用法-★★★★★\" class=\"headerlink\" title=\"16、 final 有哪些用法? ★★★★★\"></a>16、 final 有哪些用法? ★★★★★</h2><p>被 final 修饰的类不可以被继承</p>\n<p>被 final 修饰的方法不可以被重写</p>\n<p>被 final 修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.</p>\n<p>被 final 修饰的方法,JVM 会尝试将其内联,以提高运行效率 被 final 修饰的常量,在编译阶段会存入常量池中.</p>\n<p>修饰类：表示类不可被继承 修饰方法：表示方法不可被子类覆盖，但是可以重载 修饰变量：表示变量一旦被赋值就不可以更改它的值。 （1）修饰成员变量 如果 final 修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。 如果 final 修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。</p>\n<p>final 在 java 中有什么作用？<br>（1）用来修饰一个引用</p>\n<p>如果引用为基本数据类型，则该引用为常量，该值无法修改；<br>如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。<br>如果引用时类的成员变量，则必须当场赋值，否则编译会报错。<br>（2）用来修饰一个方法</p>\n<p>当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。</p>\n<p>（3）用来修饰类</p>\n<p>当用final修改类时，该类成为最终类，无法被继承。</p>\n<p>比如常用的String类就是最终类。</p>\n<h2 id=\"7、如何将字符串反转？\"><a href=\"#7、如何将字符串反转？\" class=\"headerlink\" title=\"7、如何将字符串反转？\"></a>7、如何将字符串反转？</h2><p>将对象封装到stringBuilder中，调用reverse方法反转。</p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709658384085.png\" alt=\"1709658384085\"></p>\n<h2 id=\"16、-3-0-1-0-3-返回值是什么\"><a href=\"#16、-3-0-1-0-3-返回值是什么\" class=\"headerlink\" title=\"16、 3*0.1 &#x3D;&#x3D; 0.3 返回值是什么\"></a>16、 3*0.1 &#x3D;&#x3D; 0.3 返回值是什么</h2><p>false,因为有些浮点数不能完全精确的表示出来.</p>\n<h2 id=\"17-Java-中有哪些类加载器★★★★★\"><a href=\"#17-Java-中有哪些类加载器★★★★★\" class=\"headerlink\" title=\"17 Java 中有哪些类加载器★★★★★\"></a>17 Java 中有哪些类加载器★★★★★</h2><p>JDK ⾃带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。 BootStrapClassLoader 是 ExtClassLoader 的⽗类加载器，默认负责加载%JAVA_HOME%lib 下的 jar 包和 class ⽂件。 ExtClassLoader 是 AppClassLoader 的⽗类加载器，负责加载%JAVA_HOME%&#x2F;lib&#x2F;ext ⽂件夹下的 jar 包和 class 类。 AppClassLoader 是⾃定义类加载器的⽗类，负责加载 classpath 下的类⽂件</p>\n<h2 id=\"16-hashCode-和-equals-方法有何重要性？★★★★★\"><a href=\"#16-hashCode-和-equals-方法有何重要性？★★★★★\" class=\"headerlink\" title=\"16.hashCode()和 equals()方法有何重要性？★★★★★\"></a>16.hashCode()和 equals()方法有何重要性？★★★★★</h2><h3 id=\"★★★★★\"><a href=\"#★★★★★\" class=\"headerlink\" title=\"★★★★★\"></a>★★★★★</h3><p>HashMap 使用 Key 对象的 hashCode()和 equals()方法去决定 key-value 对的索引。点击这里一</p>\n<p>文搞懂它们之间的关系。</p>\n<p>当我们试着从 HashMap 中获取值的时候，这些方法也会被用到。如果这些方法没有被正确</p>\n<p>地实现，在这种情况下，两个不同 Key 也许会产生相同的 hashCode()和 equals()输出，HashMap</p>\n<p>将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。</p>\n<p>同样的，所有不允许存储重复数据的集合类都使用 hashCode()和 equals()去查找重复，所以</p>\n<p>正确实现它们非常重要。equals()和 hashCode()的实现应该遵循以下规则：</p>\n<p>1.如果 o1.equals(o2)，那么 o1.hashCode() &#x3D;&#x3D; o2.hashCode()总是为 true 的。</p>\n<p>2.如果 o1.hashCode() &#x3D;&#x3D; o2.hashCode()，并不意味着 o1.equals(o2)会为 true。</p>\n<h2 id=\"17-Map-接口提供了哪些不同的集合视图？\"><a href=\"#17-Map-接口提供了哪些不同的集合视图？\" class=\"headerlink\" title=\"17.Map 接口提供了哪些不同的集合视图？\"></a>17.Map 接口提供了哪些不同的集合视图？</h2><p>Map 接口提供三个集合视图：</p>\n<p>1）Set keyset()：返回 map 中包含的所有 key 的一个 Set 视图。集合是受 map 支持的，map</p>\n<p>的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若 map 被修</p>\n<p>改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过 Iterator</p>\n<p>更多关注 Java 大后端公众号的 Remove、Set.remove、removeAll、retainAll 和 clear 操作进行元素移除，从 map 中移除对</p>\n<p>应的映射。</p>\n<p>它不支持 add 和 addAll 操作。</p>\n<p>2）Collection values()：返回一个 map 中包含的所有 value 的一个 Collection 视图。这个 collection</p>\n<p>受 map 支持的，map 的变化会在 collection 中反映出来，反之亦然。当一个迭代器正在遍历</p>\n<p>一个 collection 时，若 map 被修改了（除迭代器自身的移除操作以外），迭代器的结果会变</p>\n<p>为未定义。集合支持通过 Iterator 的 Remove、Set.remove、removeAll、retainAll 和 clear 操作</p>\n<p>进行元素移除，从 map 中移除对应的映射。它不支持 add 和 addAll 操作。</p>\n<p>3）Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：返回一个 map 钟包含的所有映射的一个集合视图。这个</p>\n<p>集合受 map 支持的，map 的变化会在 collection 中反映出来，反之亦然。当一个迭代器正在</p>\n<p>遍历一个集合时，若 map 被修改了（除迭代器自身的移除操作，以及对迭代器返回的 entry</p>\n<p>进行 setValue 外），迭代器的结果会变为未定义。集合支持通过 Iterator 的 Remove、Set.remove、</p>\n<p>removeAll、retainAll 和 clear 操作进行元素移除，从 map 中移除对应的映射。它不支持 add</p>\n<p>和 addAll 操作。</p>\n<h2 id=\"hashCode与equals★★★★★\"><a href=\"#hashCode与equals★★★★★\" class=\"headerlink\" title=\"hashCode与equals★★★★★\"></a>hashCode与equals★★★★★</h2><p>hashCode介绍：<br>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是<br>确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有<br>hashCode() 函数。<br>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用<br>到了散列码！（可以快速找到所需要的对象）<br>为什么要有hashCode：<br>以“HashSet如何检查重复”为例子来说明为什么要有hashCode：<br>对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有<br>值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals（）方法来<br>检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会<br>重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。<br>如果两个对象相等，则hashcode一定也是相同的<br>两个对象相等,对两个对象分别调用equals方法都返回true<br>两个对象有相同的hashcode值，它们也不一定是相等的<br>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖<br><em><strong>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则</strong></em><em><strong>该class的两个<br>对象无论如何都不会相等（即使这两个对象指向相同的数据）</strong></em></p>\n<h2 id=\"18-HashMap-和-HashTable-有何不同？\"><a href=\"#18-HashMap-和-HashTable-有何不同？\" class=\"headerlink\" title=\"18.HashMap 和 HashTable 有何不同？\"></a>18.HashMap 和 HashTable 有何不同？</h2><p>（1）HashMap 允许 key 和 value 为 null，而 HashTable 不允许。</p>\n<p>（2）HashTable 是同步的，而 HashMap 不是。所以 HashMap 适合单线程环境，HashTable</p>\n<p>适合多线程环境。</p>\n<p>（3）在 Java1.4 中引入了 LinkedHashMap，HashMap 的一个子类，假如你想要遍历顺序，你</p>\n<p>很容易从 HashMap 转向 LinkedHashMap，但是 HashTable 不是这样的，它的顺序是不可预知</p>\n<p>的。</p>\n<p>（4）HashMap 提供对 key 的 Set 进行遍历，因此它是 fail-fast 的，但 HashTable 提供对 key</p>\n<p>的 Enumeration 进行遍历，它不支持 fail-fast。</p>\n<p>（5）HashTable 被认为是个遗留的类，如果你寻求在迭代的时候修改 Map，你应该使用</p>\n<p>CocurrentHashMap。</p>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><h2 id=\"java集合超详解-java集合使用-CSDN博客\"><a href=\"#java集合超详解-java集合使用-CSDN博客\" class=\"headerlink\" title=\"[java集合超详解_java集合使用-CSDN博客]\"></a>[<a href=\"https://blog.csdn.net/feiyanaffection/article/details/81394745\">java集合超详解_java集合使用-CSDN博客</a>]</h2><p><img src=\"/images/1%E3%80%81JAVA/1709657326301.png\" alt=\"1709657326301\"></p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709657362460.png\" alt=\"1709657362460\"></p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709657394941.png\" alt=\"1709657394941\"></p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709205810985.png\" alt=\"1709205810985\"></p>\n<p><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#set\">Set</a></p>\n<ul>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#treeset\">TreeSet</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#hashset\">HashSet</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#linkedhashset\">LinkedHashSet</a></li>\n</ul>\n<p><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#list\">List</a></p>\n<ul>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#arraylist\">ArrayList </a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#vector\">Vector</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#linkedlist\">LinkedList</a></li>\n</ul>\n<p><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#queue\">Queue</a></p>\n<ul>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#linkedlist-1\">LinkedList</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#priorityqueue\">PriorityQueue</a></li>\n</ul>\n<p><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#map\">Map</a></p>\n<ul>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#treemap\">TreeMap</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#hashmap\">HashMap</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#hashtable\">HashTable</a></li>\n<li><a href=\"https://pdai.tech/md/java/collection/java-collection-all.html#linkedhashmap\">LinkedHashMap</a></li>\n</ul>\n<p>list</p>\n<p>ArrayList     底层数据结构是动态数组，查询快，增删慢。线程不安全，效率高</p>\n<p>Vector       底层数据结构是数组，查询快，增删慢。线程安全，效率低</p>\n<p>LinkedList 底层数据结构是链表，查询慢，增删快 线程不安全，效率高</p>\n<p>set</p>\n<p>Treeset 红黑树</p>\n<p>Hashset</p>\n<ul>\n<li>底层其实是包装了一个HashMap实现的</li>\n<li>底层数据结构是数组+链表 + 红黑树</li>\n<li>具有比较好的读取和查找性能， 可以有null 值</li>\n<li>通过equals和HashCode来判断两个元素是否相等</li>\n<li>非线程安全</li>\n</ul>\n<p>LinedHashkset</p>\n<ul>\n<li>继承HashSet，本质是LinkedHashMap实现</li>\n<li>底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。</li>\n<li>有序的，根据HashCode的值来决定元素的存储位置，同时使用一个链表来维护元素的插入顺序</li>\n<li>非线程安全，可以有null 值</li>\n</ul>\n<p>map</p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709208051453.png\" alt=\"1709208051453\"></p>\n<p>Hashmap 哈希表</p>\n<p>特点是访问速度快，遍历顺序不确定，线程不安全，最多允许一个key为null，允许多个value为null。</p>\n<ul>\n<li>可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap类。</li>\n</ul>\n<p>Treemap 红黑树</p>\n<ul>\n<li>TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。</li>\n</ul>\n<p>LinkedHashmap 双向链表</p>\n<ul>\n<li>LinkedHashMap继承了HashMap，是Map接口的哈希表和链接列表实现，它维护着一个双重链接列表，此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</li>\n</ul>\n<p>HashTable</p>\n<p>Hashmap底层原理</p>\n<p><strong>HashMap的底层是数组+链表+红黑树实现的。集合put时，通过计算key键的哈希值来放入元素。若有key值相同的哈希值时，会通过链表进行存放，链表长度达到8时会开辟红黑树进行存放，以此提高查询效率</strong>..</p>\n<h2 id=\"ArrayList-和-Vector-有何异同点？\"><a href=\"#ArrayList-和-Vector-有何异同点？\" class=\"headerlink\" title=\"ArrayList 和 Vector 有何异同点？\"></a>ArrayList 和 Vector 有何异同点？</h2><p><strong>ArrayList 和 Vector 在很多时候都很类似。</strong></p>\n<p>（1）两者都是基于索引的，内部由一个数组支持。</p>\n<p>（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。</p>\n<p>（3）ArrayList 和 Vector 的迭代器实现都是 fail-fast 的。</p>\n<p>（4）ArrayList 和 Vector 两者允许 null 值，也可以使用索引值对元素进行随机访问。</p>\n<p><strong>以下是 ArrayList 和 Vector 的不同点。</strong></p>\n<p>（1）Vector 是同步的，而 ArrayList 不是。然而，如果你寻求在迭代的时候对列表进行改变，</p>\n<p>你应该使用 CopyOnWriteArrayList。</p>\n<p>（2）ArrayList 比 Vector 快，它因为有同步，不会过载。</p>\n<p>（3）ArrayList 更加通用，因为我们可以使用 Collections 工具类轻易地获取同步列表和只读</p>\n<p>列表。</p>\n<h2 id=\"ArrayList-和-LinkedList-有何区别？\"><a href=\"#ArrayList-和-LinkedList-有何区别？\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 有何区别？\"></a>ArrayList 和 LinkedList 有何区别？</h2><p><img src=\"/images/1%E3%80%81JAVA/1709479433567.png\" alt=\"1709479433567\"></p>\n<p>ArrayList 和 LinkedList 两者都实现了 List 接口，但是它们之间有些不同。</p>\n<p>1）ArrayList 是由 Array 所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，</p>\n<p>复杂度为 O(1)，但 LinkedList 存储一系列的节点数据，每个节点都与前一个和下一个节点相</p>\n<p>连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引</p>\n<p>的节点然后返回元素，时间复杂度为 O(n)，比 ArrayList 要慢。</p>\n<p>2）与 ArrayList 相比，在 LinkedList 中插入、添加和删除一个元素会更快，因为在一个元素被</p>\n<p>插入到中间的时候，不会涉及改变数组的大小，或更新索引。</p>\n<p>3）LinkedList 比 ArrayList 消耗更多的内存，因为 LinkedList 中的每个节点存储了前后节点的</p>\n<p>引用。</p>\n<p>.哪些集合类提供对元素的随机访问？</p>\n<p>ArrayList、HashMap、TreeMap 和 HashTable 类提供对元素的随机访问。</p>\n<p>24.哪些集合类是线程安全的？</p>\n<p>Vector、HashTable、Properties 和 Stack 是同步类，所以它们是线程安全的，可以在多线程环</p>\n<p>境下使用。Java1.5 并发 API 包括一些集合类，允许迭代时修改，因为它们都工作在集合的</p>\n<p>克隆上，所以它们在多线程环境中是安全的。</p>\n<h2 id=\"HashMap-和-HashSet-区别\"><a href=\"#HashMap-和-HashSet-区别\" class=\"headerlink\" title=\"HashMap 和 HashSet 区别\"></a>HashMap 和 HashSet 区别</h2><p><img src=\"/images/1%E3%80%81JAVA/1709211409103.png\" alt=\"1709211409103\"></p>\n<h2 id=\"比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同\"><a href=\"#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同\" class=\"headerlink\" title=\"比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同\"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><p>HashSet 是 Set 接口的主要实现类 ，HashSet 的底层是 HashMap，线程不安全的，可以存储 null<br>值；<br>LinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历；<br>TreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p>\n<h1 id=\"2、多线程\"><a href=\"#2、多线程\" class=\"headerlink\" title=\"2、多线程\"></a>2、多线程</h1><h2 id=\"sleep-wait-join-yield-区别★★★★★\"><a href=\"#sleep-wait-join-yield-区别★★★★★\" class=\"headerlink\" title=\"sleep(), wait(), join(), yield()区别★★★★★\"></a>sleep(), wait(), join(), yield()区别★★★★★</h2><p>sleep()和wait<br>sleep()方法是Thread类的静态本地方法, wait()则是Object类的本地方法(where)<br>sleep一般用于当前线程休眠，或者轮循暂停操作，wait则多用于多线程之间的通信。(作用)<br>sleep方法不依赖于同步器synchronized, 但是wait需要依赖synchronized(依赖)<br>sleep方法不会释放锁, 但是wait会释放锁(锁)<br>sleep不需要被唤醒（休眠之后推出阻塞)，但是wait需要〈不指定时间需要被别人中断)。(醒)<br>where 作用 依赖 锁 醒</p>\n<p>yield<br>yield()执行后线程直接进入就绪状态, 马上释放cpu执行权, 但是依然保留cpu的执行资格, 所以cpu下次进行线程调度还可能会让这个线程去的执行权<br>join()执行后线程进入阻塞状态, 例如在线程B中调用线程A的join(), 那线程B会进入阻塞队列, 直到线程A结束或中断结束<br>例如t1线程正在执行, t2线程调用了t1.join(), 那线程B就会立即进入阻塞队列, 直到线程A结束或者中断线程</p>\n<h2 id=\"线程同步方式\"><a href=\"#线程同步方式\" class=\"headerlink\" title=\"线程同步方式\"></a>线程同步方式</h2><p>1、Java通过加锁实现线程同步,锁有两类：synchronized和Lock。  2、synchronized加在三个不同的位置,对应三种不同的使用方式,这三种方式的区别是锁对象不同：  （1.）加在普通方法上,则锁是当前的实例（this）。 （2.）加在静态方法上,锁是当前类的Class对象。 （3.）加在代码块上,则需要在关键字后面的小括号里,显式指定一个对象作为锁对象。</p>\n<h2 id=\"并发的三大特性\"><a href=\"#并发的三大特性\" class=\"headerlink\" title=\"并发的三大特性\"></a>并发的三大特性</h2><p>原子性 原子性是指在一个操作中 cpu 不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要 不都不执行。</p>\n<p>可见性 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>\n<p>有序性 虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按 照我们写的代码 的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，虽然对 变量的值没有造成影响，但有可能会出现线程安全问题。</p>\n<h2 id=\"线程有几种状态\"><a href=\"#线程有几种状态\" class=\"headerlink\" title=\"线程有几种状态\"></a>线程有几种状态</h2><p><img src=\"/images/1%E3%80%81JAVA/1709658004796.png\" alt=\"1709658004796\"></p>\n<p>1.线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。</p>\n<p>2.阻塞的情况又分为三种：</p>\n<p>(1)、等待阻塞：运行的线程执行 wait 方法，该线程会释放占用的所有资源，JVM 会把该线程放入“等待 池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用 notify 或 notifyAll 方法才能被唤 醒，wait 是 object 类的方法</p>\n<p>(2)、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放 入“锁池”中。</p>\n<p>(3)、其他阻塞：运行的线程执行 sleep 或 join 方法，或者发出了 I&#x2F;O 请求时，JVM 会把该线程置为阻塞状 态。当 sleep 状态超时、join 等待线程终止或者超时、或者 I&#x2F;O 处理完毕时，线程重新转入就绪状态。 sleep 是 Thread 类的方法 1.新建状态（New）：新创建了一个线程对象。 2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的 start 方法。该状态的线程位于 可运行线程池中，变得可运行，等待获取 CPU 的使用权。 3.运行状态（Running）：就绪状态的线程获取了 CPU，执行程序代码。</p>\n<p>4.阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进 入就绪状态，才有机会转到运行状态。 5.死亡状态（Dead）：线程执行完了或者因异常退出了 run 方法，该线程结束生命周期</p>\n<h2 id=\"juc是什么\"><a href=\"#juc是什么\" class=\"headerlink\" title=\"juc是什么\"></a>juc是什么</h2><p>JUC即java.util.concurrent,包含了支持并发操作的各种工具。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"></a>\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\</h2><h1 id=\"3、Nginx\"><a href=\"#3、Nginx\" class=\"headerlink\" title=\"3、Nginx\"></a>3、Nginx</h1><h2 id=\"1、请解释一下什么是-Nginx\"><a href=\"#1、请解释一下什么是-Nginx\" class=\"headerlink\" title=\"1、请解释一下什么是 Nginx?\"></a><strong>1、请解释一下什么是 Nginx?</strong></h2><p>Nginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3 和</p>\n<p>IMAP 协议。</p>\n<h2 id=\"2、请列举-Nginx-的一些特性。\"><a href=\"#2、请列举-Nginx-的一些特性。\" class=\"headerlink\" title=\"2、请列举 Nginx 的一些特性。\"></a><strong>2、请列举 Nginx 的一些特性。</strong></h2><p>Nginx 服务器的特性包括：</p>\n<p>反向代理&#x2F;L7 负载均衡器</p>\n<p>嵌入式 Perl 解释器</p>\n<p>动态二进制升级</p>\n<p>可用于重新编写 URL，具有非常好的 PCRE 支持</p>\n<h2 id=\"3、请列举-Nginx-和-Apache-之间的不同点\"><a href=\"#3、请列举-Nginx-和-Apache-之间的不同点\" class=\"headerlink\" title=\"3、请列举 Nginx 和 Apache 之间的不同点\"></a><strong>3、请列举 Nginx 和 Apache 之间的不同点</strong></h2><h2 id=\"4、请解释-Nginx-如何处理-HTTP-请求。\"><a href=\"#4、请解释-Nginx-如何处理-HTTP-请求。\" class=\"headerlink\" title=\"4、请解释 Nginx 如何处理 HTTP 请求。\"></a><strong>4、请解释 Nginx 如何处理 HTTP 请求。</strong></h2><p>Nginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数</p>\n<p>据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提</p>\n<p>供数万个并发连接。</p>\n<h2 id=\"5、在-Nginx-中，如何使用未定义的服务器名称来阻止处理请求\"><a href=\"#5、在-Nginx-中，如何使用未定义的服务器名称来阻止处理请求\" class=\"headerlink\" title=\"5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?\"></a><strong>5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?</strong></h2><p>只需将请求删除的服务器就可以定义为：</p>\n<p>Server {listen 80;server_name “ “ ;return 444;</p>\n<p>}</p>\n<p>这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下匹</p>\n<p>配请求，而一个特殊的 Nginx 的非标准代码 444 被返回，从而终止连接。</p>\n<h2 id=\"6、-使用“反向代理服务器”的优点是什么\"><a href=\"#6、-使用“反向代理服务器”的优点是什么\" class=\"headerlink\" title=\"6、 使用“反向代理服务器”的优点是什么?\"></a><strong>6、 使用“反向代理服务器”的优点是什么?</strong></h2><p>更多关注 Java 大后端公众号更多关注 Java 大后端公众号</p>\n<p>反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器</p>\n<p>之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服务时。</p>\n<h2 id=\"7、请列举-Nginx-服务器的最佳用途。\"><a href=\"#7、请列举-Nginx-服务器的最佳用途。\" class=\"headerlink\" title=\"7、请列举 Nginx 服务器的最佳用途。\"></a><strong>7、请列举 Nginx 服务器的最佳用途。</strong></h2><p>Nginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应用</p>\n<p>程序服务器、用于脚本的 FastCGI 处理程序。它还可以作为负载均衡器。</p>\n<h2 id=\"8、请解释-Nginx-服务器上的-Master-和-Worker-进程分别是什么\"><a href=\"#8、请解释-Nginx-服务器上的-Master-和-Worker-进程分别是什么\" class=\"headerlink\" title=\"8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?\"></a><strong>8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?</strong></h2><p>Master 进程：读取及评估配置和维持</p>\n<p>Worker 进程：处理请求</p>\n<h2 id=\"9、请解释你如何通过不同于-80-的端口开启-Nginx\"><a href=\"#9、请解释你如何通过不同于-80-的端口开启-Nginx\" class=\"headerlink\" title=\"9、请解释你如何通过不同于 80 的端口开启 Nginx?\"></a><strong>9、请解释你如何通过不同于 80 的端口开启 Nginx?</strong></h2><p>为了通过一个不同的端口开启 Nginx，你必须进入&#x2F;etc&#x2F;Nginx&#x2F;sites-enabled&#x2F;，</p>\n<p>如果这是默认文件，那么你必须打开名为“default”的文件。编辑文件，并放</p>\n<p>置在你想要的端口：</p>\n<p>Like server { listen 81; }</p>\n<h2 id=\"10、请解释是否有可能将-Nginx-的错误替换为-502-错误、503\"><a href=\"#10、请解释是否有可能将-Nginx-的错误替换为-502-错误、503\" class=\"headerlink\" title=\"10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?\"></a><strong>10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?</strong></h2><p>502 &#x3D;错误网关</p>\n<p>503 &#x3D;服务器超载</p>\n<p>有可能，但是您可以确保 fastcgi_intercept_errors 被设置为 ON，并使用错误</p>\n<p>页面指令。</p>\n<p>Location &#x2F; {fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors</p>\n<p>on;error_page 502 &#x3D;503&#x2F;error_page.html;#…}</p>\n<h2 id=\"11、在-Nginx-中，解释如何在-URL-中保留双斜线\"><a href=\"#11、在-Nginx-中，解释如何在-URL-中保留双斜线\" class=\"headerlink\" title=\"11、在 Nginx 中，解释如何在 URL 中保留双斜线?\"></a><strong>11、在 Nginx 中，解释如何在 URL 中保留双斜线?</strong></h2><p>要在 URL 中保留双斜线，就必须使用 merge_slashes_off;</p>\n<p>语法:merge_slashes [on&#x2F;off]更多关注 Java 大后端公众号</p>\n<p>默认值: merge_slashes on</p>\n<p>环境: http，server</p>\n<h2 id=\"12、请解释-ngx-http-upstream-module-的作用是什么\"><a href=\"#12、请解释-ngx-http-upstream-module-的作用是什么\" class=\"headerlink\" title=\"12、请解释 ngx_http_upstream_module 的作用是什么?\"></a><strong>12、请解释 ngx_http_upstream_module 的作用是什么?</strong></h2><p>ngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi</p>\n<p>传递、memcached 传递和 scgi 传递指令来引用的服务器组。</p>\n<h2 id=\"13、请解释什么是-C10K-问题\"><a href=\"#13、请解释什么是-C10K-问题\" class=\"headerlink\" title=\"13、请解释什么是 C10K 问题?\"></a><strong>13、请解释什么是 C10K 问题?</strong></h2><p>C10K 问题是指无法同时处理大量客户端(10,000)的网络套接字。</p>\n<h2 id=\"14、请陈述-stub-status-和-sub-filter-指令的作用是什么\"><a href=\"#14、请陈述-stub-status-和-sub-filter-指令的作用是什么\" class=\"headerlink\" title=\"14、请陈述 stub_status 和 sub_filter 指令的作用是什么?\"></a><strong>14、请陈述 stub_status 和 sub_filter 指令的作用是什么?</strong></h2><p>Stub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活动</p>\n<p>连接，接受和处理当前读&#x2F;写&#x2F;等待连接的总数</p>\n<p>Sub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据</p>\n<h2 id=\"15、解释-Nginx-是否支持将请求压缩到上游\"><a href=\"#15、解释-Nginx-是否支持将请求压缩到上游\" class=\"headerlink\" title=\"15、解释 Nginx 是否支持将请求压缩到上游?\"></a><strong>15、解释 Nginx 是否支持将请求压缩到上游?</strong></h2><p>您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤器，</p>\n<p>它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编码:gzip”来</p>\n<p>解压缩响应。</p>\n<h2 id=\"16、解释如何在-Nginx-中获得当前的时间\"><a href=\"#16、解释如何在-Nginx-中获得当前的时间\" class=\"headerlink\" title=\"16、解释如何在 Nginx 中获得当前的时间?\"></a><strong>16、解释如何在 Nginx 中获得当前的时间?</strong></h2><p>要获得 Nginx 的当前时间，必须使用 SSI 模块、$date_gmt 和$date_local 的变</p>\n<p>量。</p>\n<p>Proxy_set_header THE-TIME $date_gmt;</p>\n<h2 id=\"17、用-Nginx-服务器解释-s-的目的是什么\"><a href=\"#17、用-Nginx-服务器解释-s-的目的是什么\" class=\"headerlink\" title=\"17、用 Nginx 服务器解释-s 的目的是什么?\"></a><strong>17、用 Nginx 服务器解释-s 的目的是什么?</strong></h2><p>用于运行 Nginx -s 参数的可执行文件。</p>\n<h2 id=\"18、解释如何在-Nginx-服务器上添加模块\"><a href=\"#18、解释如何在-Nginx-服务器上添加模块\" class=\"headerlink\" title=\"18、解释如何在 Nginx 服务器上添加模块?\"></a><strong>18、解释如何在 Nginx 服务器上添加模块?</strong></h2><p>在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选择。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\\\\\\\\\"></a>\\\\\\\\</h2><p>1、请解释一下什么是 Nginx?</p>\n<p>Nginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3</p>\n<p>和 IMAP 协议。</p>\n<p>2、请列举 Nginx 的一些特性。</p>\n<p>Nginx 服务器的特性包括：</p>\n<p>反向代理&#x2F;L7 负载均衡器</p>\n<p>嵌入式 Perl 解释器</p>\n<p>动态二进制升级</p>\n<p>可用于重新编写 URL，具有非常好的 PCRE 支持</p>\n<p>3、请列举 Nginx 和 Apache 之间的不同点</p>\n<p>4、请解释 Nginx 如何处理 HTTP 请求。</p>\n<p>Nginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样</p>\n<p>数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可</p>\n<p>以提供数万个并发连接。</p>\n<p>5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?</p>\n<p>只需将请求删除的服务器就可以定义为：</p>\n<p>Server {listen 80;server_name “ “ ;return 444;</p>\n<p>}</p>\n<p>这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下</p>\n<p>匹配请求，而一个特殊的 Nginx 的非标准代码 444 被返回，从而终止连接。</p>\n<p>6、 使用“反向代理服务器”的优点是什么?</p>\n<p>反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务</p>\n<p>器之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服</p>\n<p>务时。</p>\n<p>7、请列举 Nginx 服务器的最佳用途。Nginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应</p>\n<p>用程序服务器、用于脚本的 FastCGI 处理程序。它还可以作为负载均衡器。</p>\n<p>8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?</p>\n<p>Master 进程：读取及评估配置和维持</p>\n<p>Worker 进程：处理请求</p>\n<p>9、请解释你如何通过不同于 80 的端口开启 Nginx?</p>\n<p>为了通过一个不同的端口开启 Nginx，你必须进入&#x2F;etc&#x2F;Nginx&#x2F;sites\u0002</p>\n<p>enabled&#x2F;，如果这是默认文件，那么你必须打开名为“default”的文件。编辑</p>\n<p>文件，并放置在你想要的端口：</p>\n<p>Like server { listen 81; }</p>\n<p>10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?</p>\n<p>502 &#x3D;错误网关</p>\n<p>503 &#x3D;服务器超载</p>\n<p>有可能，但是您可以确保 fastcgi_intercept_errors 被设置为 ON，并使用错</p>\n<p>误页面指令。</p>\n<p>Location &#x2F; {fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors</p>\n<p>on;error_page 502 &#x3D;503&#x2F;error_page.html;#…}</p>\n<p>11、在 Nginx 中，解释如何在 URL 中保留双斜线?</p>\n<p>要在 URL 中保留双斜线，就必须使用 merge_slashes_off;</p>\n<p>语法:merge_slashes [on&#x2F;off]</p>\n<p>默认值: merge_slashes on</p>\n<p>环境: http，server</p>\n<p>12、请解释 ngx_http_upstream_module 的作用是什么?</p>\n<p>ngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi</p>\n<p>传递、memcached 传递和 scgi 传递指令来引用的服务器组。</p>\n<p>13、请解释什么是 C10K 问题?C10K 问题是指无法同时处理大量客户端(10,000)的网络套接字。</p>\n<p>14、请陈述 stub_status 和 sub_filter 指令的作用是什么?</p>\n<p>Stub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活</p>\n<p>动连接，接受和处理当前读&#x2F;写&#x2F;等待连接的总数</p>\n<p>Sub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据</p>\n<p>15、解释 Nginx 是否支持将请求压缩到上游?</p>\n<p>您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤</p>\n<p>器，它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编</p>\n<p>码:gzip”来解压缩响应。</p>\n<p>16、解释如何在 Nginx 中获得当前的时间?</p>\n<p>要获得 Nginx 的当前时间，必须使用 SSI 模块、$date_gmt 和$date_local 的变</p>\n<p>量。</p>\n<p>Proxy_set_header THE-TIME $date_gmt;</p>\n<p>17、用 Nginx 服务器解释-s 的目的是什么?</p>\n<p>用于运行 Nginx -s 参数的可执行文件。</p>\n<p>18、解释如何在 Nginx 服务器上添加模块?</p>\n<p>在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选</p>\n<p>择。</p>\n<h1 id=\"4、spring\"><a href=\"#4、spring\" class=\"headerlink\" title=\"4、spring\"></a>4、spring</h1><h2 id=\"1、springboot\"><a href=\"#1、springboot\" class=\"headerlink\" title=\"1、springboot\"></a>1、springboot</h2><h3 id=\"1、什么是-Spring-Boot？\"><a href=\"#1、什么是-Spring-Boot？\" class=\"headerlink\" title=\"1、什么是 Spring Boot？\"></a><strong>1、什么是 Spring Boot？</strong></h3><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是</p>\n<p>简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p>\n<p>更多 Spring Boot 详细介绍请看这篇文章《什么是 Spring Boot?》。</p>\n<h3 id=\"2、为什么要用-Spring-Boot？\"><a href=\"#2、为什么要用-Spring-Boot？\" class=\"headerlink\" title=\"2、为什么要用 Spring Boot？\"></a><strong>2、为什么要用 Spring Boot？</strong></h3><p>Spring Boot 优点非常多，如：</p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709736051227.png\" alt=\"1709736051227\"></p>\n<p> 独立运行</p>\n<p> 简化配置</p>\n<p> 自动配置</p>\n<p> 无代码生成和 XML 配置</p>\n<p> 应用监控</p>\n<p> 上手容易</p>\n<p>Spring Boot 集这么多优点于一身，还有理由不使用它呢？</p>\n<h3 id=\"5、Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？\"><a href=\"#5、Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？\" class=\"headerlink\" title=\"5、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？\"></a><strong>5、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</strong></h3><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要</p>\n<p>组合包含了以下 3 个注解：</p>\n<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>\n<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，</p>\n<p>如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D;</p>\n<p>{ DataSourceAutoConfiguration.class })。</p>\n<p>@ComponentScan：Spring 组件扫描。</p>\n<h3 id=\"6、开启-Spring-Boot-特性有哪几种方式？\"><a href=\"#6、开启-Spring-Boot-特性有哪几种方式？\" class=\"headerlink\" title=\"6、开启 Spring Boot 特性有哪几种方式？\"></a><strong>6、开启 Spring Boot 特性有哪几种方式？</strong></h3><p>1）继承 spring-boot-starter-parent 项目</p>\n<p>2）导入 spring-boot-dependencies 项目依赖</p>\n<p>具体请参考这篇文章《Spring Boot 开启的 2 种方式》。</p>\n<p>更多关注 Java 大后端公众号<strong>7、Spring Boot 需要独立的容器运行吗？</strong></p>\n<p>可以不需要，内置了 Tomcat&#x2F; Jetty 等容器。</p>\n<h3 id=\"8、运行-Spring-Boot-有哪几种方式？\"><a href=\"#8、运行-Spring-Boot-有哪几种方式？\" class=\"headerlink\" title=\"8、运行 Spring Boot 有哪几种方式？\"></a><strong>8、运行 Spring Boot 有哪几种方式？</strong></h3><p>1）打包用命令或者放到容器中运行</p>\n<p>2）用 Maven&#x2F; Gradle 插件运行</p>\n<p>3）直接执行 main 方法运行</p>\n<h3 id=\"9、Spring-Boot-自动配置原理是什么？\"><a href=\"#9、Spring-Boot-自动配置原理是什么？\" class=\"headerlink\" title=\"9、Spring Boot 自动配置原理是什么？\"></a><strong>9、Spring Boot 自动配置原理是什么？</strong></h3><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动</p>\n<p>配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。</p>\n<p>Spring Boot 自动配置原理？</p>\n<p>@Import + @Configuration + Spring spi 图灵学院 自动配置类由各个 starter 提供，使用@Configuration + @Bean 定义配置类，放到 META\u0002INF&#x2F;spring.factories 下 使用 Spring spi 扫描 META-INF&#x2F;spring.factories 下的配置类 使用@Import 导入自动配置类具体看这篇文章《Spring Boot 自动配置原理、实战》。</p>\n<h2 id=\"2、spring-MVC\"><a href=\"#2、spring-MVC\" class=\"headerlink\" title=\"2、spring MVC\"></a>2、spring MVC</h2><h3 id=\"1、什么是-SpringMvc？\"><a href=\"#1、什么是-SpringMvc？\" class=\"headerlink\" title=\"1、什么是 SpringMvc？\"></a>1、什么是 SpringMvc？</h3><p>答：SpringMvc 是 spring 的一个模块，基于 MVC 的一个框架，无需中间整合层来整合。</p>\n<h3 id=\"2、Spring-MVC-的优点：\"><a href=\"#2、Spring-MVC-的优点：\" class=\"headerlink\" title=\"2、Spring MVC 的优点：\"></a>2、Spring MVC 的优点：</h3><p>答：</p>\n<p>1）它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java</p>\n<p>组件.并且和 Spring 提供的其他基础结构紧密集成.</p>\n<p>2）不依赖于 Servlet API(目标虽是如此,但是在实现的时候确实是依赖于 Servlet 的)</p>\n<p>3）可以任意使用各种视图技术,而不仅仅局限于 JSP</p>\n<p>4）支持各种请求资源的映射策略</p>\n<p>5）它应是易于扩展的</p>\n<h3 id=\"3、SpringMVC-工作原理？\"><a href=\"#3、SpringMVC-工作原理？\" class=\"headerlink\" title=\"3、SpringMVC 工作原理？\"></a>3、SpringMVC 工作原理？</h3><p>答：</p>\n<p>1）客户端发送请求到 DispatcherServlet</p>\n<p>2）DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller</p>\n<p>3）Controller 调用业务逻辑后，返回 ModelAndView</p>\n<p>4）DispatcherServlet 查询 ModelAndView，找到指定视图</p>\n<p>5）视图将结果返回到客户端</p>\n<h3 id=\"4、SpringMVC-流程？★★★★★\"><a href=\"#4、SpringMVC-流程？★★★★★\" class=\"headerlink\" title=\"4、SpringMVC 流程？★★★★★\"></a>4、SpringMVC 流程？★★★★★</h3><p>1）用户发送请求至前端控制器 DispatcherServlet。</p>\n<p>2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。</p>\n<p>3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器对象</p>\n<p>及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。</p>\n<p>更多关注 Java 大后端公众号 4）DispatcherServlet 调用 HandlerAdapter 处理器适配器。</p>\n<p>5）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)。</p>\n<p>6）Controller 执行完成返回 ModelAndView。</p>\n<p>7）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。</p>\n<p>8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。</p>\n<p>9）ViewReslover 解析后返回具体 View。</p>\n<p>10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</p>\n<p>11）DispatcherServlet 响应用户。</p>\n<h2 id=\"3、spring\"><a href=\"#3、spring\" class=\"headerlink\" title=\"3、spring\"></a>3、spring</h2><p><img src=\"/images/1%E3%80%81JAVA/1709742703501.png\" alt=\"1709742703501\"></p>\n<h2 id=\"BeanFactory和ApplicationContext有什么区别-不熟\"><a href=\"#BeanFactory和ApplicationContext有什么区别-不熟\" class=\"headerlink\" title=\"BeanFactory和ApplicationContext有什么区别(不熟)\"></a>BeanFactory和ApplicationContext有什么区别(不熟)</h2><p>ApplicationContext接口作为BeanFactory的子类,除了提供BeanFactory所具有的功能外,还提供了更完整的框架功能:<br>①继承MessageSource,因此支持国际化<br>②资源文件访问，如URL和文件（ResourceLoader）<br>③载入多个（有继承关系）上下文（及同时加载多个配置文件），使得每一个上下文都专注于一个特定的层次<br>④提供在监听器中注册bean的事件；</p>\n<h2 id=\"Spring是什么\"><a href=\"#Spring是什么\" class=\"headerlink\" title=\"Spring是什么\"></a>Spring是什么</h2><p>Spring 是一个轻量级的控制翻转(IOC)和面向切面(AOP)的容器框架</p>\n<p>从大小与开销两方面而言Spring都是轻量级的</p>\n<p>包含并且管理Bean的配置和生命周期,又通过控制反转和依赖注入来达到松耦合, 在这个意义上是一个Bean容器,</p>\n<p>提供了面向切面编程的丰富支持, 允许通过分离应用的业务逻辑和系统级 服务进行内聚性的开发<br>将简单的组件配置, 组合为复杂的应用, 这个意义上是一个框架<br>谈谈你对AOP的理解<br>系统是由许多不同的组件所组成的, 每一个组件各负责着一些功能, 除了主要业务功能之外, 有些组件比如日志, 事务管理和安全等服务会水平散布到所有对象层次中去,<br>OOP运行从上到下的关系但是并不适合定义从左到右的关系, 所以如果仍然按照OOP设计就会有大量代码的重复; 如果使用AOP就会将这些功能封装为一个切面, 然后注入到目标对象中, 而且AOP还可以对对象进行增强, 去做一些额外的事情.<br>谈谈你对IOC的理解<br>容器概念, 控制翻转, 依赖注入</p>\n<p>(容器概念)IOC容器中存有自己配置获取的一些Bean(比如@Repository, @Service, @Controller), 在项目启动时使用反射创建对应的对象放到map中 ;(依赖注入) 这时候map中就有各种对象了, 接下来通过bean的配置文件中去获取xml文件中该bean节点下的, 根据其ref属性进行依赖注入, 注入到对应的注解下(@Autowired或者@Resource)<br>控制翻转: 控制翻转就是一个概念, 就是对象通过IOC容器和依赖注入自动进行装配, 就相当于原本属于程序员对对象创建的控制权交给了IOC<br>总结来说, 就是IOC通过容器概念, 控制翻转和依赖注入成为了整个系统的关键核心, 它起到一种类似”粘合剂”的作用, 把系统中的所有对象粘合起来一起发挥作用.</p>\n<h2 id=\"12-spring用了哪些设计模式\"><a href=\"#12-spring用了哪些设计模式\" class=\"headerlink\" title=\"12.spring用了哪些设计模式\"></a>12.spring用了哪些设计模式</h2><p>BeanFactory用了工厂模式，AOP用了动态代理模式，RestTemplate用来模板方法模式，SpringMVC中handlerAdaper用来适配器模式，Spring里的监听器用了观察者模式</p>\n<h2 id=\"14-SpringMV工作原理★★★★★\"><a href=\"#14-SpringMV工作原理★★★★★\" class=\"headerlink\" title=\"14.SpringMV工作原理★★★★★\"></a>14.SpringMV工作原理★★★★★</h2><p>SpringMVC工作过程围绕着前端控制器DispatchServerlet，几个重要组件有HandleMapping（处理器映射器）、HandleAdapter（处理器适配器）、ViewReslover（试图解析器）</p>\n<p>工作流程：</p>\n<p>（1）DispatchServerlet接收用户请求将请求发送给HandleMapping</p>\n<p>（2）HandleMapping根据请求url找到具体的handle和拦截器，返回给DispatchServerlet</p>\n<p>（3）DispatchServerlet调用HandleAdapter,HandleAdapter执行具体的controller，并将controller返回的ModelAndView返回给DispatchServler</p>\n<p>（4）DispatchServerlet将ModelAndView传给ViewReslover,ViewReslover解析后返回具体view</p>\n<p>（5）DispatchServerlet根据view进行视图渲染，返回给用户</p>\n<h2 id=\"谈谈你对AOP的理解★★★★★\"><a href=\"#谈谈你对AOP的理解★★★★★\" class=\"headerlink\" title=\"谈谈你对AOP的理解★★★★★\"></a>谈谈你对AOP的理解★★★★★</h2><p>系统是由许多不同的组件所组成的, 每一个组件各负责着一些功能, 除了主要业务功能之外, 有些组件比如日志, 事务管理和安全等服务会水平散布到所有对象层次中去,<br>OOP运行从上到下的关系但是并不适合定义从左到右的关系, 所以如果仍然按照OOP设计就会有大量代码的重复; 如果使用AOP就会将这些功能封装为一个切面, 然后注入到目标对象中, 而且AOP还可以对对象进行增强, 去做一些额外的事情.</p>\n<h2 id=\"谈谈你对IOC的理解★★★★★\"><a href=\"#谈谈你对IOC的理解★★★★★\" class=\"headerlink\" title=\"谈谈你对IOC的理解★★★★★\"></a>谈谈你对IOC的理解★★★★★</h2><p>容器概念, 控制翻转, 依赖注入</p>\n<p>(容器概念)IOC容器中存有自己配置获取的一些Bean(比如@Repository, @Service, @Controller), 在项目启动时使用反射创建对应的对象放到map中 ;(依赖注入) 这时候map中就有各种对象了, 接下来通过bean的配置文件中去获取xml文件中该bean节点下的, 根据其ref属性进行依赖注入, 注入到对应的注解下(@Autowired或者@Resource)<br>控制翻转: 控制翻转就是一个概念, 就是对象通过IOC容器和依赖注入自动进行装配, 就相当于原本属于程序员对对象创建的控制权交给了IOC<br>总结来说, 就是IOC通过容器概念, 控制翻转和依赖注入成为了整个系统的关键核心, 它起到一种类似”粘合剂”的作用, 把系统中的所有对象粘合起来一起发挥作用.</p>\n<h2 id=\"bean的作用域\"><a href=\"#bean的作用域\" class=\"headerlink\" title=\"bean的作用域\"></a>bean的作用域</h2><p>singleton：在Spring容器中仅存在一个实例，即Bean以单例的形式存在。<br>prototype：为每一个bean请求提供一个实例。<br>request ：每次HTTP请求都会创建一个新的Bean。<br>session：同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。<br>globalSession：同一个全局的Session共享一个Bean，一般用于Portlet环境</p>\n<h2 id=\"bean的自动装配\"><a href=\"#bean的自动装配\" class=\"headerlink\" title=\".bean的自动装配\"></a>.bean的自动装配</h2><ul>\n<li>@Autowried：通过byType方式实现，并且要求这个对象存在</li>\n<li>@Resouce：默认通过byName方式实现，如果name找不到再通过byType实现</li>\n</ul>\n<h3 id=\"1、什么是-Spring-框架？Spring-框架有哪些主要模块？\"><a href=\"#1、什么是-Spring-框架？Spring-框架有哪些主要模块？\" class=\"headerlink\" title=\"1、什么是 Spring 框架？Spring 框架有哪些主要模块？\"></a>1、什么是 Spring 框架？Spring 框架有哪些主要模块？</h3><p>轻量级的开源的 J2EE 框架。它是一个容器框架，用来装 javabean（java 对象），中间层框架（万能胶） 可以起一个连接作用，比如说把 Struts 和 hibernate 粘合在一起运用，可以让我们的企业开发更快、更简 洁 Spring 是一个轻量级的控制反转（IoC)和面向切面（AOP）的容器框架</p>\n<p>谈谈你对AOP的理解<br>AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象<br>（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增<br>强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情</p>\n<h2 id=\"依赖注入的三种方式\"><a href=\"#依赖注入的三种方式\" class=\"headerlink\" title=\"依赖注入的三种方式\"></a>依赖注入的三种方式</h2><blockquote>\n<p>常用的注入方式主要有三种：构造方法注入（Construct注入），setter注入，基于注解的注入（接口注入）</p>\n</blockquote>\n<h3 id=\"3、什么是控制反转-IOC-？什么是依赖注入？\"><a href=\"#3、什么是控制反转-IOC-？什么是依赖注入？\" class=\"headerlink\" title=\"3、什么是控制反转(IOC)？什么是依赖注入？\"></a>3、什么是控制反转(IOC)？什么是依赖注入？</h3><p>控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象</p>\n<p>之间耦合关系在编译时通常是未知的。在传统的编程方式中，业 务逻辑的流程是由应用程序中的早</p>\n<p>已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来</p>\n<p>决定的，该对象关系图由装配 器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽</p>\n<p>象化。而绑定的过程是通过“依赖注入”实现的。</p>\n<p>控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了</p>\n<p>有效的作用。</p>\n<p>依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实</p>\n<p>例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的</p>\n<p>基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？</p>\n<h2 id=\"在-Java-中依然注入有以下三种实现方式：★★★★★\"><a href=\"#在-Java-中依然注入有以下三种实现方式：★★★★★\" class=\"headerlink\" title=\"在 Java 中依然注入有以下三种实现方式：★★★★★\"></a>在 Java 中依然注入有以下三种实现方式：★★★★★</h2><ol>\n<li>构造器注入</li>\n<li>Setter 方法注入</li>\n<li>接口注入</li>\n</ol>\n<h3 id=\"4、请解释下-Spring-框架中的-IoC？\"><a href=\"#4、请解释下-Spring-框架中的-IoC？\" class=\"headerlink\" title=\"4、请解释下 Spring 框架中的 IoC？\"></a>4、请解释下 Spring 框架中的 IoC？</h3><p>Spring 中的 org.springframework.beans 包和 org.springframework.context 包</p>\n<p>构成了 Spring 框架 IoC 容器的基础。</p>\n<p>BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。</p>\n<p>ApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory</p>\n<p>的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource</p>\n<p>的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的</p>\n<p>WebApplicationContext。</p>\n<p>org.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现，</p>\n<p>用来包装和管理前面提到的各种 bean。BeanFactory 接口是 Spring IoC 容器的核心接口。</p>\n<p>IOC:把对象的创建、初始化、销毁交给 spring 来管理，而不是由开发者控制，实现控制反转。</p>\n<h3 id=\"5、BeanFactory-和-ApplicationContext-有什么区别？\"><a href=\"#5、BeanFactory-和-ApplicationContext-有什么区别？\" class=\"headerlink\" title=\"5、BeanFactory 和 ApplicationContext 有什么区别？\"></a>5、BeanFactory 和 ApplicationContext 有什么区别？</h3><p><img src=\"/images/1%E3%80%81JAVA/1709478839382.png\" alt=\"1709478839382\"></p>\n<p>BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在</p>\n<p>接收到客户端请求时将对应的 bean 实例化。</p>\n<p>BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的</p>\n<p>配置中解放出来。BeanFactory 还包含 了 bean 生命周期的控制，调用客户端的初始化方法</p>\n<p>（initialization methods）和销毁方法（destruction methods）。</p>\n<p>从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，</p>\n<p>根据请求分发 bean 的功能。但 applicationcontext 在此基础上还提供了其他的功能。</p>\n<ol>\n<li>提供了支持国际化的文本消息</li>\n<li>统一的资源文件读取方式</li>\n<li>已在监听器中注册的 bean 的事件</li>\n</ol>\n<p>以下是三种较常见的 ApplicationContext 实现方式：</p>\n<p>1、ClassPathXmlApplicationContext：从 classpath 的 XML 配置文件中读取上下文，并生成上</p>\n<p>下文定义。应用程序上下文从程序环境变量中</p>\n<p>ApplicationContext context &#x3D; new</p>\n<p>ClassPathXmlApplicationContext(“bean.xml”);</p>\n<p>2、FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。</p>\n<p>ApplicationContext context &#x3D; new</p>\n<p>FileSystemXmlApplicationContext(“bean.xml”);</p>\n<p>3、XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。</p>\n<p>4.AnnotationConfigApplicationContext(基于 Java 配置启动容器)</p>\n<p><img src=\"/images/1%E3%80%81JAVA/1708002876939.png\" alt=\"1708002876939\"></p>\n<h3 id=\"6、Spring-有几种配置方式？\"><a href=\"#6、Spring-有几种配置方式？\" class=\"headerlink\" title=\"6、Spring 有几种配置方式？\"></a>6、Spring 有几种配置方式？</h3><p>将 Spring 配置到应用开发中有以下三种方式：</p>\n<ol>\n<li>基于 XML 的配置</li>\n<li>基于注解的配置</li>\n<li>基于 Java 的配置</li>\n</ol>\n<p>1.什么是 spring?</p>\n<p>Spring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用，但是有些</p>\n<p>扩展是针对构建 J2EE 平台的 web 应用。Spring 框架目标是简化 Java 企业级应用开发，并</p>\n<p>通过 POJO 为基础的编程模型促进良好的编程习惯。</p>\n<h3 id=\"2-使用-Spring-框架的好处是什么？★★★★★\"><a href=\"#2-使用-Spring-框架的好处是什么？★★★★★\" class=\"headerlink\" title=\"2.使用 Spring 框架的好处是什么？★★★★★\"></a>2.使用 Spring 框架的好处是什么？★★★★★</h3><p> 轻量：Spring 是轻量的，基本的版本大约 2MB。</p>\n<p> 控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建</p>\n<p>或查找依赖的对象们。</p>\n<p> 面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务</p>\n<p>分开。</p>\n<p> 容器：Spring 包含并管理应用中对象的生命周期和配置。</p>\n<p> MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。</p>\n<p> 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事</p>\n<p>务（JTA）。</p>\n<p> 异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，HibernateorJDO</p>\n<p>抛出的）转化为一致的 unchecked 异常。</p>\n<h3 id=\"14-IOC-的优点是什么？\"><a href=\"#14-IOC-的优点是什么？\" class=\"headerlink\" title=\"14.IOC 的优点是什么？\"></a>14.IOC 的优点是什么？</h3><p>IOC 或依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和</p>\n<p>JNDI 查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC 容器支持加载服务时</p>\n<p>的饿汉式初始化和懒加载。</p>\n<h3 id=\"15-ApplicationContext-通常的实现是什么\"><a href=\"#15-ApplicationContext-通常的实现是什么\" class=\"headerlink\" title=\"15.ApplicationContext 通常的实现是什么?\"></a>15.ApplicationContext 通常的实现是什么?</h3><p> FileSystemXmlApplicationContext：此容器从一个 XML 文件中加载 beans 的定义，</p>\n<p>XMLBean 配置文件的全路径名必须提供给它的构造函数。</p>\n<p> ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans 的定义，这</p>\n<p>里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。</p>\n<p> WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个 WEB 应用的</p>\n<p>所有 bean。</p>\n<h3 id=\"16-Bean-工厂和-Applicationcontexts-有什么区别？\"><a href=\"#16-Bean-工厂和-Applicationcontexts-有什么区别？\" class=\"headerlink\" title=\"16.Bean 工厂和 Applicationcontexts 有什么区别？\"></a>16.Bean 工厂和 Applicationcontexts 有什么区别？</h3><p>Applicationcontexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如</p>\n<p>镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内的对象上执行</p>\n<p>的那些不得不由 bean 工厂以程序化方式处理的操作，可以在 Applicationcontexts 中以声</p>\n<p>明的方式处理。Applicationcontexts 实现了 MessageSource 接口，该接口的实现以可插拔</p>\n<p>的方式提供获取本地化消息的方法。</p>\n<h3 id=\"19-有哪些不同类型的-IOC（依赖注入）方式？\"><a href=\"#19-有哪些不同类型的-IOC（依赖注入）方式？\" class=\"headerlink\" title=\"19.有哪些不同类型的 IOC（依赖注入）方式？\"></a>19.有哪些不同类型的 IOC（依赖注入）方式？</h3><p>更多关注 Java 大后端公众号  构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系</p>\n<p>列参数，每个参数代表一个对其他类的依赖。</p>\n<p> Setter 方法注入：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂方法</p>\n<p>实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注入。</p>\n<h3 id=\"11、-解释-Spring-支持的几种-bean-的作用域。\"><a href=\"#11、-解释-Spring-支持的几种-bean-的作用域。\" class=\"headerlink\" title=\"11、 解释 Spring 支持的几种 bean 的作用域。\"></a>11、 解释 Spring 支持的几种 bean 的作用域。</h3><p>Spring 容器中的 bean 可以分为 5 个范围：</p>\n<p>（1）singleton：默认，每个容器中只有一个 bean 的实例，单例的模式由 BeanFactory 自身来维护。</p>\n<p>（2）prototype：为每一个 bean 请求提供一个实例。</p>\n<p>（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回 收。</p>\n<p>（4）session：与 request 范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。</p>\n<p>（5）global-session：全局作用域，global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器 中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局 变量需要存储在 global-session 中。全局作用域与 Servlet 中的 session 作用域效果相同。25.解释 Spring 支持的几种 bean 的作用域。★★★★★</p>\n<h2 id=\"★★★★★Spring-基于-xml-注入-bean-的几种方式：\"><a href=\"#★★★★★Spring-基于-xml-注入-bean-的几种方式：\" class=\"headerlink\" title=\"★★★★★Spring 基于 xml 注入 bean 的几种方式：\"></a>★★★★★Spring 基于 xml 注入 bean 的几种方式：</h2><p>（1）Set 方法注入；</p>\n<p>（2）构造器注入：① 通过 index 设置参数的位置；② 通过 type 设置参数类型； （3）静态工厂注入； （4）实例工厂；</p>\n<h2 id=\"Spring-Boot、Spring-MVC-和-Spring-有什么区别\"><a href=\"#Spring-Boot、Spring-MVC-和-Spring-有什么区别\" class=\"headerlink\" title=\"Spring Boot、Spring MVC 和 Spring 有什么区别\"></a>Spring Boot、Spring MVC 和 Spring 有什么区别</h2><p>spring 是一个 IOC 容器，用来管理 Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提 供 AOP 机制弥补 OOP 的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给 方法执行，比如日志、异常等 springmvc 是 spring 对 web 框架的一个解决方案，提供了一个总的前端控制器 Servlet，用来接收请求， 然后定义了一套路由策略（url 到 handle 的映射）及适配执行 handle，将 handle 结果使用视图解析技术 生成视图展现给前端 springboot 是 spring 提供的一个快速开发工具包，让程序员能更方便、更快速的开发 spring+springmvc 应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter 机制）、redis、 mongodb、es，可以开箱即用</p>\n<h2 id=\"和-的区别是什么？★★★★★\"><a href=\"#和-的区别是什么？★★★★★\" class=\"headerlink\" title=\"#{}和${}的区别是什么？★★★★★\"></a>#{}和${}的区别是什么？★★★★★</h2><p>#{}是预编译处理、是占位符， ${}是字符串替换、是拼接符。 Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 来赋值； Mybatis 在处理${}时， 就是把${}替换成变量的值，调用 Statement 来赋值； #{} 的变量替换是在 DBMS 中、变量替换后，#{} 对应的变量自动加上单引号 ${} 的变量替换是在 DBMS 外、变量替换后，${} 对应的变量不会加上单引号 使用#{}可以有效的防止 SQL 注入， 提高系统安全性。</p>\n<h2 id=\"缓存雪崩、缓存穿透、缓存击穿★★★★★\"><a href=\"#缓存雪崩、缓存穿透、缓存击穿★★★★★\" class=\"headerlink\" title=\"缓存雪崩、缓存穿透、缓存击穿★★★★★\"></a>缓存雪崩、缓存穿透、缓存击穿★★★★★</h2><p>4.缓存穿透、缓存击穿、缓存雪崩<br>缓存穿透：客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数据。<br>解决方案：缓存空对象；布隆过滤器<br>缓存击穿：一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。<br>解决方案：热点数据永不过期；加互斥锁<br>缓存雪崩<br>解决方案：设置过期时间时，附加一个随机数，避免数据同时过期；</p>\n<p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内 承受大量请求而崩掉。 解决方案：</p>\n<ul>\n<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>\n<li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓 存。</li>\n<li>缓存预热</li>\n<li>互斥锁</li>\n</ul>\n<p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承 受大量请求而崩掉。</p>\n<ul>\n<li>解决方案： 接口层增加校验，如用户鉴权校验，id 做基础校验，id&lt;&#x3D;0 的直接拦截；</li>\n<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有 效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户 反复用同一个 id 暴力攻击</li>\n<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据 会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li>\n</ul>\n<p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同 时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪 崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查 数据库。</p>\n<p>解决方案</p>\n<ul>\n<li>设置热点数据永远不过期。</li>\n<li>加互斥锁</li>\n</ul>\n<h1 id=\"Mybatis\"><a href=\"#Mybatis\" class=\"headerlink\" title=\"Mybatis\"></a>Mybatis</h1><p>2、MyBatis 的优点和缺点 优点：</p>\n<ol>\n<li>（1）基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重 用。</li>\n<li>（2）与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；</li>\n<li>（3）很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。</li>\n<li>（4）能够与 Spring 很好的集成； （5）提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系 组件维护。</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>（1）SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定 要求。</li>\n<li>（2）SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>\n</ol>\n<h2 id=\"和-的区别是什么？\"><a href=\"#和-的区别是什么？\" class=\"headerlink\" title=\"#{}和${}的区别是什么？\"></a>#{}和${}的区别是什么？</h2><p>#{}是预编译处理，${}是字符串替换。 Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值； Mybatis 在处理${}时，就是把${}替换成变量的值。 使用#{}可以有效的防止 SQL 注入，提高系统安全性。</p>\n<h1 id=\"5、ES\"><a href=\"#5、ES\" class=\"headerlink\" title=\"5、ES\"></a>5、ES</h1><h3 id=\"1-为什么要使用-ES？\"><a href=\"#1-为什么要使用-ES？\" class=\"headerlink\" title=\"1.为什么要使用 ES？\"></a>1.为什么要使用 ES？</h3><p>虽然 lucene 是性能最先进的、功能完善的搜索引擎，但是它只能有一个库，而且使用它需</p>\n<p>要集成到 java 项目才能使用，配置还特别复杂,而 ES 语法简单、是基于 Resultful api 风格的,</p>\n<p>它在 lucene 所有功能基础上还能集成多台服务器进行搜索，也就是集群;</p>\n<h3 id=\"2-ES-和-lucene-的区别是什么？\"><a href=\"#2-ES-和-lucene-的区别是什么？\" class=\"headerlink\" title=\"2. ES 和 lucene 的区别是什么？\"></a>2. ES 和 lucene 的区别是什么？</h3><p>lucene 是现存功能最强大、最先进搜索库，直接基于 lucene 开发，api 非常复杂大量的 java</p>\n<p>代码、需要深入了解原理</p>\n<p>对比处:</p>\n<p>只有一个索引库、</p>\n<p>传统的遍历搜索方式</p>\n<p>采用 B+树索引;</p>\n<p>Es 是基于 lucene 的，隐藏了 lucene 复杂部分的一个分布式全文检索框架</p>\n<p>对比处:</p>\n<p>一个 es 的集群包含多个索引库、</p>\n<p>分布式搜索</p>\n<p>Es 是采用倒排式索引</p>\n<p>es 没有事物概念,删除不能恢复</p>\n<p>es 开源免费</p>\n<p>正排索引：id —&gt; value</p>\n<p>倒排索引：value —&gt; id</p>\n<h3 id=\"3-你还了解哪些全文检索工具？\"><a href=\"#3-你还了解哪些全文检索工具？\" class=\"headerlink\" title=\"3.你还了解哪些全文检索工具？\"></a>3.你还了解哪些全文检索工具？</h3><p>Lucene，Solr，HadoopContrib，Katta</p>\n<h3 id=\"4-Bulk-一次最大处理多少数据量？\"><a href=\"#4-Bulk-一次最大处理多少数据量？\" class=\"headerlink\" title=\"4.Bulk 一次最大处理多少数据量？\"></a>4.Bulk 一次最大处理多少数据量？</h3><p>bulk 会把将要处理的数据载入内存中，所以数据量是有限制的</p>\n<p>最佳的数据量不是一个确定的数值，它取决于你的硬件，你的文档大小以及复杂性，你的索</p>\n<p>更多关注 Java 大后端公众号引以及搜索的负载。</p>\n<p>一般建议是 1000-5000 个文档，如果你的文档很大，可以适当减少队列,大小建议是 5-15MB，</p>\n<p>默认不能超过 100M，可以在 es 的配置文件中修改这个值 http.max_content_length: 100mb</p>\n<h3 id=\"5-ES-在高并发的情况下如何保证数据线程安全问题？\"><a href=\"#5-ES-在高并发的情况下如何保证数据线程安全问题？\" class=\"headerlink\" title=\"5.ES 在高并发的情况下如何保证数据线程安全问题？\"></a>5.ES 在高并发的情况下如何保证数据线程安全问题？</h3><p>在读数据与写数据之间如果有其他线程进行写操作，就会出问题，es 使用版本控制才避免</p>\n<p>这种问题</p>\n<p>在修改数据的时候指定版本号，操作一次版本号加 1</p>\n<h3 id=\"6-ES-管理的工具有哪些？\"><a href=\"#6-ES-管理的工具有哪些？\" class=\"headerlink\" title=\"6.ES 管理的工具有哪些？\"></a>6.ES 管理的工具有哪些？</h3><p>1）BigDesk Plugin (作者 Luká? Vl?ek)：监控 es 状态的插件,推荐！主要提供的是节点的实时</p>\n<p>状态监控，包括 jvm 的情况，linux 的情况，elasticsearch 的情况</p>\n<p>2）Elasticsearch Head Plugin (作者 Ben Birch)：很方便对 es 进行各种操作的客户端。?</p>\n<p>3）Kibana(ES 官方推荐)：Es 基于?RestAPI 调试、数据报表、数据搜索</p>\n<h3 id=\"7-ES-自动映射的规则？\"><a href=\"#7-ES-自动映射的规则？\" class=\"headerlink\" title=\"7.ES 自动映射的规则？\"></a>7.ES 自动映射的规则？</h3><p>Es 映射是用于确定字段类型，将新增的每个字段数据类型映射后确定的字段类型，常见的</p>\n<p>映射类型有基本数据类型、复杂数据类型映射有数组对象(但对象映射扁平化后相关性会丢</p>\n<p>失，不能确定哪个是哪个属性)、</p>\n<p>全局映射的方式默认映射继承_default_的配置、动态模板映射：dynamic_templates，使用动</p>\n<p>态模板映射会覆盖默认模板，可设置关键字分词，默认模板是 string 类型的。</p>\n<h1 id=\"6、面试\"><a href=\"#6、面试\" class=\"headerlink\" title=\"6、面试\"></a>6、面试</h1><h2 id=\"1、请你自我介绍一下你自己？\"><a href=\"#1、请你自我介绍一下你自己？\" class=\"headerlink\" title=\"1、请你自我介绍一下你自己？\"></a>1、请你自我介绍一下你自己？</h2><p>回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历</p>\n<p>上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究</p>\n<p>的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习</p>\n<p>无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。</p>\n<p>企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”，企</p>\n<p>业喜欢有礼貌的求职者。</p>\n<h2 id=\"2、你觉得你个性上最大的优点是什么？\"><a href=\"#2、你觉得你个性上最大的优点是什么？\" class=\"headerlink\" title=\"2、你觉得你个性上最大的优点是什么？\"></a>2、你觉得你个性上最大的优点是什么？</h2><p>回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和</p>\n<p>幽默感、乐观和友爱。</p>\n<h2 id=\"3、说说你最大的缺点？\"><a href=\"#3、说说你最大的缺点？\" class=\"headerlink\" title=\"3、说说你最大的缺点？\"></a>3、说说你最大的缺点？</h2><p>回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求</p>\n<p>职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对</p>\n<p>不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比</p>\n<p>较出色，但事实上，他已经岌岌可危了。业喜欢求职者从自己的优点说起，中间加一些小缺</p>\n<p>点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者。</p>\n<h2 id=\"4、你对加班的看法？\"><a href=\"#4、你对加班的看法？\" class=\"headerlink\" title=\"4、你对加班的看法？\"></a>4、你对加班的看法？</h2><p>回答提示：实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公</p>\n<p>司奉献。</p>\n<p>回答样本：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身</p>\n<p>心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。</p>\n<h2 id=\"5、你对薪资的要求？\"><a href=\"#5、你对薪资的要求？\" class=\"headerlink\" title=\"5、你对薪资的要求？\"></a>5、你对薪资的要求？</h2><p>回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，</p>\n<p>那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，</p>\n<p>因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这</p>\n<p>笔钱是否足以引起你对该工作的兴趣。如果你自己必须说出具体数目，请不要说一个宽泛的</p>\n<p>范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当</p>\n<p>今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。</p>\n<p>回答样本一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重</p>\n<p>的是找对工作机会，所以只要条件公平，我则不会计较太多。</p>\n<p>回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程</p>\n<p>特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。</p>\n<h2 id=\"6、你的职业规划？\"><a href=\"#6、你的职业规划？\" class=\"headerlink\" title=\"6、你的职业规划？\"></a>6、你的职业规划？</h2><p>回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多</p>\n<p>的答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地</p>\n<p>位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感</p>\n<p>兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的</p>\n<p>工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧</p>\n<p>失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司</p>\n<p>的管理思路发展”。</p>\n<h2 id=\"7、你还有什么问题要问吗？\"><a href=\"#7、你还有什么问题要问吗？\" class=\"headerlink\" title=\"7、你还有什么问题要问吗？\"></a>7、你还有什么问题要问吗？</h2><p>回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，</p>\n<p>因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人</p>\n<p>这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋</p>\n<p>升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的</p>\n<p>上进心。</p>\n<h2 id=\"8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，\"><a href=\"#8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，\" class=\"headerlink\" title=\"8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，\"></a>8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，</h2><p>你怎么办？</p>\n<p>回答提示：一段时间发现工作不适合我，有两种情况：① 如果你确实热爱这个职业，那你就</p>\n<p>要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业</p>\n<p>要求，力争减少差距；② 你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，</p>\n<p>你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</p>\n<h2 id=\"9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该\"><a href=\"#9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该\" class=\"headerlink\" title=\"9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该\"></a>9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该</h2><p>怎么做？</p>\n<p>回答提示：①.原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，</p>\n<p>婉转地表达自己的想法，看看领导是否能改变想法。② 如果领导没有采纳我的建议，我也同</p>\n<p>样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原</p>\n<p>则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</p>\n<h2 id=\"10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？\"><a href=\"#10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？\" class=\"headerlink\" title=\"10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？\"></a>10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</h2><p>回答提示：① 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法</p>\n<p>去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。② 分清责任，各负其责，</p>\n<p>如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，</p>\n<p>作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。</p>\n<p>③ 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中</p>\n<p>吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的</p>\n<p>深度和力度是否不够，以致出现了本可以避免的错误。</p>\n<p>更多关注 Java 大后端公众号 11、谈谈你对跳槽的看法？</p>\n<p>回答提示：① 正常的“跳槽”能促进人才合理流动，应该支持。② 频繁的跳槽对单位和个人</p>\n<p>双方都不利，应该反对。</p>\n<h2 id=\"12、工作中你难以和同事、上司相处，你该怎么办？\"><a href=\"#12、工作中你难以和同事、上司相处，你该怎么办？\" class=\"headerlink\" title=\"12、工作中你难以和同事、上司相处，你该怎么办？\"></a>12、工作中你难以和同事、上司相处，你该怎么办？</h2><p>回答提示：① 我会服从领导的指挥，配合同事的工作。② 我会从自身找原因，仔细分析是不</p>\n<p>是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，</p>\n<p>如果是这样的话 我会努力改正。③ 如果我找不到原因，我会找机会跟他们沟通，请他们指</p>\n<p>出我的不足，有问题就及时改正。④ 作为优秀的员工，应该时刻以大局为重，即使在一段时</p>\n<p>间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看</p>\n<p>见我在努力，总有一天会对我微笑的。</p>\n<h2 id=\"13、你对于我们公司了解多少？\"><a href=\"#13、你对于我们公司了解多少？\" class=\"headerlink\" title=\"13、你对于我们公司了解多少？\"></a>13、你对于我们公司了解多少？</h2><p>回答提示：在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加</p>\n<p>强与国外大厂的 OEM 合作，自有品牌的部分则透过海外经销商。</p>\n<h2 id=\"14、请说出你选择这份工作的动机？\"><a href=\"#14、请说出你选择这份工作的动机？\" class=\"headerlink\" title=\"14、请说出你选择这份工作的动机？\"></a>14、请说出你选择这份工作的动机？</h2><p>回答提示：这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，</p>\n<p>如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。</p>\n<h2 id=\"15、你最擅长的技术方向是什么？\"><a href=\"#15、你最擅长的技术方向是什么？\" class=\"headerlink\" title=\"15、你最擅长的技术方向是什么？\"></a>15、你最擅长的技术方向是什么？</h2><p>回答提示：说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。</p>\n<h2 id=\"16、你能为我们公司带来什么呢？\"><a href=\"#16、你能为我们公司带来什么呢？\" class=\"headerlink\" title=\"16、你能为我们公司带来什么呢？\"></a>16、你能为我们公司带来什么呢？</h2><p>回答提示：企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后</p>\n<p>说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多</p>\n<p>的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以</p>\n<p>说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需</p>\n<p>求和消费。”等等。</p>\n<h2 id=\"17、最能概括你自己的三个词是什么？\"><a href=\"#17、最能概括你自己的三个词是什么？\" class=\"headerlink\" title=\"17、最能概括你自己的三个词是什么？\"></a>17、最能概括你自己的三个词是什么？</h2><p>回答提示：我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主</p>\n<p>考官解释，</p>\n<h2 id=\"18、为什么要离职\"><a href=\"#18、为什么要离职\" class=\"headerlink\" title=\"18、为什么要离职?\"></a>18、为什么要离职?</h2><p>回答提示：回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少</p>\n<p>的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪</p>\n<p>及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的</p>\n<p>更多关注 Java 大后端公众号空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等</p>\n<p>等，回答的答案最好是积极正面的。</p>\n<p>回答样本：我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，</p>\n<p>已经达到顶峰，即沒有升迁机会。</p>\n<h2 id=\"19、对工作的期望与目标何在？\"><a href=\"#19、对工作的期望与目标何在？\" class=\"headerlink\" title=\"19、对工作的期望与目标何在？\"></a>19、对工作的期望与目标何在？</h2><p>回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解</p>\n<p>的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这</p>\n<p>时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我</p>\n<p>的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为</p>\n<p>了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目</p>\n<p>标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。</p>\n<h2 id=\"20、就你申请的这个职位，你认为你还欠缺什么？\"><a href=\"#20、就你申请的这个职位，你认为你还欠缺什么？\" class=\"headerlink\" title=\"20、就你申请的这个职位，你认为你还欠缺什么？\"></a>20、就你申请的这个职位，你认为你还欠缺什么？</h2><p>回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的</p>\n<p>求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可</p>\n<p>以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学</p>\n<p>习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地</p>\n<p>躲过难题的求职者。</p>\n<h2 id=\"21、你通常如何处理別人的批评？\"><a href=\"#21、你通常如何处理別人的批评？\" class=\"headerlink\" title=\"21、你通常如何处理別人的批评？\"></a>21、你通常如何处理別人的批评？</h2><p>回答提示：① 沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。② 我会</p>\n<p>等大家冷靜下来再讨论。</p>\n<h2 id=\"22、怎样对待自己的失敗？\"><a href=\"#22、怎样对待自己的失敗？\" class=\"headerlink\" title=\"22、怎样对待自己的失敗？\"></a>22、怎样对待自己的失敗？</h2><p>回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。</p>\n<h2 id=\"23、什么会让你有成就感？\"><a href=\"#23、什么会让你有成就感？\" class=\"headerlink\" title=\"23、什么会让你有成就感？\"></a>23、什么会让你有成就感？</h2><p>回答提示：为贵公司竭力效劳，尽我所能，完成一个项目。</p>\n<h2 id=\"24、你为什么愿意到我们公司来工作？\"><a href=\"#24、你为什么愿意到我们公司来工作？\" class=\"headerlink\" title=\"24、你为什么愿意到我们公司来工作？\"></a>24、你为什么愿意到我们公司来工作？</h2><p>回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些</p>\n<p>详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，</p>\n<p>我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市</p>\n<p>场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你</p>\n<p>已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。</p>\n<h2 id=\"25、你和别人发生过争执吗？你是怎样解决的？\"><a href=\"#25、你和别人发生过争执吗？你是怎样解决的？\" class=\"headerlink\" title=\"25、你和别人发生过争执吗？你是怎样解决的？\"></a>25、你和别人发生过争执吗？你是怎样解决的？</h2><p>更多关注 Java 大后端公众号回答提示：这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过</p>\n<p>错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，</p>\n<p>这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。</p>\n<p>考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没</p>\n<p>有外界干涉的情况下，通过妥协的方式来解决才是正确答案。</p>\n<h2 id=\"26、对这项工作，你有哪些可预见的困难？\"><a href=\"#26、对这项工作，你有哪些可预见的困难？\" class=\"headerlink\" title=\"26、对这项工作，你有哪些可预见的困难？\"></a>26、对这项工作，你有哪些可预见的困难？</h2><p>回答提示：① 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。② 可以尝试迂回</p>\n<p>战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但</p>\n<p>是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以</p>\n<p>克服。</p>\n<p>分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中</p>\n<p>的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。第一，看看应</p>\n<p>聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一</p>\n<p>下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难</p>\n<p>的态度。</p>\n<h2 id=\"27、如果我录用你，你将怎样开展工作？\"><a href=\"#27、如果我录用你，你将怎样开展工作？\" class=\"headerlink\" title=\"27、如果我录用你，你将怎样开展工作？\"></a>27、如果我录用你，你将怎样开展工作？</h2><p>回答提示： ① 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工</p>\n<p>作的具体办法。② 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就</p>\n<p>有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开</p>\n<p>展工作。”。</p>\n<p>分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知</p>\n<p>道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回</p>\n<p>避的话，此人绝对不会录用了。</p>\n<h2 id=\"28、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应\"><a href=\"#28、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应\" class=\"headerlink\" title=\"28、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应\"></a>28、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应</h2><p>该怎么做？与上级意见不一是，你将怎么办？</p>\n<p>回答提示：①.原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，</p>\n<p>婉转地表达自己的想法，看看领导是否能改变想法。② 如果领导没有采纳我的建议，我也同</p>\n<p>样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原</p>\n<p>则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</p>\n<h2 id=\"29、你工作经验欠缺，如何能胜任这项工作？\"><a href=\"#29、你工作经验欠缺，如何能胜任这项工作？\" class=\"headerlink\" title=\"29、你工作经验欠缺，如何能胜任这项工作？\"></a>29、你工作经验欠缺，如何能胜任这项工作？</h2><p>常规思路：① 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在</p>\n<p>乎“经验”，关键看应聘者怎样回答。② 对这个问题的回答最好要体现出应聘者的诚恳、机</p>\n<p>智、果敢及敬业。③ 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期</p>\n<p>间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。</p>\n<p>更多关注 Java 大后端公众号但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各</p>\n<p>项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我</p>\n<p>一定能胜任这个职位。”</p>\n<p>点评：这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习</p>\n<p>成绩）为好。</p>\n<h2 id=\"30、您在前一家公司的离职原因是什么？\"><a href=\"#30、您在前一家公司的离职原因是什么？\" class=\"headerlink\" title=\"30、您在前一家公司的离职原因是什么？\"></a>30、您在前一家公司的离职原因是什么？</h2><p>回答提示：① 最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”</p>\n<p>在此家招聘单位里不存在。② 避免把“离职原因”说得太详细、太具体。③ 不能掺杂主观的</p>\n<p>负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥</p>\n<p>我们某某的员工”等。④ 但也不能躲闪、回避，如“想换换环境”、“个人原因”等。⑤ 不能</p>\n<p>涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等。⑥ 尽量使解释的理由</p>\n<p>为应聘者个人形象添彩。⑦ 相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三</p>\n<p>年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步</p>\n<p>我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只</p>\n<p>有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对</p>\n<p>面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。</p>\n<p>分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考</p>\n<p>官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真</p>\n<p>诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能</p>\n<p>准假，所以辞职，这个答案一般面试官还能接受。</p>\n<h2 id=\"31、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？\"><a href=\"#31、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？\" class=\"headerlink\" title=\"31、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？\"></a>31、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</h2><p>回答提示：每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得</p>\n<p>到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重</p>\n<p>要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。</p>\n<h2 id=\"32、果你在这次面试中没有被录用，你怎么打算？\"><a href=\"#32、果你在这次面试中没有被录用，你怎么打算？\" class=\"headerlink\" title=\"32、果你在这次面试中没有被录用，你怎么打算？\"></a>32、果你在这次面试中没有被录用，你怎么打算？</h2><p>回答提示：现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有</p>\n<p>优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅</p>\n<p>仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方</p>\n<p>面来正确看待这次失败：① 要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就</p>\n<p>不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己</p>\n<p>经历了这次之后经过努力一定能行，能够超越自我。② 善于反思，对于这次面试经验要认真</p>\n<p>总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的</p>\n<p>看待自己的长短得失，做一个明白人。③ 走出阴影，要克服这一次失败带给自己的心理压力，</p>\n<p>时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④ 认真工作，回到原单位岗位</p>\n<p>上后，要实实在在、踏踏实实地工作，三十六行、行行出状元，争取在本岗位上做出一定的</p>\n<p>更多关注 Java 大后端公众号成绩。⑤ 再接再厉，成为国家公务员一直是我的梦想，以后如果有机会我仍然后再次参加竞</p>\n<p>争。</p>\n<h2 id=\"33、谈谈你过去做过的成功案例？-工作中遇到什么问题\"><a href=\"#33、谈谈你过去做过的成功案例？-工作中遇到什么问题\" class=\"headerlink\" title=\"33、谈谈你过去做过的成功案例？(工作中遇到什么问题)\"></a>33、谈谈你过去做过的成功案例？(工作中遇到什么问题)</h2><p>回答提示：举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。切</p>\n<p>忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电</p>\n<p>话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。</p>\n<h2 id=\"34、如何安排自己的时间？会不会排斥加班？\"><a href=\"#34、如何安排自己的时间？会不会排斥加班？\" class=\"headerlink\" title=\"34、如何安排自己的时间？会不会排斥加班？\"></a>34、如何安排自己的时间？会不会排斥加班？</h2><p>回答提示：基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也</p>\n<p>知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配</p>\n<p>合。</p>\n<p>分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。</p>\n<h2 id=\"35、这个职务的期许？\"><a href=\"#35、这个职务的期许？\" class=\"headerlink\" title=\"35、这个职务的期许？\"></a>35、这个职务的期许？</h2><p>回答提示：希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、</p>\n<p>我个人而言，缔造“双赢”的局面。</p>\n<p>分析：回答前不妨先询问该公司对这项职务的责任认定及归属，因为每一家公司的状况不尽</p>\n<p>相同，以免说了一堆理想抱负却发现牛头不对马嘴。</p>\n<h2 id=\"36、什么选择我们这家公司？\"><a href=\"#36、什么选择我们这家公司？\" class=\"headerlink\" title=\"36、什么选择我们这家公司？\"></a>36、什么选择我们这家公司？</h2><p>回答提示：曾经在报章杂志看过关于贵公司的报道，与自己所追求的理念有志一同。而贵公</p>\n<p>司在业界的成绩也是有目共睹的，而且对员工的教育训练、升迁等也都很有制度。</p>\n<p>分析：去面试前先做功课，了解一下该公司的背景，让对方觉得你真的很有心想得到这份工</p>\n<p>作，而不只是探探路。</p>\n<h2 id=\"37、谈谈如何适应办公室工作的新环境？\"><a href=\"#37、谈谈如何适应办公室工作的新环境？\" class=\"headerlink\" title=\"37、谈谈如何适应办公室工作的新环境？\"></a>37、谈谈如何适应办公室工作的新环境？</h2><p>回答提示：① 办公室里每个人有各自的岗位与职责，不得擅离岗位。② 根据领导指示和工作</p>\n<p>安排，制定工作计划，提前预备，并按计划完成。③ 多请示并及时汇报，遇到不明白的要虚</p>\n<p>心请教。④ 抓间隙时间，多学习，努力提高自己的政治素质和业务水平。</p>\n<h2 id=\"38、工作中学习到了些什么？\"><a href=\"#38、工作中学习到了些什么？\" class=\"headerlink\" title=\"38、工作中学习到了些什么？\"></a>38、工作中学习到了些什么？</h2><p>回答提示：这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来</p>\n<p>回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学</p>\n<p>习到哪些经验，把握这些要点做陈述，就可以轻易过关了。</p>\n<h2 id=\"39、除了本公司外，还应聘了哪些公司？\"><a href=\"#39、除了本公司外，还应聘了哪些公司？\" class=\"headerlink\" title=\"39、除了本公司外，还应聘了哪些公司？\"></a>39、除了本公司外，还应聘了哪些公司？</h2><p>回答提示：很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，</p>\n<p>更多关注 Java 大后端公众号所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，</p>\n<p>如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。</p>\n<h2 id=\"40、何时可以到职？\"><a href=\"#40、何时可以到职？\" class=\"headerlink\" title=\"40、何时可以到职？\"></a>40、何时可以到职？</h2><p>回答提示：大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司规</p>\n<p>定上班”，但如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至</p>\n<p>少要一个月的时间，应进一步说明原因，录取公司应该会通融的。</p>\n<h1 id=\"7、redis\"><a href=\"#7、redis\" class=\"headerlink\" title=\"7、redis\"></a>7、redis</h1><h2 id=\"1-redis为什么快？\"><a href=\"#1-redis为什么快？\" class=\"headerlink\" title=\"1.redis为什么快？\"></a>1.redis为什么快？</h2><p>（1）完全基于内存操作</p>\n<p>（2）数据结构简单，对数据操作简单</p>\n<p>（3）redis执行命令是单线程的，避免了上下文切换带来的性能问题，也不用考虑锁的问题</p>\n<p>(4) 采用了非阻塞的io多路复用机制，使用了单线程来处理并发的连接;内部采用的epoll+自己实现的事件分离器</p>\n<p>其实Redis不是完全多线程的，在核心的网络模型中是多线程的用来处理并发连接，但是数据的操作都是单线程。Redis坚持单线程是因为Redis是的性能瓶颈是网络延迟而不是CPU，多线程对数据读取不会带来性能提升。</p>\n<h2 id=\"Redis如何实现key的过期删除？★★★★★\"><a href=\"#Redis如何实现key的过期删除？★★★★★\" class=\"headerlink\" title=\"Redis如何实现key的过期删除？★★★★★\"></a>Redis如何实现key的过期删除？★★★★★</h2><p>采用的定期过期+惰性过期</p>\n<p>定期删除 ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。<br>惰性删除 ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。</p>\n<h2 id=\"11-Redis缓存一致性解决方案\"><a href=\"#11-Redis缓存一致性解决方案\" class=\"headerlink\" title=\"11.Redis缓存一致性解决方案\"></a>11.Redis缓存一致性解决方案</h2><p>Redis缓存一致性解决方案主要思考的是删除缓存和更新数据库的先后顺序</p>\n<p>先删除缓存后更新数据库存在的问题是可能会数据不一致，一般使用延时双删来解决，即先删除缓存，再更新数据库，休眠X秒后再次淘汰缓存。第二次删除可能导致吞吐率降低，可以考虑进行异步删除。</p>\n<p>先更新数据库后删除缓存存在的问题是会可能会更新失败，可以采用延时删除。但由于读比写快，发生这一情况概率较小。</p>\n<p>但是无论哪种策略，都可能存在删除失败的问题，解决方案是用中间件canal订阅binlog日志提取需要删除的key，然后另写一段非业务代码去获取key并尝试删除，若删除失败就把删除失败的key发送到消息队列，然后进行删除重试。</p>\n<h2 id=\"12-Redis内存淘汰策略\"><a href=\"#12-Redis内存淘汰策略\" class=\"headerlink\" title=\"12.Redis内存淘汰策略\"></a>12.Redis内存淘汰策略</h2><p>当内存不足时按设定好的策略进行淘汰，策略有(1)淘汰最久没使用的（2）淘汰一段时间内最少使用的（3）淘汰快要过期的</p>\n<h2 id=\"1、什么是-Redis？\"><a href=\"#1、什么是-Redis？\" class=\"headerlink\" title=\"1、什么是 Redis？\"></a>1、什么是 Redis？</h2><p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载</p>\n<p>在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。因为是纯</p>\n<p>内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快</p>\n<p>的 Key-Value DB。</p>\n<p>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结</p>\n<p>构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis</p>\n<p>可以用来实现很多有用的功能，比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的</p>\n<p>高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。另外 Redis 也可以对存入</p>\n<p>的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。</p>\n<p>Redis</p>\n<p>的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis</p>\n<p>适合的场景主要局限在较小数据量的高性能操作和运算上。</p>\n<h2 id=\"2、Redis-相比-memcached-有哪些优势？\"><a href=\"#2、Redis-相比-memcached-有哪些优势？\" class=\"headerlink\" title=\"2、Redis 相比 memcached 有哪些优势？\"></a>2、Redis 相比 memcached 有哪些优势？</h2><p>(1) memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型</p>\n<p>(2) redis 的速度比 memcached 快很多</p>\n<p>(3) redis 可以持久化其数据</p>\n<h2 id=\"3、Redis-支持哪几种数据类型？\"><a href=\"#3、Redis-支持哪几种数据类型？\" class=\"headerlink\" title=\"3、Redis 支持哪几种数据类型？\"></a>3、Redis 支持哪几种数据类型？</h2><p>String、List、Set、Sorted Set、hashes</p>\n<p>字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。如果是高级用户，那</p>\n<p>么还会有，如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、</p>\n<p>Geo、Pub&#x2F;Sub。</p>\n<h2 id=\"4、Redis-主要消耗什么物理资源？\"><a href=\"#4、Redis-主要消耗什么物理资源？\" class=\"headerlink\" title=\"4、Redis 主要消耗什么物理资源？\"></a>4、Redis 主要消耗什么物理资源？</h2><p>内存。</p>\n<h2 id=\"5、Redis-的全称是什么？\"><a href=\"#5、Redis-的全称是什么？\" class=\"headerlink\" title=\"5、Redis 的全称是什么？\"></a>5、Redis 的全称是什么？</h2><p>Remote Dictionary Server。</p>\n<h2 id=\"6、Redis-有哪几种数据淘汰策略？\"><a href=\"#6、Redis-有哪几种数据淘汰策略？\" class=\"headerlink\" title=\"6、Redis 有哪几种数据淘汰策略？\"></a>6、Redis 有哪几种数据淘汰策略？</h2><p>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部</p>\n<p>分的写入指令，但 DEL 和几个例外）</p>\n<p>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</p>\n<p>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有</p>\n<p>空间存放。</p>\n<p>allkeys-random: 回收随机的键使得新添加的数据有空间存放。</p>\n<p>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</p>\n<p>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数</p>\n<p>据有空间存放。</p>\n<h2 id=\"7、Redis-官方为什么不提供-Windows-版本？\"><a href=\"#7、Redis-官方为什么不提供-Windows-版本？\" class=\"headerlink\" title=\"7、Redis 官方为什么不提供 Windows 版本？\"></a>7、Redis 官方为什么不提供 Windows 版本？</h2><p>因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来</p>\n<p>兼容性等问题。</p>\n<h2 id=\"8、一个字符串类型的值能存储最大容量是多少？\"><a href=\"#8、一个字符串类型的值能存储最大容量是多少？\" class=\"headerlink\" title=\"8、一个字符串类型的值能存储最大容量是多少？\"></a>8、一个字符串类型的值能存储最大容量是多少？</h2><p>512M</p>\n<p>更多关注 Java 大后端公众号 9、为什么 Redis 需要把所有数据放到内存中？</p>\n<p>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。</p>\n<p>所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I&#x2F;O 速度为严重</p>\n<p>影响 redis 的性能。在内存越来越便宜的今天，redis 将会越来越受欢迎。 如果设置了最大</p>\n<p>使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>\n<h2 id=\"10、Redis-集群方案应该怎么做？都有哪些方案？\"><a href=\"#10、Redis-集群方案应该怎么做？都有哪些方案？\" class=\"headerlink\" title=\"10、Redis 集群方案应该怎么做？都有哪些方案？\"></a>10、Redis 集群方案应该怎么做？都有哪些方案？</h2><p>1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通 redis 无任何区别，设</p>\n<p>置好它下属的多个 redis 实例后，使用时在本需要连接 redis 的地方改为连接 twemproxy，它</p>\n<p>会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再</p>\n<p>返回 twemproxy。使用方式简便(相对 redis 只需修改连接端口)，对旧项目扩展的首选。 问</p>\n<p>题：twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的</p>\n<p>计算值的改变，数据无法自动移动到新的节点。</p>\n<p>2.codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量</p>\n<p>改变情况下，旧节点数据可恢复到新 hash 节点。</p>\n<p>3.redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概</p>\n<p>念，以及自身支持节点设置从节点。具体看官方文档介绍。</p>\n<p>4.在业务代码层实现，起几个毫无关联的 redis 实例，在代码层，对 key 进行 hash 计算，然</p>\n<p>后去对应的 redis 实例操作数据。 这种方式对 hash 层代码要求比较高，考虑部分包括，节</p>\n<p>点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>\n<h2 id=\"11、Redis-集群方案什么情况下会导致整个集群不可用？\"><a href=\"#11、Redis-集群方案什么情况下会导致整个集群不可用？\" class=\"headerlink\" title=\"11、Redis 集群方案什么情况下会导致整个集群不可用？\"></a>11、Redis 集群方案什么情况下会导致整个集群不可用？</h2><p>有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就</p>\n<p>会以为缺少 5501-11000 这个范围的槽而不可用。</p>\n<h2 id=\"12、MySQL-里有-2000w-数据，redis-中只存-20w-的数据，如何保证-redis-中的数据都是热点\"><a href=\"#12、MySQL-里有-2000w-数据，redis-中只存-20w-的数据，如何保证-redis-中的数据都是热点\" class=\"headerlink\" title=\"12、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点\"></a>12、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点</h2><p>数据？</p>\n<p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>\n<h2 id=\"13、Redis-有哪些适合的场景？\"><a href=\"#13、Redis-有哪些适合的场景？\" class=\"headerlink\" title=\"13、Redis 有哪些适合的场景？\"></a>13、Redis 有哪些适合的场景？</h2><p>更多关注 Java 大后端公众号（1）、会话缓存（Session Cache）</p>\n<p>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储</p>\n<p>（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存</p>\n<p>时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p>\n<p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。</p>\n<p>甚至广为人知的商业平台 Magento 也提供 Redis 的插件。</p>\n<p>（2）、全页缓存（FPC）</p>\n<p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了</p>\n<p>Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改</p>\n<p>进，类似 PHP 本地 FPC。</p>\n<p>再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。</p>\n<p>此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助</p>\n<p>你以最快速度加载你曾浏览过的页面。</p>\n<p>（3）、队列</p>\n<p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很</p>\n<p>好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）</p>\n<p>对 list 的 push&#x2F;pop 操作。</p>\n<p>如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项</p>\n<p>目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一</p>\n<p>个后台就是使用 Redis 作为 broker，你可以从这里去查看。</p>\n<p>（4），排行榜&#x2F;计数器</p>\n<p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted</p>\n<p>Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结</p>\n<p>构。所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，</p>\n<p>我们只需要像下面一样执行即可：</p>\n<p>更多关注 Java 大后端公众号当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你</p>\n<p>需要这样执行：</p>\n<p>ZRANGE user_scores 0 10 WITHSCORES</p>\n<p>Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据</p>\n<p>的，你可以在这里看到。</p>\n<p>（5）、发布&#x2F;订阅</p>\n<p>最后（但肯定不是最不重要的）是 Redis 的发布&#x2F;订阅功能。发布&#x2F;订阅的使用场景确实非常</p>\n<p>多。我已看见人们在社交网络连接中使用，还可作为基于发布&#x2F;订阅的脚本触发器，甚至用</p>\n<p>Redis 的发布&#x2F;订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。</p>\n<h2 id=\"14、Redis-支持的-Java-客户端都有哪些？官方推荐用哪个？\"><a href=\"#14、Redis-支持的-Java-客户端都有哪些？官方推荐用哪个？\" class=\"headerlink\" title=\"14、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？\"></a>14、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？</h2><p>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</p>\n<h2 id=\"15、Redis-和-Redisson-有什么关系？\"><a href=\"#15、Redis-和-Redisson-有什么关系？\" class=\"headerlink\" title=\"15、Redis 和 Redisson 有什么关系？\"></a>15、Redis 和 Redisson 有什么关系？</h2><p>Redisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些</p>\n<p>Java 的 对 象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map,</p>\n<p>ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore,</p>\n<p>Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, HyperLogLog)。</p>\n<h2 id=\"16、Jedis-与-Redisson-对比有什么优缺点？\"><a href=\"#16、Jedis-与-Redisson-对比有什么优缺点？\" class=\"headerlink\" title=\"16、Jedis 与 Redisson 对比有什么优缺点？\"></a>16、Jedis 与 Redisson 对比有什么优缺点？</h2><p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；Redisson</p>\n<p>实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，</p>\n<p>不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关</p>\n<p>注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>\n<h2 id=\"17、Redis-如何设置密码及验证密码？\"><a href=\"#17、Redis-如何设置密码及验证密码？\" class=\"headerlink\" title=\"17、Redis 如何设置密码及验证密码？\"></a>17、Redis 如何设置密码及验证密码？</h2><p>设置密码：config set requirepass 123456</p>\n<p>授权密码：auth 123456</p>\n<p>更多关注 Java 大后端公众号 18、说说 Redis 哈希槽的概念？</p>\n<p>Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，</p>\n<p>每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分</p>\n<p>hash 槽。</p>\n<h2 id=\"19、Redis-集群的主从复制模型是怎样的？\"><a href=\"#19、Redis-集群的主从复制模型是怎样的？\" class=\"headerlink\" title=\"19、Redis 集群的主从复制模型是怎样的？\"></a>19、Redis 集群的主从复制模型是怎样的？</h2><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主</p>\n<p>从复制模型,每个节点都会有 N-1 个复制品.</p>\n<h2 id=\"20、Redis-集群会有写操作丢失吗？为什么？\"><a href=\"#20、Redis-集群会有写操作丢失吗？为什么？\" class=\"headerlink\" title=\"20、Redis 集群会有写操作丢失吗？为什么？\"></a>20、Redis 集群会有写操作丢失吗？为什么？</h2><p>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操</p>\n<p>作。</p>\n<h2 id=\"21、Redis-集群之间是如何复制的？\"><a href=\"#21、Redis-集群之间是如何复制的？\" class=\"headerlink\" title=\"21、Redis 集群之间是如何复制的？\"></a>21、Redis 集群之间是如何复制的？</h2><p>异步复制</p>\n<h2 id=\"22、Redis-集群最大节点个数是多少？\"><a href=\"#22、Redis-集群最大节点个数是多少？\" class=\"headerlink\" title=\"22、Redis 集群最大节点个数是多少？\"></a>22、Redis 集群最大节点个数是多少？</h2><p>16384 个。</p>\n<h2 id=\"23、Redis-集群如何选择数据库？\"><a href=\"#23、Redis-集群如何选择数据库？\" class=\"headerlink\" title=\"23、Redis 集群如何选择数据库？\"></a>23、Redis 集群如何选择数据库？</h2><p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p>\n<h2 id=\"24、怎么测试-Redis-的连通性？\"><a href=\"#24、怎么测试-Redis-的连通性？\" class=\"headerlink\" title=\"24、怎么测试 Redis 的连通性？\"></a>24、怎么测试 Redis 的连通性？</h2><p>ping</p>\n<h2 id=\"25、Redis-中的管道有什么用？\"><a href=\"#25、Redis-中的管道有什么用？\" class=\"headerlink\" title=\"25、Redis 中的管道有什么用？\"></a>25、Redis 中的管道有什么用？</h2><p>一次请求&#x2F;响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命</p>\n<p>令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>\n<p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现</p>\n<p>更多关注 Java 大后端公众号支持这个功能，大大加快了从服务器下载新邮件的过程。</p>\n<h2 id=\"26、怎么理解-Redis-事务？\"><a href=\"#26、怎么理解-Redis-事务？\" class=\"headerlink\" title=\"26、怎么理解 Redis 事务？\"></a>26、怎么理解 Redis 事务？</h2><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的</p>\n<p>过程中，不会被其他客户端发送来的命令请求所打断。</p>\n<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>\n<h2 id=\"27、Redis-事务相关的命令有哪几个？\"><a href=\"#27、Redis-事务相关的命令有哪几个？\" class=\"headerlink\" title=\"27、Redis 事务相关的命令有哪几个？\"></a>27、Redis 事务相关的命令有哪几个？</h2><p>MULTI、EXEC、DISCARD、WATCH</p>\n<h2 id=\"28、Redis-key-的过期时间和永久有效分别怎么设置？\"><a href=\"#28、Redis-key-的过期时间和永久有效分别怎么设置？\" class=\"headerlink\" title=\"28、Redis key 的过期时间和永久有效分别怎么设置？\"></a>28、Redis key 的过期时间和永久有效分别怎么设置？</h2><p>EXPIRE 和 PERSIST 命令。</p>\n<h2 id=\"29、Redis-如何做内存优化？\"><a href=\"#29、Redis-如何做内存优化？\" class=\"headerlink\" title=\"29、Redis 如何做内存优化？\"></a>29、Redis 如何做内存优化？</h2><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，</p>\n<p>所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个</p>\n<p>用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户</p>\n<p>的所有信息存储到一张散列表里面.</p>\n<h2 id=\"30、Redis-回收进程如何工作的？\"><a href=\"#30、Redis-回收进程如何工作的？\" class=\"headerlink\" title=\"30、Redis 回收进程如何工作的？\"></a>30、Redis 回收进程如何工作的？</h2><p>一个客户端运行了新的命令，添加了新的数据。</p>\n<p>Redi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。</p>\n<p>一个新的命令被执行，等等。</p>\n<p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</p>\n<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不</p>\n<p>用多久内存限制就会被这个内存使用量超越。</p>\n<h2 id=\"31、Redis-回收使用的是什么算法？\"><a href=\"#31、Redis-回收使用的是什么算法？\" class=\"headerlink\" title=\"31、Redis 回收使用的是什么算法？\"></a>31、Redis 回收使用的是什么算法？</h2><p>LRU 算法</p>\n<h2 id=\"32、Redis-如何做大量数据插入？\"><a href=\"#32、Redis-如何做大量数据插入？\" class=\"headerlink\" title=\"32、Redis 如何做大量数据插入？\"></a>32、Redis 如何做大量数据插入？</h2><p>更多关注 Java 大后端公众号 Redis2.6 开始 redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工</p>\n<p>作。</p>\n<h2 id=\"33、为什么要做-Redis-分区？\"><a href=\"#33、为什么要做-Redis-分区？\" class=\"headerlink\" title=\"33、为什么要做 Redis 分区？\"></a>33、为什么要做 Redis 分区？</h2><p>分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，你</p>\n<p>最多只能使用一台机器的内存。分区使 Redis 的计算能力通过简单地增加计算机得到成倍提</p>\n<p>升,Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>\n<h2 id=\"34、你知道有哪些-Redis-分区实现方案？\"><a href=\"#34、你知道有哪些-Redis-分区实现方案？\" class=\"headerlink\" title=\"34、你知道有哪些 Redis 分区实现方案？\"></a>34、你知道有哪些 Redis 分区实现方案？</h2><p>客户端分区就是在客户端就已经决定数据会被存储到哪个 redis 节点或者从哪个 redis 节点读</p>\n<p>取。大多数客户端已经实现了客户端分区。</p>\n<p>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。</p>\n<p>代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。redis</p>\n<p>和 memcached 的一种代理实现就是 Twemproxy</p>\n<p>查询路由(Query routing) 的意思是客户端随机地请求任意一个 redis 实例，然后由 Redis 将请</p>\n<p>求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接</p>\n<p>将请求从一个 redis 节点转发到另一个 redis 节点，而是在客户端的帮助下直接 redirected 到</p>\n<p>正确的 redis 节点。</p>\n<h2 id=\"35、Redis-分区有什么缺点？\"><a href=\"#35、Redis-分区有什么缺点？\" class=\"headerlink\" title=\"35、Redis 分区有什么缺点？\"></a>35、Redis 分区有什么缺点？</h2><p>涉及多个 key 的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储</p>\n<p>到不同的 Redis 实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</p>\n<p>同时操作多个 key,则不能使用 Redis 事务.</p>\n<p>分区使用的粒度是 key，不能使用一个非常长的排序 key 存储一个数据集（The partitioning</p>\n<p>granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big</p>\n<p>sorted set）.</p>\n<p>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的 Redis 实例和主机</p>\n<p>同时收集 RDB &#x2F; AOF 文件。</p>\n<p>分区时动态扩容或缩容可能非常复杂。Redis 集群在运行时增加或者删除 Redis 节点，能做</p>\n<p>到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这</p>\n<p>种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</p>\n<h2 id=\"36、Redis-持久化数据和缓存怎么做扩容？\"><a href=\"#36、Redis-持久化数据和缓存怎么做扩容？\" class=\"headerlink\" title=\"36、Redis 持久化数据和缓存怎么做扩容？\"></a>36、Redis 持久化数据和缓存怎么做扩容？</h2><p>更多关注 Java 大后端公众号如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。</p>\n<p>如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数</p>\n<p>量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行</p>\n<p>时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。</p>\n<h2 id=\"37、分布式-Redis-是前期做还是后期规模上来了再做好？为什么？\"><a href=\"#37、分布式-Redis-是前期做还是后期规模上来了再做好？为什么？\" class=\"headerlink\" title=\"37、分布式 Redis 是前期做还是后期规模上来了再做好？为什么？\"></a>37、分布式 Redis 是前期做还是后期规模上来了再做好？为什么？</h2><p>既然 Redis 是如此的轻量（单实例只使用 1M 内存）,为防止以后的扩容，最好的办法就是一</p>\n<p>开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式</p>\n<p>运行，使用分区，在同一台服务器上启动多个实例。</p>\n<p>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可</p>\n<p>能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>\n<p>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis</p>\n<p>实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了</p>\n<p>另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</p>\n<h2 id=\"38、Twemproxy-是什么？\"><a href=\"#38、Twemproxy-是什么？\" class=\"headerlink\" title=\"38、Twemproxy 是什么？\"></a>38、Twemproxy 是什么？</h2><p>Twemproxy 是 Twitter 维护的（缓存）代理系统，代理 Memcached 的 ASCII 协议和 Redis 协</p>\n<p>议。它是单线程程序，使用 c 语言编写，运行起来非常快。它是采用 Apache 2.0 license 的开</p>\n<p>源软件。 Twemproxy 支持自动分区，如果其代理的其中一个 Redis 节点不可用时，会自动</p>\n<p>将该节点排除（这将改变原来的 keys-instances 的映射关系，所以你应该仅在把 Redis 当缓存</p>\n<p>时使用 Twemproxy)。 Twemproxy 本身不存在单点问题，因为你可以启动多个 Twemproxy 实</p>\n<p>例，然后让你的客户端去连接任意一个 Twemproxy 实例。 Twemproxy 是 Redis 客户端和服</p>\n<p>务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。</p>\n<h2 id=\"39、支持一致性哈希的客户端有哪些？\"><a href=\"#39、支持一致性哈希的客户端有哪些？\" class=\"headerlink\" title=\"39、支持一致性哈希的客户端有哪些？\"></a>39、支持一致性哈希的客户端有哪些？</h2><p>Redis-rb、Predis 等。</p>\n<h2 id=\"40、Redis-与其他-key-value-存储有什么不同？\"><a href=\"#40、Redis-与其他-key-value-存储有什么不同？\" class=\"headerlink\" title=\"40、Redis 与其他 key-value 存储有什么不同？\"></a>40、Redis 与其他 key-value 存储有什么不同？</h2><p>Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库</p>\n<p>的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外</p>\n<p>的抽象。</p>\n<p>Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡</p>\n<p>更多关注 Java 大后端公众号更多关注 Java 大后端公众号</p>\n<p>内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上</p>\n<p>相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很</p>\n<p>强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要</p>\n<p>进行随机访问。</p>\n<h2 id=\"41、Redis-的内存占用情况怎么样？\"><a href=\"#41、Redis-的内存占用情况怎么样？\" class=\"headerlink\" title=\"41、Redis 的内存占用情况怎么样？\"></a>41、Redis 的内存占用情况怎么样？</h2><p>给你举个例子： 100 万个键值对（键是 0 到 999999 值是字符串“hello world”）在我的 32</p>\n<p>位的 Mac 笔记本上 用了 100MB。同样的数据放到一个 key 里只需要 16MB，</p>\n<p>这是因为键值</p>\n<p>有一个很大的开销。 在 Memcached 上执行也是类似的结果，但是相对 Redis 的开销要小一</p>\n<p>点点，因为 Redis 会记录类型信息引用计数等等。</p>\n<p>当然，大键值对时两者的比例要好很多。</p>\n<p>64 位的系统比 32 位的需要更多的内存开销，尤其是键值对都较小时，这是因为 64 位的系</p>\n<p>统里指针占用了 8 个字节。 但是，当然，64 位系统支持更大的内存，所以为了运行大型的</p>\n<p>Redis 服务器或多或少的需要使用 64 位的系统。</p>\n<h2 id=\"42、都有哪些办法可以降低-Redis-的内存使用情况呢？\"><a href=\"#42、都有哪些办法可以降低-Redis-的内存使用情况呢？\" class=\"headerlink\" title=\"42、都有哪些办法可以降低 Redis 的内存使用情况呢？\"></a>42、都有哪些办法可以降低 Redis 的内存使用情况呢？</h2><p>如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据，</p>\n<p>因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。</p>\n<p>43、查看 Redis 使用情况及状态信息用什么命令？</p>\n<p>info</p>\n<h2 id=\"44、Redis-的内存用完了会发生什么？\"><a href=\"#44、Redis-的内存用完了会发生什么？\" class=\"headerlink\" title=\"44、Redis 的内存用完了会发生什么？\"></a>44、Redis 的内存用完了会发生什么？</h2><p>如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或者</p>\n<p>你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。</p>\n<h2 id=\"45、Redis-是单线程的，如何提高多核-CPU-的利用率？\"><a href=\"#45、Redis-是单线程的，如何提高多核-CPU-的利用率？\" class=\"headerlink\" title=\"45、Redis 是单线程的，如何提高多核 CPU 的利用率？\"></a>45、Redis 是单线程的，如何提高多核 CPU 的利用率？</h2><p>可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时</p>\n<p>候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU，你可以考虑一下分片</p>\n<p>（shard）。</p>\n<h2 id=\"46、一个-Redis-实例最多能存放多少的-keys？List、Set、Sorted-Set-他们最多能存放多少元素？理论上-Redis-可以处理多达-232-的-keys，并且在实际中进行了测试，每个实例至少存放了-2\"><a href=\"#46、一个-Redis-实例最多能存放多少的-keys？List、Set、Sorted-Set-他们最多能存放多少元素？理论上-Redis-可以处理多达-232-的-keys，并且在实际中进行了测试，每个实例至少存放了-2\" class=\"headerlink\" title=\"46、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2\"></a>46、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2</h2><p>亿 5 千万的 keys。我们正在测试一些较大的值。</p>\n<p>任何 list、set、和 sorted set 都可以放 232 个元素。</p>\n<p>换句话说，Redis 的存储极限是系统中的可用内存值。</p>\n<h2 id=\"47、Redis-常见性能问题和解决方案？\"><a href=\"#47、Redis-常见性能问题和解决方案？\" class=\"headerlink\" title=\"47、Redis 常见性能问题和解决方案？\"></a>47、Redis 常见性能问题和解决方案？</h2><p>(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件</p>\n<p>(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次</p>\n<p>(3) 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内</p>\n<p>(4) 尽量避免在压力很大的主库上增加从库</p>\n<p>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;-</p>\n<p>Slave3…</p>\n<p>这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以</p>\n<p>立刻启用 Slave1 做 Master，其他不变。</p>\n<h2 id=\"48、Redis-提供了哪几种持久化方式？\"><a href=\"#48、Redis-提供了哪几种持久化方式？\" class=\"headerlink\" title=\"48、Redis 提供了哪几种持久化方式？\"></a>48、Redis 提供了哪几种持久化方式？</h2><p>RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</p>\n<p>AOF 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢</p>\n<p>复原始的数据,AOF 命令以 redis 协议追加保存每次写的操作到文件末尾.Redis 还能对 AOF 文</p>\n<p>件进行后台重写,使得 AOF 文件的体积不至于过大.</p>\n<p>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p>\n<p>你也可以同时开启两种持久化方式, 在这种情况下, 当 redis 重启的时候会优先载入 AOF 文</p>\n<p>件来恢复原始的数据,因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集</p>\n<p>要完整.</p>\n<p>最重要的事情是了解 RDB 和 AOF 持久化方式的不同,让我们以 RDB 持久化方式开始。</p>\n<h2 id=\"49、如何选择合适的持久化方式？\"><a href=\"#49、如何选择合适的持久化方式？\" class=\"headerlink\" title=\"49、如何选择合适的持久化方式？\"></a>49、如何选择合适的持久化方式？</h2><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化</p>\n<p>更多关注 Java 大后端公众号功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只</p>\n<p>使用 RDB 持久化。</p>\n<p>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）</p>\n<p>非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除</p>\n<p>此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug。</p>\n<h2 id=\"50、修改配置不重启-Redis-会实时生效吗？\"><a href=\"#50、修改配置不重启-Redis-会实时生效吗？\" class=\"headerlink\" title=\"50、修改配置不重启 Redis 会实时生效吗？\"></a>50、修改配置不重启 Redis 会实时生效吗？</h2><p>针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式</p>\n<p>的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要</p>\n<p>重启 Redis。检索 ‘CONFIG GET *’ 命令获取更多信息。</p>\n<p>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前</p>\n<p>CONFIG 命令还不支持的配置参数的时候。</p>\n<p>\\\\\\\\\\\\\\\\</p>\n<h1 id=\"8-MySQL\"><a href=\"#8-MySQL\" class=\"headerlink\" title=\"8.MySQL\"></a>8.MySQL</h1><h2 id=\"1-、数据库的三范式是什么★★★★★\"><a href=\"#1-、数据库的三范式是什么★★★★★\" class=\"headerlink\" title=\"1**、数据库的三范式是什么★★★★★\"></a>1*<strong>*、数据库的三范式是什么★★★★★</strong></h2><p>第一范式：列不可再分</p>\n<p>第二范式：行可以唯一区分，主键约束</p>\n<p>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束</p>\n<p>且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。</p>\n<h2 id=\"2-、数据库引擎有哪些\"><a href=\"#2-、数据库引擎有哪些\" class=\"headerlink\" title=\"**2****、数据库引擎有哪些**\"></a>**2****、数据库引擎有哪些**</h2><p>如何查看 mysql 提供的所有存储引擎</p>\n<p><img src=\"/images/1%E3%80%81JAVA/1709735857375.png\" alt=\"1709735857375\"></p>\n<p><code>mysql&gt; show engines;</code></p>\n<p>mysql 常用引擎包括：MYISAM、Innodb、Memory、MERGE</p>\n<ul>\n<li>MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对</li>\n<li>较小，对事务完整性没有要求，以 select、insert 为主的应用基本上可以使用这引擎</li>\n<li>Innodb:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键</li>\n<li>约束，并发能力强，占用空间是 MYISAM 的 2.5 倍，处理效率相对会差一些</li>\n<li>Memory:全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在 mysql 重</li>\n<li>启时会丢失，默认使用 HASH 索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变</li>\n<li>化不频繁的代码表</li>\n<li>MERGE：是一组 MYISAM 表的组合</li>\n</ul>\n<h2 id=\"3-、-InnoDB-与-MyISAM-的区别\"><a href=\"#3-、-InnoDB-与-MyISAM-的区别\" class=\"headerlink\" title=\"**3**、**InnoDB**与**MyISAM****的区别\"></a>**3**<strong>、*</strong>*InnoDB**<strong>与*</strong>*MyISAM****的区别</h2><ol>\n<li>InnoDB 支持事务，MyISAM 不支持，对于 InnoDB 每一条 SQL 语言都默认封装成事务，自动提交，</li>\n</ol>\n<p>这样会影响速度，所以最好把多条 SQL 语言放在 begin 和 commit 之间，组成一个事务；</p>\n<ol start=\"2\">\n<li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li>\n<li>InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但</li>\n</ol>\n<p>是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，</p>\n<p>因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的</p>\n<p>是数据文件的指针。主键索引和辅助索引是独立的。</p>\n<ol start=\"4\">\n<li>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而 MyISAM 用一</li>\n</ol>\n<p>个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p>\n<ol start=\"5\">\n<li>Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；</li>\n</ol>\n<p>mysql&gt; show engines;<strong>如何选择引擎？</strong></p>\n<p>如果没有特别的需求，使用默认的 Innodb 即可。</p>\n<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>\n<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如</p>\n<p>OA 自动化办公系统。</p>\n<p>**4****、数据库的事务**</p>\n<h2 id=\"4-、数据库的事务★★★★★\"><a href=\"#4-、数据库的事务★★★★★\" class=\"headerlink\" title=\"4**、数据库的事务★★★★★\"></a>4*<strong>*、数据库的事务★★★★★</strong></h2><p><strong>什么是事务？</strong></p>\n<p><strong>：</strong> 多条 sql 语句，要么全部成功，要么全部失败。</p>\n<p><strong>事务的特性：</strong></p>\n<p><strong>数据库事务特性：原子性**</strong>(Atomic)*<strong>*、一致性**</strong>(Consistency)*<strong>*、隔离性**</strong>(Isolation)*<strong>*、持久性**</strong>(Durabiliy)*<strong>*。</strong></p>\n<p><strong>简称**<strong>ACID*</strong>*。</strong></p>\n<p>原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功，整个</p>\n<p>事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。</p>\n<p>一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如 A</p>\n<p>转账 100 元给 B，不管操作是否成功，A 和 B 的账户总额是不变的。</p>\n<p>隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰</p>\n<p>持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。</p>\n<h2 id=\"事务并发产生的三种问题\"><a href=\"#事务并发产生的三种问题\" class=\"headerlink\" title=\"事务并发产生的三种问题\"></a>事务并发产生的三种问题</h2><h2 id=\"脏读：一个事务读取到了另外一个事务没有提交的数据\"><a href=\"#脏读：一个事务读取到了另外一个事务没有提交的数据\" class=\"headerlink\" title=\"脏读：一个事务读取到了另外一个事务没有提交的数据\"></a>脏读：一个事务读取到了另外一个事务没有提交的数据</h2><p>幻读：同一事务中，用同样的操作读取两次，得到的记录数不相同（数据条数）<br>不可重复读：在同一事务中，两次读取同一数据，得到内容不同（数据内容）<br>6.mysql的事务隔离级别<br>读未提交 Read uncommitted：一个事务还没有提交时，它做的变更就能被别的事务看到。<br>读提交 Read committed：一个事物提交之后，它做的变更才会被其他事务看到。<br>可重复读 Repeatable read：一个事物执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。未提交变更对其他事务也是不可见的。<br>串行化 serializable：对于同一行记录，写会加“写锁”，读会加“读锁”，当出现</p>\n<h2 id=\"innodb和myisam区别\"><a href=\"#innodb和myisam区别\" class=\"headerlink\" title=\".innodb和myisam区别\"></a>.innodb和myisam区别</h2><p>innodb支持事务；myisam不支持事务<br>innodb支持外键；myisam不支持外键<br>innodb是聚集索引，数据和索引是捆绑在一起的；myisam是非聚集索引，数据和索引分开的，这也导致他们底层B+树结构不同。<br>innodb每个表下两个文件：.frm文件中保存的是表的结构，.ibd文件中保存的是数据和索引方式<br>myisam每个表下三个文件：一个文件用来保存 表结构，一个文件用来保存 数据，一个文件用来保存 索引</p>\n<h2 id=\"5、索引问题\"><a href=\"#5、索引问题\" class=\"headerlink\" title=\"5、索引问题\"></a><strong>5</strong>、索引问题</h2><p>索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于快速获取信息。</p>\n<p>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，</p>\n<p>索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅</p>\n<p>速地找到表中的数据，而不必扫描整个数据库。</p>\n<p>.索引<br>索引是帮助MySQL高效获取数据的数据结构，通俗来讲索引就好比书本的目录，加快数据库的查询速度。<br>分类<br>按功能逻辑分<br>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个<br>唯一索引：加速查询 + 列值唯一（可以有null）<br>普通索引：仅加速查询<br>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并<br>全文索引：对文本的内容进行分词，进行搜索<br>按物理结构分<br>聚簇索引<br>非聚簇索引★★★★★</p>\n<p>mysql 有 4 种不同的索引：</p>\n<ol>\n<li>主键索引（PRIMARY）</li>\n<li>数据列不允许重复，不允许为 NULL，一个表只能有一个主键。</li>\n<li>唯一索引（UNIQUE）</li>\n<li>数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。</li>\n<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引</li>\n<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索</li>\n<li>引</li>\n<li>普通索引（INDEX）</li>\n<li>可以通过 ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引</li>\n<li>可以通过 ALTER TABLE table_name ADD INDEX index_name(column1, column2,</li>\n<li>column3); 创建组合索引</li>\n<li>全文索引（FULLTEXT）</li>\n<li>可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引</li>\n</ol>\n<p><strong>索引并非是越多越好，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时</strong></p>\n<p><strong>要花费较多的时间维护索引</strong></p>\n<ol>\n<li>索引加快数据库的检索速度</li>\n<li>索引降低了插入、删除、修改等维护任务的速度</li>\n<li>唯一索引可以确保每一行数据的唯一性</li>\n<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li>\n<li>索引需要占物理和数据空间</li>\n</ol>\n<h2 id=\"6、SQL-优化\"><a href=\"#6、SQL-优化\" class=\"headerlink\" title=\"6、SQL 优化\"></a>6、SQL 优化</h2><p>1、查询语句中不要使用 select *</p>\n<p>2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代</p>\n<p>3、减少使用 IN 或者 NOT IN ,使用 exists，not exists 或者关联查询语句替代</p>\n<p>4、or 的查询尽量用 union 或者 union all 代替(在确认没有重复数据或者不用剔除重复数据时，union</p>\n<p>all 会更好)</p>\n<p>5、应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>\n<p>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫</p>\n<p>描，如： select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null</p>\n<p>值，然后这样查询： select id from t where num&#x3D;0</p>\n<h2 id=\"7-、简单说一说-drop-、-delete-与-truncate-的区别\"><a href=\"#7-、简单说一说-drop-、-delete-与-truncate-的区别\" class=\"headerlink\" title=\"**7**、简单说一说**drop**、**delete**与**truncate****的区别**\"></a>**7**<strong>、简单说一说*</strong>*drop**<strong>、*</strong>*delete**<strong>与*</strong>*truncate****的区别**</h2><p>SQL 中的 drop、delete、truncate 都表示删除，但是三者有一些差别</p>\n<p>delete 和 truncate 只删除表的数据不删除表的结构</p>\n<p>速度,一般来说: drop&gt; truncate &gt;delete</p>\n<p>delete 语句是 dml,这个操作会放到 rollback segement 中,事务提交之后才生效;</p>\n<p>如果有相应的 trigger,执行的时候将被触发. truncate,drop 是 ddl, 操作立即生效,原数据不放到 rollback</p>\n<p>segment 中,不能回滚. 操作不触发 trigger.</p>\n<h2 id=\"8-、什么是视图\"><a href=\"#8-、什么是视图\" class=\"headerlink\" title=\"**8****、什么是视图**\"></a>**8****、什么是视图**</h2><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一</p>\n<p>个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表</p>\n<p>查询。</p>\n<h2 id=\"9-、-什么是内联接、左外联接、右外联接？\"><a href=\"#9-、-什么是内联接、左外联接、右外联接？\" class=\"headerlink\" title=\"**9****、 什么是内联接、左外联接、右外联接？**\"></a>**9****、 什么是内联接、左外联接、右外联接？**</h2><ol>\n<li>内联接（Inner Join）：匹配 2 张表中相关联的记录。</li>\n<li>左外联接（Left Outer Join）：除了匹配 2 张表中相关联的记录外，还会匹配左表中剩余的记录，</li>\n<li>右表中未匹配到的字段用 NULL 表示。</li>\n<li>右外联接（Right Outer Join）：除了匹配 2 张表中相关联的记录外，还会匹配右表中剩余的记录，</li>\n<li>左表中未匹配到的字段用 NULL 表示。在判定左表和右表时，要根据表名出现在 Outer Join 的左右</li>\n<li>位置关系。</li>\n</ol>\n<h2 id=\"10-、并发事务带来哪些问题-隔离级别\"><a href=\"#10-、并发事务带来哪些问题-隔离级别\" class=\"headerlink\" title=\"**10**、并发事务带来哪些问题**?****隔离级别**\"></a>**10**<strong>、并发事务带来哪些问题*</strong>*?****隔离级别**</h2><p><strong>脏读</strong></p>\n<p><strong>不可重复读</strong></p>\n<p><strong>幻影读</strong></p>\n<p>READ-UNCOMMITTED</p>\n<p>√</p>\n<p>√</p>\n<p>√</p>\n<p>READ-COMMITTED</p>\n<p>×</p>\n<p>√</p>\n<p>√</p>\n<p>REPEATABLE-READ</p>\n<p>×</p>\n<p>×</p>\n<p>√</p>\n<p>SERIALIZABLE</p>\n<p>×</p>\n<p>×</p>\n<p>×</p>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一</p>\n<p>数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<p><strong>脏读（**<strong>Dirty read*</strong>*）**</strong>:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到</p>\n<p>数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提</p>\n<p>交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确</p>\n<p>的。</p>\n<p><strong>丢失修改（**<strong>Lost to modify*</strong>*）**</strong>:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那</p>\n<p>么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结</p>\n<p>果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事</p>\n<p>务 1 修改 A&#x3D;A-1，事务 2 也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</p>\n<p><strong>不可重复读（**<strong>Unrepeatableread*</strong>*）**</strong>:** 指在一个事务内多次读同一数据。在这个事务还没有结束</p>\n<p>时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改</p>\n<p>导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样</p>\n<p>的情况，因此称为不可重复读。</p>\n<p><strong>幻读（**<strong>Phantom read*</strong>*）**</strong>:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接</p>\n<p>着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了</p>\n<p>一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<p><strong>不可重复读和幻读区别：</strong></p>\n<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者</p>\n<p>删除比如多次读取一条记录发现记录增多或减少了。</p>\n<h2 id=\"11-、事务隔离级别有哪些-MySQL-的默认隔离级别是\"><a href=\"#11-、事务隔离级别有哪些-MySQL-的默认隔离级别是\" class=\"headerlink\" title=\"11**、事务隔离级别有哪些**?MySQL**的默认隔离级别是**?\"></a><strong>11**<strong>、事务隔离级别有哪些*</strong>*?MySQL**<strong>的默认隔离级别是*</strong>*?</strong></h2><p><strong>SQL</strong> <strong>标准定义了四个隔离级别：</strong></p>\n<p><strong>READ-UNCOMMITTED(**<strong>读取未提交*</strong>*)**<strong>：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，</strong>可能会**</p>\n<p><strong>导致脏读、幻读或不可重复读</strong>。</p>\n<p><strong>READ-COMMITTED(**<strong>读取已提交*</strong>*)**<strong>：</strong> 允许读取并发事务已经提交的数据，</strong>可以阻止脏读，但是幻**</p>\n<p><strong>读或不可重复读仍有可能发生</strong>。</p>\n<p>**REPEATABLE-READ(**<strong>可重复读*</strong>*)****：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务</p>\n<p>自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</p>\n<p>**SERIALIZABLE(**<strong>可串行化*</strong>*)****：** 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执</p>\n<p>行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻</strong></p>\n<p><strong>读</strong>。</p>\n<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ****（可重读）**。我们可以通过</p>\n<p>SELECT @@tx_isolation; 命令来查看这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ****（可重读）**</p>\n<p>事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如</p>\n<p>SQL Server) 是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ****（可重**</p>\n<p><strong>读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 <strong>SERIALIZABLE(**<strong>可串行化*</strong>*)</strong> 隔离级</p>\n<p>别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ\u0002</strong></p>\n<p><strong>COMMITTED(**<strong>读取提交内容*</strong>*)</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEAaTABLE\u0002</strong></p>\n<p>**READ****（可重读）** 并不会有任何性能损失。</p>\n<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(**<strong>可串行化*</strong>*)</strong> 隔离级别。</p>\n<h2 id=\"12-、大表如何优化？\"><a href=\"#12-、大表如何优化？\" class=\"headerlink\" title=\"**12****、大表如何优化？**\"></a>**12****、大表如何优化？**</h2><p>当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：</p>\n<p><strong>1.</strong> <strong>限定数据的范围</strong></p>\n<p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以</p>\n<p>控制在一个月的范围内；</p>\n<p><strong>2.</strong> <strong>读**</strong>&#x2F;*<strong>*写分离</strong></p>\n<p>经典的数据库拆分方案，主库负责写，从库负责读；</p>\n<p><strong>3.</strong> <strong>垂直分区</strong></p>\n<p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，</p>\n<p>可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>\n<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大</p>\n<p>家应该就更容易理解了。</p>\n<p><strong>垂直拆分的优点：</strong> 可以使得列数据变小，在查询时减少读取的 Block 数，减少 I&#x2F;O 次数。此外，垂</p>\n<p>直分区可以简化表的结构，易于维护。</p>\n<p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起 Join 操作，可以通过在应用层进行</p>\n<p>Join 来解决。此外，垂直分区会让事务变得更加复杂；</p>\n<p><strong>4.</strong> <strong>水平分区</strong></p>\n<p>mysql&gt; SELECT @@tx_isolation;</p>\n<p>+—————–+</p>\n<p>| @@tx_isolation |</p>\n<p>+—————–+</p>\n<p>| REPEATABLE-READ |</p>\n<p>+—————–+<strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了</strong></p>\n<p><strong>分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>\n<p>水平拆分是指数据表行的拆分，表的行数超过 200 万行时，就会变慢，这时可以把一张的表的数据拆成</p>\n<p>多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据</p>\n<p>量过大对性能造成影响。</p>\n<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但</p>\n<p>由于表的数据还是在同一台机器上，其实对于提升 MySQL 并发能力没有什么意义，所以 <strong>水平拆分最好</strong></p>\n<p><strong>分库</strong> 。</p>\n<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨节点 Join 性能较</p>\n<p>差，逻辑复杂。《Java 工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、</strong></p>\n<p><strong>部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题</p>\n<p>的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络 I&#x2F;O。</p>\n<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>\n<p><strong>客户端代理： 分片逻辑在应用端，封装在**<strong>jar*</strong>*包中，通过修改或者封装**<strong>JDBC*</strong>*层来实现。</strong> 当当网的</p>\n<p><strong>Sharding-JDBC</strong> 、阿里的 TDDL 是两种比较常用的实现。</p>\n<p><strong>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在</p>\n<p>谈的 <strong>Mycat</strong> 、360 的 Atlas、网易的 DDB 等等都是这种架构的实现。</p>\n<p>详细内容可以参考： MySQL 大表优化方案: <a href=\"https://segmentfault.com/a/1190000006158186\">https://segmentfault.com/a/1190000006158186</a></p>\n<h2 id=\"13-、分库分表之后-id-主键如何处理？\"><a href=\"#13-、分库分表之后-id-主键如何处理？\" class=\"headerlink\" title=\"13**、分库分表之后**,id 主键如何处理？\"></a><strong>13**<strong>、分库分表之后*</strong>*,id</strong> <strong>主键如何处理？</strong></h2><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来</p>\n<p>支持。</p>\n<p>生成全局 id 有下面这几种方式：</p>\n<p><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的</p>\n<p>名字的标示比如文件的名字。</p>\n<p><strong>数据库自增</strong> <strong>id</strong> : 两台数据库分别设置不同步长，生成不重复 ID 的策略来实现高可用。这种方式生成</p>\n<p>的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</p>\n<p><strong>利用</strong> <strong>redis</strong> <strong>生成</strong> <strong>id :</strong> 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更</p>\n<p>加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>\n<p>**Twitter**<strong>的*</strong>*snowflake****算法** ：Github 地址：<a href=\"https://github.com/twitter-archive/snowflake%E3%80%82\">https://github.com/twitter-archive/snowflake。</a></p>\n<p><strong>美团的**<strong>Leaf*</strong>*分布式**<strong>ID*</strong>*生成系统</strong> ：Leaf 是美团开源的分布式 ID 生成器，能保证全局唯一性、趋势递</p>\n<p>增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、</p>\n<p>Zookeeper 等中间件。感觉还不错。美团技术团队的一篇文章：<a href=\"https://tech.meituan.com/2017/\">https://tech.meituan.com/2017/</a></p>\n<p>04&#x2F;21&#x2F;mt-leaf.html 。**14**<strong>、*</strong>*mysql****有关权限的表都有哪几个**</p>\n<p>MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里，由</p>\n<p>mysql_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和 host。下面分</p>\n<p>别介绍一下这些表的结构和内容：</p>\n<p>user 权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</p>\n<p>db 权限表：记录各个帐号在各个数据库上的操作权限。</p>\n<p>table_priv 权限表：记录数据表级的操作权限。</p>\n<p>columns_priv 权限表：记录数据列级的操作权限。</p>\n<p>host 权限表：配合 db 权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受</p>\n<p>GRANT 和 REVOKE 语句的影响。</p>\n<h2 id=\"15-、-mysql-有哪些数据类型\"><a href=\"#15-、-mysql-有哪些数据类型\" class=\"headerlink\" title=\"**15**、**mysql****有哪些数据类型**\"></a>**15**<strong>、*</strong>*mysql****有哪些数据类型**</h2><p>**1****、整数类型** ，包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示 1 字节、2 字节、3</p>\n<p>字节、4 字节、8 字节整数。任何整数类型都可以加上 UNSIGNED 属性，表示数据是无符号的，即非负整</p>\n<p>数。</p>\n<p>长度：整数类型可以被指定长度，例如：INT(11)表示长度为 11 的 INT 类型。长度在大多数场景是没有意</p>\n<p>义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和 UNSIGNED ZEROFILL 属性配</p>\n<p>合使用才有意义。</p>\n<p>例子，假定类型设定为 INT(5)，属性为 UNSIGNED ZEROFILL，如果用户插入的数据为 12 的话，那么数</p>\n<p>据库实际存储数据为 00012。</p>\n<p>**2****、实数类型**，包括 FLOAT、DOUBLE、DECIMAL。</p>\n<p>DECIMAL 可以用于存储比 BIGINT 还大的整型，能存储精确的小数。</p>\n<p>而 FLOAT 和 DOUBLE 是有取值范围的，并支持使用标准的浮点进行近似计算。</p>\n<p>计算时 FLOAT 和 DOUBLE 相比 DECIMAL 效率更高一些，DECIMAL 你可以理解成是用字符串进行处理。</p>\n<p>**3****、字符串类型**，包括 VARCHAR、CHAR、TEXT、BLOB</p>\n<p>VARCHAR 用于存储可变长字符串，它比定长类型更节省空间。</p>\n<p>VARCHAR 使用额外 1 或 2 个字节存储字符串长度。列长度小于 255 字节时，使用 1 字节表示，否则使用 2</p>\n<p>字节表示。</p>\n<p>VARCHAR 存储的内容超出设置的长度时，内容会被截断。</p>\n<p>CHAR 是定长的，根据定义的字符串长度分配足够的空间。</p>\n<p>CHAR 会根据需要使用空格进行填充方便比较。</p>\n<p>CHAR 适合存储很短的字符串，或者所有值都接近同一个长度。</p>\n<p>CHAR 存储的内容超出设置的长度时，内容同样会被截断。</p>\n<p><strong>使用策略：</strong></p>\n<p>对于经常变更的数据来说，CHAR 比 VARCHAR 更好，因为 CHAR 不容易产生碎片。</p>\n<p>对于非常短的列，CHAR 比 VARCHAR 在存储空间上更有效率。</p>\n<p>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。</p>\n<p>尽量避免使用 TEXT&#x2F;BLOB 类型，查询时会使用临时表，导致严重的性能开销。</p>\n<p>**4**<strong>、枚举类型（*</strong>*ENUM****）**，把不重复的数据存储为一个预定义的集合。</p>\n<p>有时可以使用 ENUM 代替常用的字符串类型。</p>\n<p>ENUM 存储非常紧凑，会把列表值压缩到一个或两个字节。</p>\n<p>ENUM 在内部存储时，其实存的是整数。</p>\n<p>尽量避免使用数字作为 ENUM 枚举的常量，因为容易混乱。</p>\n<p>排序是按照内部存储的整数**5****、日期和时间类型**，尽量使用 timestamp，空间效率高于 datetime，</p>\n<p>用整数保存时间戳通常不方便处理。</p>\n<p>如果需要存储微妙，可以使用 bigint 存储。</p>\n<p>看到这里，这道真题是不是就比较容易回答了。</p>\n<h2 id=\"16-、创建索引的三种方式，删除索引\"><a href=\"#16-、创建索引的三种方式，删除索引\" class=\"headerlink\" title=\"**16****、创建索引的三种方式，删除索引**\"></a>**16****、创建索引的三种方式，删除索引**</h2><p>第一种方式：在执行 CREATE TABLE 时创建索引</p>\n<p>第二种方式：使用 ALTER TABLE 命令去增加索引</p>\n<p>ALTER TABLE 用来创建普通索引、UNIQUE 索引或 PRIMARY KEY 索引。</p>\n<p>其中 table_name 是要增加索引的表名，column_list 指出对哪些列进行索引，多列时各列之间用逗号分</p>\n<p>隔。</p>\n<p>索引名 index_name 可自己命名，缺省时，MySQL 将根据第一个索引列赋一个名称。另外，ALTER</p>\n<p>TABLE 允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>\n<p>第三种方式：使用 CREATE INDEX 命令创建</p>\n<p>CREATE INDEX 可对表增加普通索引或 UNIQUE 索引。（但是，不能创建 PRIMARY KEY 索引）</p>\n<p>删除索引</p>\n<p>根据索引名删除普通索引、唯一索引、全文索引： alter table 表名 drop KEY 索引名</p>\n<p>删除主键索引： alter table 表名 drop primary key （因为主键只有一个）。这里值得注意的是，</p>\n<p>如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>\n<p>CREATE TABLE user_index2 (</p>\n<p>id INT auto_increment PRIMARY KEY,</p>\n<p>first_name VARCHAR (16),</p>\n<p>last_name VARCHAR (16),</p>\n<p>id_card VARCHAR (18),</p>\n<p>information text,</p>\n<p>KEY name (first_name, last_name),</p>\n<p>FULLTEXT KEY (information),</p>\n<p>UNIQUE KEY (id_card)</p>\n<p>);</p>\n<p>ALTER TABLE table_name ADD INDEX index_name (column_list);</p>\n<p>CREATE INDEX index_name ON table_name (column_list);</p>\n<p>alter table user_index drop KEY name;</p>\n<p>alter table user_index drop KEY id_card;</p>\n<p>alter table user_index drop KEY information;需要取消自增长再行删除：</p>\n<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>\n<h1 id=\"2、未分类\"><a href=\"#2、未分类\" class=\"headerlink\" title=\"2、未分类\"></a>2、未分类</h1><h2 id=\"1、你知道的-List-都有哪些？\"><a href=\"#1、你知道的-List-都有哪些？\" class=\"headerlink\" title=\"1、你知道的 List 都有哪些？\"></a>1、你知道的 List 都有哪些？</h2><p>ArrayList、LinkedList、Vector 等。</p>\n<h2 id=\"2、List-和-Vector-有什么区别？\"><a href=\"#2、List-和-Vector-有什么区别？\" class=\"headerlink\" title=\"2、List 和 Vector 有什么区别？\"></a>2、List 和 Vector 有什么区别？</h2><p>Vector 是 List 接口下线程安全的集合。</p>\n<h2 id=\"3、List-是有序的吗？\"><a href=\"#3、List-是有序的吗？\" class=\"headerlink\" title=\"3、List 是有序的吗？\"></a>3、List 是有序的吗？</h2><p>List 是有序的。</p>\n<h2 id=\"4、ArrayList-和-LinkedList-的区别？分别用在什么场景？\"><a href=\"#4、ArrayList-和-LinkedList-的区别？分别用在什么场景？\" class=\"headerlink\" title=\"4、ArrayList 和 LinkedList 的区别？分别用在什么场景？\"></a>4、ArrayList 和 LinkedList 的区别？分别用在什么场景？</h2><p>ArrayList 和 LinkedList 数据结构不一样，前者用在查询较多的场合，后者适用于插入较多的</p>\n<p>场合。</p>\n<h2 id=\"5、ArrayList-和-LinkedList-的底层数据结构是什么？\"><a href=\"#5、ArrayList-和-LinkedList-的底层数据结构是什么？\" class=\"headerlink\" title=\"5、ArrayList 和 LinkedList 的底层数据结构是什么？\"></a>5、ArrayList 和 LinkedList 的底层数据结构是什么？</h2><p>ArrayList 使用的是数组结构，LinkedList 使用的是链表结构。</p>\n<h2 id=\"6、ArrayList-默认大小是多少，是如何扩容的？\"><a href=\"#6、ArrayList-默认大小是多少，是如何扩容的？\" class=\"headerlink\" title=\"6、ArrayList 默认大小是多少，是如何扩容的？\"></a>6、ArrayList 默认大小是多少，是如何扩容的？</h2><p>Jdk1.7 之前 ArrayList 默认大小是 10，JDK1.7 之后是 0，JDK 差异，每次约按 1.5 倍扩容。</p>\n<h2 id=\"7、List-是线程安全的吗？如果要线程安全要怎么做？\"><a href=\"#7、List-是线程安全的吗？如果要线程安全要怎么做？\" class=\"headerlink\" title=\"7、List 是线程安全的吗？如果要线程安全要怎么做？\"></a>7、List 是线程安全的吗？如果要线程安全要怎么做？</h2><p>List 中 的 Vector 才 是 线 程 安 全 的 ， 其 他 要 实 现 线 程 安 全 使 用 工 具 类</p>\n<p>Collections.synchronizedList(new ArrayList())方法。</p>\n<h2 id=\"8、怎么给-List-排序？\"><a href=\"#8、怎么给-List-排序？\" class=\"headerlink\" title=\"8、怎么给 List 排序？\"></a>8、怎么给 List 排序？</h2><p>使用 List 自身的 sort 方法，或者使用 Collections.sort(list)方法;</p>\n<h2 id=\"9、Arrays-asList-方法后的-List-可以扩容吗？\"><a href=\"#9、Arrays-asList-方法后的-List-可以扩容吗？\" class=\"headerlink\" title=\"9、Arrays.asList 方法后的 List 可以扩容吗？\"></a>9、Arrays.asList 方法后的 List 可以扩容吗？</h2><p>Arrays.asList 使用的是 final 数组，并且不支持 add 方法，不支持扩容。</p>\n<h2 id=\"10、List-和-Array-之间如何互相转换？\"><a href=\"#10、List-和-Array-之间如何互相转换？\" class=\"headerlink\" title=\"10、List 和 Array 之间如何互相转换？\"></a>10、List 和 Array 之间如何互相转换？</h2><p>List&gt;Array 使用 toArray 方法，Array&gt;List 使用 Arrays.asList(array)方法，由于它是固定的，不固</p>\n<p>定的可以使用 new ArrayList(Arrays.asList(array))。</p>\n"},{"title":"liunx","date":"2024-03-18T14:13:13.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/B8B163278E23BA1602FC65A3FE65F386A2CDFBA635A7FD76F98CCE73CA700417.jpeg","_content":"# 一.liunx简介\n```","source":"_posts/liunx.md","raw":"---\ntitle: liunx\ndate: 2024-03-18 22:13:13\ntags: liunx\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/B8B163278E23BA1602FC65A3FE65F386A2CDFBA635A7FD76F98CCE73CA700417.jpeg\n---\n# 一.liunx简介\n```","slug":"liunx","published":1,"updated":"2024-03-20T04:17:29.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgxz001hiou23x8z37kz","content":"<h1 id=\"一-liunx简介\"><a href=\"#一-liunx简介\" class=\"headerlink\" title=\"一.liunx简介\"></a>一.liunx简介</h1><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\"></span></span></code></pre></div>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一-liunx简介\"><a href=\"#一-liunx简介\" class=\"headerlink\" title=\"一.liunx简介\"></a>一.liunx简介</h1><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\"></span></span></code></pre></div>"},{"title":"pinia 使用方法详解","date":"2024-03-19T07:34:53.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/logo.svg","_content":"\n## 一：Pinia简介和五大优势\n\nPinia是vue生态里Vuex的替代者，一个全新的vue状态管理库。在Vue3成为正式版以后，尤雨溪强势推荐的项目就是Pinia。\n那先来看看Pinia比Vuex好的地方，也就是Pinia的五大优势。\n\n1. 可以对Vue2和Vue3做到很好的支持，也就是老项目也可以使用Pinia。\n2. 抛弃了Mutations的操作，只有state、getters和actions.极大的简化了状态管理库的使用，让代码编写更加容易直观。\n3. 不需要嵌套模块，符合Vue3的Composition api ，让代码更加扁平化。\n4. 完整的TypeScript支持。Vue3版本的一大优势就是对TypeScript的支持，所以Pinia也做到了完整的支持。如果你对Vuex很熟悉的化，一定知道Vuex对TS的语法支持不是完整的（经常被吐槽）。\n5. 代码更加简洁，可以实现很好的代码自动分割。Vue2的时代，写代码需要来回翻滚屏幕屏幕找变量，非常的麻烦，Vue3的Composition api完美了解决这个问题。 可以实现代码自动分割，pinia也同样继承了这个优点。\n   \n\n## 二：Pinia开发环境安装\n\n####  1.使用Vite就需要先初始化vite： \n\n```shell\nnpm init vite@latest\n\n```\n\n####  2.启动项目： \n\n```shell\nnpm install\nnpm run dev\n\n```\n\n####  3.pinia的安装： \n\n```shell\nnpm install pinia\n\n```\n\n## 三：用Pinia的方式创建一个store\n\n####  1.在main.ts文件里引入Pinia \n\n```js\nimport { createPinia } from 'pinia'\n\napp.use(createPinia())\n```\n\n#### **2.创建pinia**\n\n```\nimport {defineStore} from 'pinia'\nconst useAgeStore = defineStore('use', {\n    state:()=>{//state 相当于 data 存储变量\n        return {}\n    },\n    getters: {//getters 相当于计算属性 computed\n        getAge: (state) => {\n            return state.age\n        }\n    },\n    actions: {//actions 相当于 methods\n        setAge(age) {\n            this.age = age\n        }\n    }\n}) \n```\n\n\n\n#### 2.创建store\n\n**<u>*store实例相当于一个容器，里面存放的有类似于data，计算属性，方法之类的东西</u>***。通过defineStore()方法定义\n\n在src下面创建一个store文件夹，再创建与之对应的js文件，比如user.js\n\n```js\nimport { defineStore } from 'pinia'\n​\n// useStore 可以是 useUser、useCart 之类的任何东西\n// 第一个参数是应用程序中 store 的唯一 id\nexport const useUser = defineStore('user', {\n  // other options...\n})\n```\n\n3.使用store\n\n```javascript\n<script setup>\nimport { useUser } from '@/store/user.js'\nconst store = useUser()\nconsole.log(store)\n</script>\n```\n\n 4.添加state \n\n```\nimport { defineStore } from 'pinia'\n​\n// 第一个参数是应用程序中 store 的唯一 id\n// 第二个参数是配置对象\nexport const useUser = defineStore('user', {\n  // state是一个函数，返回一个对象\n  state: () => {\n    return {\n      userName: 'jack',\n      avatar: 'https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/363.jpg'\n    }\n  }\n})\n```\n\n## 1.state\n\n1.读取state\n\n```js\nimport { storeToRefs } from 'pinia'\nconst userStore = useUser()\n// 如果直接解构出数据，这个数据不是响应式的。如果想要变成响应式的，需要调用storeToRefs方法\nconst { userName, avatar } = storeToRefs(userStore)\n```\n\n####  1.修改state \n\n```js\nuserStore.userName = '张三'\n```\n\n####  2.批量修改state \n\n```js\n// 可以用来修改单个属性\nuserStore.$patch({\n  userName: '张三'\n})\n    \n// 这种回调函数的形式适合修改集合类的数据，比如数组\nuserStore.$patch((state) => {\n  state.avatar = 'https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/596.jpg'\n})\n```\n\n####  3.重置state \n\n```js\n// 重置\n  userStore.$reset()\n```\n\n#### 4.直接替换整个state \n\n```js\n// 替换\nuserStore.$state = { userName: 'rose', avatar: 'https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/854.jpg' }\n```\n\n\n\n## 2.getters\n\n#### 1.基础使用\n\n类似计算属性。推荐里面传递一个形参的写法，不容易出错。\n\n```js\n  getters: {\n    isAdult: (state) => {\n      return state.age >= 18 ? '成年人' : '未成年'\n    }\n  }\n```\n\n####  2.获取 \n\n```js\n// 直接获取\n<div>{{userStore.isAdult}}</div>\n```\n\n#### 3. 调用本模块其他getters \n\n```js\n  getters: {\n    isAdult: (state) => {\n      return state.age >= 18 ? '成年人' : '未成年'\n    },\n    msg: (state) => {\n      // msg这个getter访问了自身的getter（isAdult）\n      return state.userName + state.isAdult\n    }\n  }\n```\n\n#### 4.getters传参 \n\n```js\n  getters: {\n    isAdmin: (state) => {\n      // 如果getter里面是返回的函数，那么它就可以传参数了\n      return (name) => name === 'admin' ? '是管理员' : '不是管理员'\n    }\n  }\n```\n\n 调用： \n\n```vue\n{{userStore.isAdmin}}\n```\n\n## 3.actions\n\n```js\n  actions: {\n    // 这里的方法要写成普通函数，因为里面需要通过this去访问state里面的数据\n    changeNameAsync (newName) {\n      setTimeout(() => {\n        // actions里面可以访问state\n        this.userName = newName\n      }, 1000)\n    }\n  }\n```\n\n详情可见官方文档 :  https://pinia.vuejs.org","source":"_posts/pinia.md","raw":"---\ntitle:  pinia 使用方法详解\ndate: 2024-03-19 15:34:53\ntags:\n    - pinia\ncategories:\n    - 前端\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/logo.svg\n---\n\n## 一：Pinia简介和五大优势\n\nPinia是vue生态里Vuex的替代者，一个全新的vue状态管理库。在Vue3成为正式版以后，尤雨溪强势推荐的项目就是Pinia。\n那先来看看Pinia比Vuex好的地方，也就是Pinia的五大优势。\n\n1. 可以对Vue2和Vue3做到很好的支持，也就是老项目也可以使用Pinia。\n2. 抛弃了Mutations的操作，只有state、getters和actions.极大的简化了状态管理库的使用，让代码编写更加容易直观。\n3. 不需要嵌套模块，符合Vue3的Composition api ，让代码更加扁平化。\n4. 完整的TypeScript支持。Vue3版本的一大优势就是对TypeScript的支持，所以Pinia也做到了完整的支持。如果你对Vuex很熟悉的化，一定知道Vuex对TS的语法支持不是完整的（经常被吐槽）。\n5. 代码更加简洁，可以实现很好的代码自动分割。Vue2的时代，写代码需要来回翻滚屏幕屏幕找变量，非常的麻烦，Vue3的Composition api完美了解决这个问题。 可以实现代码自动分割，pinia也同样继承了这个优点。\n   \n\n## 二：Pinia开发环境安装\n\n####  1.使用Vite就需要先初始化vite： \n\n```shell\nnpm init vite@latest\n\n```\n\n####  2.启动项目： \n\n```shell\nnpm install\nnpm run dev\n\n```\n\n####  3.pinia的安装： \n\n```shell\nnpm install pinia\n\n```\n\n## 三：用Pinia的方式创建一个store\n\n####  1.在main.ts文件里引入Pinia \n\n```js\nimport { createPinia } from 'pinia'\n\napp.use(createPinia())\n```\n\n#### **2.创建pinia**\n\n```\nimport {defineStore} from 'pinia'\nconst useAgeStore = defineStore('use', {\n    state:()=>{//state 相当于 data 存储变量\n        return {}\n    },\n    getters: {//getters 相当于计算属性 computed\n        getAge: (state) => {\n            return state.age\n        }\n    },\n    actions: {//actions 相当于 methods\n        setAge(age) {\n            this.age = age\n        }\n    }\n}) \n```\n\n\n\n#### 2.创建store\n\n**<u>*store实例相当于一个容器，里面存放的有类似于data，计算属性，方法之类的东西</u>***。通过defineStore()方法定义\n\n在src下面创建一个store文件夹，再创建与之对应的js文件，比如user.js\n\n```js\nimport { defineStore } from 'pinia'\n​\n// useStore 可以是 useUser、useCart 之类的任何东西\n// 第一个参数是应用程序中 store 的唯一 id\nexport const useUser = defineStore('user', {\n  // other options...\n})\n```\n\n3.使用store\n\n```javascript\n<script setup>\nimport { useUser } from '@/store/user.js'\nconst store = useUser()\nconsole.log(store)\n</script>\n```\n\n 4.添加state \n\n```\nimport { defineStore } from 'pinia'\n​\n// 第一个参数是应用程序中 store 的唯一 id\n// 第二个参数是配置对象\nexport const useUser = defineStore('user', {\n  // state是一个函数，返回一个对象\n  state: () => {\n    return {\n      userName: 'jack',\n      avatar: 'https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/363.jpg'\n    }\n  }\n})\n```\n\n## 1.state\n\n1.读取state\n\n```js\nimport { storeToRefs } from 'pinia'\nconst userStore = useUser()\n// 如果直接解构出数据，这个数据不是响应式的。如果想要变成响应式的，需要调用storeToRefs方法\nconst { userName, avatar } = storeToRefs(userStore)\n```\n\n####  1.修改state \n\n```js\nuserStore.userName = '张三'\n```\n\n####  2.批量修改state \n\n```js\n// 可以用来修改单个属性\nuserStore.$patch({\n  userName: '张三'\n})\n    \n// 这种回调函数的形式适合修改集合类的数据，比如数组\nuserStore.$patch((state) => {\n  state.avatar = 'https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/596.jpg'\n})\n```\n\n####  3.重置state \n\n```js\n// 重置\n  userStore.$reset()\n```\n\n#### 4.直接替换整个state \n\n```js\n// 替换\nuserStore.$state = { userName: 'rose', avatar: 'https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/854.jpg' }\n```\n\n\n\n## 2.getters\n\n#### 1.基础使用\n\n类似计算属性。推荐里面传递一个形参的写法，不容易出错。\n\n```js\n  getters: {\n    isAdult: (state) => {\n      return state.age >= 18 ? '成年人' : '未成年'\n    }\n  }\n```\n\n####  2.获取 \n\n```js\n// 直接获取\n<div>{{userStore.isAdult}}</div>\n```\n\n#### 3. 调用本模块其他getters \n\n```js\n  getters: {\n    isAdult: (state) => {\n      return state.age >= 18 ? '成年人' : '未成年'\n    },\n    msg: (state) => {\n      // msg这个getter访问了自身的getter（isAdult）\n      return state.userName + state.isAdult\n    }\n  }\n```\n\n#### 4.getters传参 \n\n```js\n  getters: {\n    isAdmin: (state) => {\n      // 如果getter里面是返回的函数，那么它就可以传参数了\n      return (name) => name === 'admin' ? '是管理员' : '不是管理员'\n    }\n  }\n```\n\n 调用： \n\n```vue\n{{userStore.isAdmin}}\n```\n\n## 3.actions\n\n```js\n  actions: {\n    // 这里的方法要写成普通函数，因为里面需要通过this去访问state里面的数据\n    changeNameAsync (newName) {\n      setTimeout(() => {\n        // actions里面可以访问state\n        this.userName = newName\n      }, 1000)\n    }\n  }\n```\n\n详情可见官方文档 :  https://pinia.vuejs.org","slug":"pinia","published":1,"updated":"2024-03-20T06:24:03.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgy0001jiou20xmy4j7k","content":"<h2 id=\"一：Pinia简介和五大优势\"><a href=\"#一：Pinia简介和五大优势\" class=\"headerlink\" title=\"一：Pinia简介和五大优势\"></a>一：Pinia简介和五大优势</h2><p>Pinia是vue生态里Vuex的替代者，一个全新的vue状态管理库。在Vue3成为正式版以后，尤雨溪强势推荐的项目就是Pinia。<br>那先来看看Pinia比Vuex好的地方，也就是Pinia的五大优势。</p>\n<ol>\n<li>可以对Vue2和Vue3做到很好的支持，也就是老项目也可以使用Pinia。</li>\n<li>抛弃了Mutations的操作，只有state、getters和actions.极大的简化了状态管理库的使用，让代码编写更加容易直观。</li>\n<li>不需要嵌套模块，符合Vue3的Composition api ，让代码更加扁平化。</li>\n<li>完整的TypeScript支持。Vue3版本的一大优势就是对TypeScript的支持，所以Pinia也做到了完整的支持。如果你对Vuex很熟悉的化，一定知道Vuex对TS的语法支持不是完整的（经常被吐槽）。</li>\n<li>代码更加简洁，可以实现很好的代码自动分割。Vue2的时代，写代码需要来回翻滚屏幕屏幕找变量，非常的麻烦，Vue3的Composition api完美了解决这个问题。 可以实现代码自动分割，pinia也同样继承了这个优点。</li>\n</ol>\n<h2 id=\"二：Pinia开发环境安装\"><a href=\"#二：Pinia开发环境安装\" class=\"headerlink\" title=\"二：Pinia开发环境安装\"></a>二：Pinia开发环境安装</h2><h4 id=\"1-使用Vite就需要先初始化vite：\"><a href=\"#1-使用Vite就需要先初始化vite：\" class=\"headerlink\" title=\"1.使用Vite就需要先初始化vite：\"></a>1.使用Vite就需要先初始化vite：</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm init vite@latest\n</code></pre>\n\n<h4 id=\"2-启动项目：\"><a href=\"#2-启动项目：\" class=\"headerlink\" title=\"2.启动项目：\"></a>2.启动项目：</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install\nnpm run dev\n</code></pre>\n\n<h4 id=\"3-pinia的安装：\"><a href=\"#3-pinia的安装：\" class=\"headerlink\" title=\"3.pinia的安装：\"></a>3.pinia的安装：</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install pinia\n</code></pre>\n\n<h2 id=\"三：用Pinia的方式创建一个store\"><a href=\"#三：用Pinia的方式创建一个store\" class=\"headerlink\" title=\"三：用Pinia的方式创建一个store\"></a>三：用Pinia的方式创建一个store</h2><h4 id=\"1-在main-ts文件里引入Pinia\"><a href=\"#1-在main-ts文件里引入Pinia\" class=\"headerlink\" title=\"1.在main.ts文件里引入Pinia\"></a>1.在main.ts文件里引入Pinia</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; createPinia &#125; from &#39;pinia&#39;\n\napp.use(createPinia())</code></pre>\n\n<h4 id=\"2-创建pinia\"><a href=\"#2-创建pinia\" class=\"headerlink\" title=\"2.创建pinia\"></a><strong>2.创建pinia</strong></h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">import &#123;defineStore&#125; from &#39;pinia&#39;\nconst useAgeStore &#x3D; defineStore(&#39;use&#39;, &#123;\n    state:()&#x3D;&gt;&#123;&#x2F;&#x2F;state 相当于 data 存储变量\n        return &#123;&#125;\n    &#125;,\n    getters: &#123;&#x2F;&#x2F;getters 相当于计算属性 computed\n        getAge: (state) &#x3D;&gt; &#123;\n            return state.age\n        &#125;\n    &#125;,\n    actions: &#123;&#x2F;&#x2F;actions 相当于 methods\n        setAge(age) &#123;\n            this.age &#x3D; age\n        &#125;\n    &#125;\n&#125;) </code></pre>\n\n\n\n<h4 id=\"2-创建store\"><a href=\"#2-创建store\" class=\"headerlink\" title=\"2.创建store\"></a>2.创建store</h4><p>**<u>*store实例相当于一个容器，里面存放的有类似于data，计算属性，方法之类的东西</u>***。通过defineStore()方法定义</p>\n<p>在src下面创建一个store文件夹，再创建与之对应的js文件，比如user.js</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; defineStore &#125; from &#39;pinia&#39;\n​\n&#x2F;&#x2F; useStore 可以是 useUser、useCart 之类的任何东西\n&#x2F;&#x2F; 第一个参数是应用程序中 store 的唯一 id\nexport const useUser &#x3D; defineStore(&#39;user&#39;, &#123;\n  &#x2F;&#x2F; other options...\n&#125;)</code></pre>\n\n<p>3.使用store</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script setup&gt;\nimport &#123; useUser &#125; from &#39;@&#x2F;store&#x2F;user.js&#39;\nconst store &#x3D; useUser()\nconsole.log(store)\n&lt;&#x2F;script&gt;</code></pre>\n\n<p> 4.添加state </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import &#123; defineStore &#125; from &#39;pinia&#39;\n​\n&#x2F;&#x2F; 第一个参数是应用程序中 store 的唯一 id\n&#x2F;&#x2F; 第二个参数是配置对象\nexport const useUser &#x3D; defineStore(&#39;user&#39;, &#123;\n  &#x2F;&#x2F; state是一个函数，返回一个对象\n  state: () &#x3D;&gt; &#123;\n    return &#123;\n      userName: &#39;jack&#39;,\n      avatar: &#39;https:&#x2F;&#x2F;cloudflare-ipfs.com&#x2F;ipfs&#x2F;Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye&#x2F;avatar&#x2F;363.jpg&#39;\n    &#125;\n  &#125;\n&#125;)</code></pre>\n\n<h2 id=\"1-state\"><a href=\"#1-state\" class=\"headerlink\" title=\"1.state\"></a>1.state</h2><p>1.读取state</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; storeToRefs &#125; from &#39;pinia&#39;\nconst userStore &#x3D; useUser()\n&#x2F;&#x2F; 如果直接解构出数据，这个数据不是响应式的。如果想要变成响应式的，需要调用storeToRefs方法\nconst &#123; userName, avatar &#125; &#x3D; storeToRefs(userStore)</code></pre>\n\n<h4 id=\"1-修改state\"><a href=\"#1-修改state\" class=\"headerlink\" title=\"1.修改state\"></a>1.修改state</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">userStore.userName &#x3D; &#39;张三&#39;</code></pre>\n\n<h4 id=\"2-批量修改state\"><a href=\"#2-批量修改state\" class=\"headerlink\" title=\"2.批量修改state\"></a>2.批量修改state</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 可以用来修改单个属性\nuserStore.$patch(&#123;\n  userName: &#39;张三&#39;\n&#125;)\n    \n&#x2F;&#x2F; 这种回调函数的形式适合修改集合类的数据，比如数组\nuserStore.$patch((state) &#x3D;&gt; &#123;\n  state.avatar &#x3D; &#39;https:&#x2F;&#x2F;cloudflare-ipfs.com&#x2F;ipfs&#x2F;Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye&#x2F;avatar&#x2F;596.jpg&#39;\n&#125;)</code></pre>\n\n<h4 id=\"3-重置state\"><a href=\"#3-重置state\" class=\"headerlink\" title=\"3.重置state\"></a>3.重置state</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 重置\n  userStore.$reset()</code></pre>\n\n<h4 id=\"4-直接替换整个state\"><a href=\"#4-直接替换整个state\" class=\"headerlink\" title=\"4.直接替换整个state\"></a>4.直接替换整个state</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 替换\nuserStore.$state &#x3D; &#123; userName: &#39;rose&#39;, avatar: &#39;https:&#x2F;&#x2F;cloudflare-ipfs.com&#x2F;ipfs&#x2F;Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye&#x2F;avatar&#x2F;854.jpg&#39; &#125;</code></pre>\n\n\n\n<h2 id=\"2-getters\"><a href=\"#2-getters\" class=\"headerlink\" title=\"2.getters\"></a>2.getters</h2><h4 id=\"1-基础使用\"><a href=\"#1-基础使用\" class=\"headerlink\" title=\"1.基础使用\"></a>1.基础使用</h4><p>类似计算属性。推荐里面传递一个形参的写法，不容易出错。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">getters: &#123;\n  isAdult: (state) &#x3D;&gt; &#123;\n    return state.age &gt;&#x3D; 18 ? &#39;成年人&#39; : &#39;未成年&#39;\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"2-获取\"><a href=\"#2-获取\" class=\"headerlink\" title=\"2.获取\"></a>2.获取</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 直接获取\n&lt;div&gt;&#123;&#123;userStore.isAdult&#125;&#125;&lt;&#x2F;div&gt;</code></pre>\n\n<h4 id=\"3-调用本模块其他getters\"><a href=\"#3-调用本模块其他getters\" class=\"headerlink\" title=\"3. 调用本模块其他getters\"></a>3. 调用本模块其他getters</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">getters: &#123;\n  isAdult: (state) &#x3D;&gt; &#123;\n    return state.age &gt;&#x3D; 18 ? &#39;成年人&#39; : &#39;未成年&#39;\n  &#125;,\n  msg: (state) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; msg这个getter访问了自身的getter（isAdult）\n    return state.userName + state.isAdult\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"4-getters传参\"><a href=\"#4-getters传参\" class=\"headerlink\" title=\"4.getters传参\"></a>4.getters传参</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">getters: &#123;\n  isAdmin: (state) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果getter里面是返回的函数，那么它就可以传参数了\n    return (name) &#x3D;&gt; name &#x3D;&#x3D;&#x3D; &#39;admin&#39; ? &#39;是管理员&#39; : &#39;不是管理员&#39;\n  &#125;\n&#125;</code></pre>\n\n<p> 调用： </p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&#123;&#123;userStore.isAdmin&#125;&#125;</code></pre>\n\n<h2 id=\"3-actions\"><a href=\"#3-actions\" class=\"headerlink\" title=\"3.actions\"></a>3.actions</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">actions: &#123;\n  &#x2F;&#x2F; 这里的方法要写成普通函数，因为里面需要通过this去访问state里面的数据\n  changeNameAsync (newName) &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F; actions里面可以访问state\n      this.userName &#x3D; newName\n    &#125;, 1000)\n  &#125;\n&#125;</code></pre>\n\n<p>详情可见官方文档 :  <a href=\"https://pinia.vuejs.org/\">https://pinia.vuejs.org</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一：Pinia简介和五大优势\"><a href=\"#一：Pinia简介和五大优势\" class=\"headerlink\" title=\"一：Pinia简介和五大优势\"></a>一：Pinia简介和五大优势</h2><p>Pinia是vue生态里Vuex的替代者，一个全新的vue状态管理库。在Vue3成为正式版以后，尤雨溪强势推荐的项目就是Pinia。<br>那先来看看Pinia比Vuex好的地方，也就是Pinia的五大优势。</p>\n<ol>\n<li>可以对Vue2和Vue3做到很好的支持，也就是老项目也可以使用Pinia。</li>\n<li>抛弃了Mutations的操作，只有state、getters和actions.极大的简化了状态管理库的使用，让代码编写更加容易直观。</li>\n<li>不需要嵌套模块，符合Vue3的Composition api ，让代码更加扁平化。</li>\n<li>完整的TypeScript支持。Vue3版本的一大优势就是对TypeScript的支持，所以Pinia也做到了完整的支持。如果你对Vuex很熟悉的化，一定知道Vuex对TS的语法支持不是完整的（经常被吐槽）。</li>\n<li>代码更加简洁，可以实现很好的代码自动分割。Vue2的时代，写代码需要来回翻滚屏幕屏幕找变量，非常的麻烦，Vue3的Composition api完美了解决这个问题。 可以实现代码自动分割，pinia也同样继承了这个优点。</li>\n</ol>\n<h2 id=\"二：Pinia开发环境安装\"><a href=\"#二：Pinia开发环境安装\" class=\"headerlink\" title=\"二：Pinia开发环境安装\"></a>二：Pinia开发环境安装</h2><h4 id=\"1-使用Vite就需要先初始化vite：\"><a href=\"#1-使用Vite就需要先初始化vite：\" class=\"headerlink\" title=\"1.使用Vite就需要先初始化vite：\"></a>1.使用Vite就需要先初始化vite：</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm init vite@latest\n</code></pre>\n\n<h4 id=\"2-启动项目：\"><a href=\"#2-启动项目：\" class=\"headerlink\" title=\"2.启动项目：\"></a>2.启动项目：</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install\nnpm run dev\n</code></pre>\n\n<h4 id=\"3-pinia的安装：\"><a href=\"#3-pinia的安装：\" class=\"headerlink\" title=\"3.pinia的安装：\"></a>3.pinia的安装：</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install pinia\n</code></pre>\n\n<h2 id=\"三：用Pinia的方式创建一个store\"><a href=\"#三：用Pinia的方式创建一个store\" class=\"headerlink\" title=\"三：用Pinia的方式创建一个store\"></a>三：用Pinia的方式创建一个store</h2><h4 id=\"1-在main-ts文件里引入Pinia\"><a href=\"#1-在main-ts文件里引入Pinia\" class=\"headerlink\" title=\"1.在main.ts文件里引入Pinia\"></a>1.在main.ts文件里引入Pinia</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; createPinia &#125; from &#39;pinia&#39;\n\napp.use(createPinia())</code></pre>\n\n<h4 id=\"2-创建pinia\"><a href=\"#2-创建pinia\" class=\"headerlink\" title=\"2.创建pinia\"></a><strong>2.创建pinia</strong></h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">import &#123;defineStore&#125; from &#39;pinia&#39;\nconst useAgeStore &#x3D; defineStore(&#39;use&#39;, &#123;\n    state:()&#x3D;&gt;&#123;&#x2F;&#x2F;state 相当于 data 存储变量\n        return &#123;&#125;\n    &#125;,\n    getters: &#123;&#x2F;&#x2F;getters 相当于计算属性 computed\n        getAge: (state) &#x3D;&gt; &#123;\n            return state.age\n        &#125;\n    &#125;,\n    actions: &#123;&#x2F;&#x2F;actions 相当于 methods\n        setAge(age) &#123;\n            this.age &#x3D; age\n        &#125;\n    &#125;\n&#125;) </code></pre>\n\n\n\n<h4 id=\"2-创建store\"><a href=\"#2-创建store\" class=\"headerlink\" title=\"2.创建store\"></a>2.创建store</h4><p>**<u>*store实例相当于一个容器，里面存放的有类似于data，计算属性，方法之类的东西</u>***。通过defineStore()方法定义</p>\n<p>在src下面创建一个store文件夹，再创建与之对应的js文件，比如user.js</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; defineStore &#125; from &#39;pinia&#39;\n​\n&#x2F;&#x2F; useStore 可以是 useUser、useCart 之类的任何东西\n&#x2F;&#x2F; 第一个参数是应用程序中 store 的唯一 id\nexport const useUser &#x3D; defineStore(&#39;user&#39;, &#123;\n  &#x2F;&#x2F; other options...\n&#125;)</code></pre>\n\n<p>3.使用store</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script setup&gt;\nimport &#123; useUser &#125; from &#39;@&#x2F;store&#x2F;user.js&#39;\nconst store &#x3D; useUser()\nconsole.log(store)\n&lt;&#x2F;script&gt;</code></pre>\n\n<p> 4.添加state </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import &#123; defineStore &#125; from &#39;pinia&#39;\n​\n&#x2F;&#x2F; 第一个参数是应用程序中 store 的唯一 id\n&#x2F;&#x2F; 第二个参数是配置对象\nexport const useUser &#x3D; defineStore(&#39;user&#39;, &#123;\n  &#x2F;&#x2F; state是一个函数，返回一个对象\n  state: () &#x3D;&gt; &#123;\n    return &#123;\n      userName: &#39;jack&#39;,\n      avatar: &#39;https:&#x2F;&#x2F;cloudflare-ipfs.com&#x2F;ipfs&#x2F;Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye&#x2F;avatar&#x2F;363.jpg&#39;\n    &#125;\n  &#125;\n&#125;)</code></pre>\n\n<h2 id=\"1-state\"><a href=\"#1-state\" class=\"headerlink\" title=\"1.state\"></a>1.state</h2><p>1.读取state</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; storeToRefs &#125; from &#39;pinia&#39;\nconst userStore &#x3D; useUser()\n&#x2F;&#x2F; 如果直接解构出数据，这个数据不是响应式的。如果想要变成响应式的，需要调用storeToRefs方法\nconst &#123; userName, avatar &#125; &#x3D; storeToRefs(userStore)</code></pre>\n\n<h4 id=\"1-修改state\"><a href=\"#1-修改state\" class=\"headerlink\" title=\"1.修改state\"></a>1.修改state</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">userStore.userName &#x3D; &#39;张三&#39;</code></pre>\n\n<h4 id=\"2-批量修改state\"><a href=\"#2-批量修改state\" class=\"headerlink\" title=\"2.批量修改state\"></a>2.批量修改state</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 可以用来修改单个属性\nuserStore.$patch(&#123;\n  userName: &#39;张三&#39;\n&#125;)\n    \n&#x2F;&#x2F; 这种回调函数的形式适合修改集合类的数据，比如数组\nuserStore.$patch((state) &#x3D;&gt; &#123;\n  state.avatar &#x3D; &#39;https:&#x2F;&#x2F;cloudflare-ipfs.com&#x2F;ipfs&#x2F;Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye&#x2F;avatar&#x2F;596.jpg&#39;\n&#125;)</code></pre>\n\n<h4 id=\"3-重置state\"><a href=\"#3-重置state\" class=\"headerlink\" title=\"3.重置state\"></a>3.重置state</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 重置\n  userStore.$reset()</code></pre>\n\n<h4 id=\"4-直接替换整个state\"><a href=\"#4-直接替换整个state\" class=\"headerlink\" title=\"4.直接替换整个state\"></a>4.直接替换整个state</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 替换\nuserStore.$state &#x3D; &#123; userName: &#39;rose&#39;, avatar: &#39;https:&#x2F;&#x2F;cloudflare-ipfs.com&#x2F;ipfs&#x2F;Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye&#x2F;avatar&#x2F;854.jpg&#39; &#125;</code></pre>\n\n\n\n<h2 id=\"2-getters\"><a href=\"#2-getters\" class=\"headerlink\" title=\"2.getters\"></a>2.getters</h2><h4 id=\"1-基础使用\"><a href=\"#1-基础使用\" class=\"headerlink\" title=\"1.基础使用\"></a>1.基础使用</h4><p>类似计算属性。推荐里面传递一个形参的写法，不容易出错。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">getters: &#123;\n  isAdult: (state) &#x3D;&gt; &#123;\n    return state.age &gt;&#x3D; 18 ? &#39;成年人&#39; : &#39;未成年&#39;\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"2-获取\"><a href=\"#2-获取\" class=\"headerlink\" title=\"2.获取\"></a>2.获取</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 直接获取\n&lt;div&gt;&#123;&#123;userStore.isAdult&#125;&#125;&lt;&#x2F;div&gt;</code></pre>\n\n<h4 id=\"3-调用本模块其他getters\"><a href=\"#3-调用本模块其他getters\" class=\"headerlink\" title=\"3. 调用本模块其他getters\"></a>3. 调用本模块其他getters</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">getters: &#123;\n  isAdult: (state) &#x3D;&gt; &#123;\n    return state.age &gt;&#x3D; 18 ? &#39;成年人&#39; : &#39;未成年&#39;\n  &#125;,\n  msg: (state) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; msg这个getter访问了自身的getter（isAdult）\n    return state.userName + state.isAdult\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"4-getters传参\"><a href=\"#4-getters传参\" class=\"headerlink\" title=\"4.getters传参\"></a>4.getters传参</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">getters: &#123;\n  isAdmin: (state) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果getter里面是返回的函数，那么它就可以传参数了\n    return (name) &#x3D;&gt; name &#x3D;&#x3D;&#x3D; &#39;admin&#39; ? &#39;是管理员&#39; : &#39;不是管理员&#39;\n  &#125;\n&#125;</code></pre>\n\n<p> 调用： </p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&#123;&#123;userStore.isAdmin&#125;&#125;</code></pre>\n\n<h2 id=\"3-actions\"><a href=\"#3-actions\" class=\"headerlink\" title=\"3.actions\"></a>3.actions</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">actions: &#123;\n  &#x2F;&#x2F; 这里的方法要写成普通函数，因为里面需要通过this去访问state里面的数据\n  changeNameAsync (newName) &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F; actions里面可以访问state\n      this.userName &#x3D; newName\n    &#125;, 1000)\n  &#125;\n&#125;</code></pre>\n\n<p>详情可见官方文档 :  <a href=\"https://pinia.vuejs.org/\">https://pinia.vuejs.org</a></p>\n"},{"title":"代码工具","author":{"name":"好名字都是狗起的","link":"https://hexo-git-test-3309446352s-projects.vercel.app/","avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg","description":"古来圣贤皆寂寞，惟有饮者留其名。","socials":{"github":"https://github.com/3309446352"}},"date":"2024-03-22T13:39:54.000Z","cover":null,"description":null,"abstracts":null,"_content":"# {{ title }}\n\n## Smart Input插件\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n\t<form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\">\n        <iframe style=\"height: 500px;width: 100%;\" src=\"//player.bilibili.com/player.html?aid=619010134&bvid=BV1Y84y1U7Jo&cid=1282400439&p=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n    </form>\n</div>\n\n## Git History插件","source":"_posts/代码工具.md","raw":"---\ntitle: 代码工具\nauthor:\n  name: 好名字都是狗起的\n  link: https://hexo-git-test-3309446352s-projects.vercel.app/\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\n  description: 古来圣贤皆寂寞，惟有饮者留其名。\n  socials:\n    github: https://github.com/3309446352\ndate: 2024-03-22 21:39:54\ntags:\n  - 工具\n  - 插件\ncategories: [\"工具\"]\ncover:\ndescription:\nabstracts:\n---\n# {{ title }}\n\n## Smart Input插件\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n\t<form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\">\n        <iframe style=\"height: 500px;width: 100%;\" src=\"//player.bilibili.com/player.html?aid=619010134&bvid=BV1Y84y1U7Jo&cid=1282400439&p=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n    </form>\n</div>\n\n## Git History插件","slug":"代码工具","published":1,"updated":"2024-03-24T16:58:28.445Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgy6001qiou2ehp3d5uv","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>代码工具</h1><h2 id=\"Smart-Input插件\"><a href=\"#Smart-Input插件\" class=\"headerlink\" title=\"Smart Input插件\"></a>Smart Input插件</h2><div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n    <form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\">\n        <iframe style=\"height: 500px;width: 100%;\" src=\"//player.bilibili.com/player.html?aid=619010134&bvid=BV1Y84y1U7Jo&cid=1282400439&p=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n    </form>\n</div>\n\n<h2 id=\"Git-History插件\"><a href=\"#Git-History插件\" class=\"headerlink\" title=\"Git History插件\"></a>Git History插件</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>代码工具</h1><h2 id=\"Smart-Input插件\"><a href=\"#Smart-Input插件\" class=\"headerlink\" title=\"Smart Input插件\"></a>Smart Input插件</h2><div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n    <form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\">\n        <iframe style=\"height: 500px;width: 100%;\" src=\"//player.bilibili.com/player.html?aid=619010134&bvid=BV1Y84y1U7Jo&cid=1282400439&p=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n    </form>\n</div>\n\n<h2 id=\"Git-History插件\"><a href=\"#Git-History插件\" class=\"headerlink\" title=\"Git History插件\"></a>Git History插件</h2>"},{"title":"SpringBoot 使用详解","date":"2024-03-18T14:12:42.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-03-19_17-56-24.png","_content":"# SpringBoot 使用详解","source":"_posts/springboot.md","raw":"---\ntitle: SpringBoot 使用详解\ndate: 2024-03-18 22:12:42\ntags: Spingboot\ncategories: 后端\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/Snipaste_2023-03-19_17-56-24.png\n---\n# SpringBoot 使用详解","slug":"springboot","published":1,"updated":"2024-03-20T06:25:51.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgy7001tiou243w7egnw","content":"<h1 id=\"SpringBoot-使用详解\"><a href=\"#SpringBoot-使用详解\" class=\"headerlink\" title=\"SpringBoot 使用详解\"></a>SpringBoot 使用详解</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SpringBoot-使用详解\"><a href=\"#SpringBoot-使用详解\" class=\"headerlink\" title=\"SpringBoot 使用详解\"></a>SpringBoot 使用详解</h1>"},{"title":"少年锦衣卫","date":"2024-03-21T14:17:41.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/少年锦衣卫.jpg","author":{"name":"ZMC","link":"https://tridiamond.tech","avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/illust_77229305_20210626_204628.png","description":"Think like an artist, code like an artisan.","socials":{"github":"https://github.com/tridiamond"}},"_content":"# 少年锦衣卫 似水流年▪落英\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=830 height=86 src=\"//music.163.com/outchain/player?type=2&id=464055137&auto=1&height=66\"></iframe>\n\n# 晚夜微雨问海棠-镜予歌 / 陈亦洺 / 喧笑\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=830 height=86 src=\"//music.163.com/outchain/player?type=2&id=1456673752&auto=1&height=66\"></iframe>","source":"_posts/少年锦衣卫.md","raw":"---\ntitle: 少年锦衣卫\ndate: 2024-03-21 22:17:41\ntags:\n - 动漫\n - 音乐\ncategories:\n - 动漫\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/少年锦衣卫.jpg\nauthor:\n  name: ZMC # 作者名字\n  link: https://tridiamond.tech #链接\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/illust_77229305_20210626_204628.png\n  description: 'Think like an artist, code like an artisan.' #简介\n  socials:\n    github: https://github.com/tridiamond #联系方式\n---\n# 少年锦衣卫 似水流年▪落英\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=830 height=86 src=\"//music.163.com/outchain/player?type=2&id=464055137&auto=1&height=66\"></iframe>\n\n# 晚夜微雨问海棠-镜予歌 / 陈亦洺 / 喧笑\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=830 height=86 src=\"//music.163.com/outchain/player?type=2&id=1456673752&auto=1&height=66\"></iframe>","slug":"少年锦衣卫","published":1,"updated":"2024-03-21T14:38:49.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgy8001viou20ayub59i","content":"<h1 id=\"少年锦衣卫-似水流年▪落英\"><a href=\"#少年锦衣卫-似水流年▪落英\" class=\"headerlink\" title=\"少年锦衣卫 似水流年▪落英\"></a>少年锦衣卫 似水流年▪落英</h1><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=830 height=86 src=\"//music.163.com/outchain/player?type=2&id=464055137&auto=1&height=66\"></iframe>\n\n<h1 id=\"晚夜微雨问海棠-镜予歌-陈亦洺-喧笑\"><a href=\"#晚夜微雨问海棠-镜予歌-陈亦洺-喧笑\" class=\"headerlink\" title=\"晚夜微雨问海棠-镜予歌 &#x2F; 陈亦洺 &#x2F; 喧笑\"></a>晚夜微雨问海棠-镜予歌 &#x2F; 陈亦洺 &#x2F; 喧笑</h1><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=830 height=86 src=\"//music.163.com/outchain/player?type=2&id=1456673752&auto=1&height=66\"></iframe>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"少年锦衣卫-似水流年▪落英\"><a href=\"#少年锦衣卫-似水流年▪落英\" class=\"headerlink\" title=\"少年锦衣卫 似水流年▪落英\"></a>少年锦衣卫 似水流年▪落英</h1><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=830 height=86 src=\"//music.163.com/outchain/player?type=2&id=464055137&auto=1&height=66\"></iframe>\n\n<h1 id=\"晚夜微雨问海棠-镜予歌-陈亦洺-喧笑\"><a href=\"#晚夜微雨问海棠-镜予歌-陈亦洺-喧笑\" class=\"headerlink\" title=\"晚夜微雨问海棠-镜予歌 &#x2F; 陈亦洺 &#x2F; 喧笑\"></a>晚夜微雨问海棠-镜予歌 &#x2F; 陈亦洺 &#x2F; 喧笑</h1><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=830 height=86 src=\"//music.163.com/outchain/player?type=2&id=1456673752&auto=1&height=66\"></iframe>"},{"title":"HTML八股文","date":"2024-03-18T09:27:43.000Z","CATEGORYS":"前端","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/屏幕截图(1).png","feature":true,"_content":"# 1、HTML\n\n![1709997145390](https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg)\n\n## 1.你对 HTML 语义化的理解？★★★★★\n\n1. html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、[搜索引擎](https://so.csdn.net/so/search?q=搜索引擎&spm=1001.2101.3001.7020)解析；即使在没有样式 CSS 情况下也以    一种文档格式显示，并且是容易阅读的;\n2. 搜索引擎的[爬虫](https://so.csdn.net/so/search?q=爬虫&spm=1001.2101.3001.7020)也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;\n\n## 2、 title 与 alt 属性的区别是什么？\n\n1. alt 是给搜索引擎识别，在图像无法显示时的替代文本；\n2. title 是关于元素的注释信息，主要是给用户解读。\n3. 当鼠标放到文字或是图片上时有 title 文字显示。（因为 IE 不标准）在 IE 浏览器中 alt 起到了 title 的作用，变成文字提示。\n\n## 3、href 与 src？\n\n> href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。（目的不是为了引用资源，而是为了建立联系，让当前标签能够链接到目标地址。）\n> src source（缩写），指向外部资源的位置，指向的内容将会应用到文档中当前标签所在位置。\n> href与src的区别\n> 1、请求资源类型不同：href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；\n> 2、作用结果不同：href 用于在当前文档和引用资源之间确立联系；src 用于替换当前内容；\n> 3、浏览器解析方式不同：当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。\n\nsrc和href都是对外部资源的引用，区别如下：\n\nsrc: 表示对资源的引用，用在js脚本、img、frame等元素上，当浏览器解析到该元素时，会**暂停**其他资源的下载和处理，直到该资源加载、编译、执行完成，所以js脚本会放在页面的底部，而不是头部。\n\nhref：表示超文本引用，指向一些网络资源，当浏览器识别它指向的文件时，就会**并行**下载资源，不会停止对当前文件的处理，用在a、link上\n\n## 4、HTML5、CSS3 里面都新增了那些新特性？\n\nHTML5\n\n- [ ]  新的语义标签\n  article 独立的内容。\n  aside 侧边栏。\n  header 头部。\n  nav 导航。\n  section 文档中的节。\n  footer 页脚。\n  画布(Canvas) API\n  地理(Geolocation) API\n  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；\n  sessionStorage 的数据在浏览器关闭后自动删除\n  新的技术webworker, websocket, Geolocation\n  拖拽释放(Drag and drop) API\n  音频、视频API(audio,video)\n  表单控件，calendar、date、time、email、url、searc\n  CSS3\n\n- 2d，3d变换\n  Transition, animation\n  媒体查询\n  新的单位（rem, vw，vh 等）\n  圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜\n  rgba\n\n## 5、行内元素与块级元素\n\n### 块级元素： 独占一行，可以设置宽高，设置margin和padding都有效，代表如下：\n\ndiv、p、h1…h6、table、tr、ol、li、ul\n\n### 行内元素元素： 可以排成一行，设置宽高无效，对margin设置左右方向有效，而上下无效，padding设置都无效，代表如下：\n\n基本上都是文本标签\n\nspan、img、b、strong、font、br、a\n\n## 什么是BFC?\n\nBFC全称是Block Formatting Context，意思就是块级格式化上下文。你可以把BFC看做一个容器，容器里边的元素不会影响到容器外部的元素。\n\nBFC有什么特性？\nBFC是一个块级元素，块级元素在垂直方向上依次排列。\n\nBFC是一个独立的容器，内部元素不会影响容器外部的元素。\n\n属于同一个BFC的两个盒子，外边距margin会发生重叠，并且取最大外边距。\n\n[[面试官：什么是BFC？BFC有什么特性？如何创建BFC？BFC有什么作用？-CSDN博客](https://blog.csdn.net/guoao20000915/article/details/125685983?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170929193616777224499886%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170929193616777224499886&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125685983-null-null.142^v99^pc_search_result_base2&utm_term=bfc&spm=1018.2226.3001.4187)](https://)\n\n解决当父级元素没有高度时，子级元素浮动会使父级元素高度塌陷的问题\n\n解决子级元素外边距会使父级元素塌陷的问题\n\n# 2、CSS\n\n## 1、介绍一下 CSS 的盒子模型？★★★★★\n\n有两种， IE 盒子模型、W3C 盒子模型；\n盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n区 别： IE 的 content 部分把 border 和 padding 计算了进去;\n\n## 2、css 选择器优先级？★★★★★\n\n!important > 行内样式（比重1000）> ID 选择器（比重100） > 类选择器（比重10） > 标签（比重1） > 通配符 > 继承 > 浏览器默认属性\n\n## 3、垂直居中几种方式？★★★★★\n\n单行文本: line-height = height\n图片: vertical-align: middle;\nabsolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);\nflex: display:flex;margin\n\n- 1 使用flex布局\n  利用flex的alignItems:center垂直居中，justifycontent:center水平居中\n- 2 利用相对定位和绝对定位的margin:auto\n- 相对定位下，使用绝对定位将上下左右都设置为0，再设置margin:auto即可实现居中\n- 3 利用相对定位和绝对定位，再加上外边距和平移的配合\n  相对定位下，使用绝对定位，利用margin偏移外容器的50%，再利用translate平移回补自身宽高的50%即可\n- 4 利用textAlign和verticalAlign\n  利用textAlign:center实现行内元素的水平居中，再利用verticalAlign:middle实现行内元素的垂直居中，前提是要先加上伪元素并给设置高度为100%，用过elementUI的可以去看看其消息弹窗居中实现方式就是如此\n\n**四种方式：**\n\n**利用绝对定位**，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。\n\n```css\n.div {\n        position: absolute;\n        width: 200px;height: 200px;\n         left: 50%;top: 50%;\n        transform: translate(-50%, -50%);\n        或//margin-left:-50px;margin-top:-50px;\n      }\n```\n\n**利用绝对定位**，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于盒子有宽高的情况。\n\n```css\n.div {\n        position: relative;\n        width: 200px;height: 200px;\n        left: 50%; top: 50%;\n       transfrom:trable(-50%,-50%)\n      }\n```\n\n使用**flex布局****，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。\n\n```\n.div {\n       // width: 100%; //height: 100%;\n        display: flex;\n        justify-content: center;\n        align-items:center;\n      }\n```\n\n## 4.flex布局的父级元素中有哪些常用属性。\n\n答：\n\nflex-direction: 设置主轴的方向\n\njustify-content: 设置主轴上的子元素对齐方式\n\nflex-wrap: 设置子元素是否换行\n\nalign-content: 设置侧轴上的子元素的排列方式(多行)\n\nalign-items:  设置侧轴上的子元素排列方式 (单行)\n\nflex-flow: 复合属性, 相当于同时设置了 flex-direction 和 flex-wrap\n\n## 5、var、let、const 区别？★★★★★\n\nvar 存在变量提升。\nlet 只能在块级作用域内访问。\nconst 用来定义常量，必须初始化，不能修改（对象特殊）\n\nvar 全局作用域 变量更新 重新声明 可以变量提升(**将var变量放到第一行**)\n\nlet 块作用域  变量更新 不能重新声明\n\nconst 块作用域  不能变量更新 不能重新声明\n\nvar 初始化为undefined\n\n## 6、1rem、1em、1vh、1px各自代表的含义？\n\nrem\nrem是全部的长度都相对于根元素元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。\nem\n子元素字体大小的em是相对于父元素字体大小\n元素的width/height/padding/margin用em的话是相对于该元素的font-size\nvw/vh\n全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。\npx\npx像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。\n一般电脑的分辨率有{19201024}等不同的分辨率\n19201024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素\n\n## 7、怎么解决浮动中塌陷的问题\n\n### 第一种：开启BFC\n\n根据W3C的标准，在页面中元素都有一个隐含的属性 Block Formatting Context,简称BFC，默认是关闭的；\n\n开启元素BFC后，元素将会具有以下特性：\n\n父元素的垂直外边距不会和子元素重叠\n开启BFC的元素不会被浮动元素所覆盖\n开启BFC的元素可以包含浮动元素\n开启BFC的方法：。\n\n** overflow【常见，副作用最小】**\n\noverflow设置为非visible的值。推荐使用hidden（副作用最小）\n\na) auto （溢出显示滚动条）\n\nb) scroll （默认就显示滚动条）\n\nc) hidden （溢出隐藏）[常用]\n\n注：但在IE6及以下的浏览器中不支持BFC，所以使用这种方式不兼容IE6。在IE6中有类似BFC的隐含属性 hasLayout，开启方式很多，推荐使用zoom:1\n\n### 第二种：在浮动元素后添加元素，并设置其clear属性\n\n### 第三种：br元素的clear属性\n\nbr元素本身没有高度，所以也就不会存在IE低版本下最小高度问题。只需要在浮动元素下添加一句 :\n\n※第四种：after伪类【各大公司推荐】\n\n可以通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动，和第二种方法原理相同，可达到相同的效果，而且不会在页面中添加多余的div，这是最推荐的方式，几乎没有副作用\n\n## 8、display:none和visibility:hidden的区别？\n\ndisplay:none：     隐藏元素,不占空间 继承属性\n\nvisibility:hidden：隐藏元素,不占空间 继承属性\n\n> display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。\n> visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。\n\n## 9、position的值， relative和absolute分别是相对于谁进行定位的？\n\nrelative:相对定位，相对于自己本身在正常文档流中的位置进行定位。\nabsolute:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。\nfixed: （老版本IE不支持）生成绝对定位，相对于浏览器窗口或者frame进行定位。\nstatic:默认值，没有定位，元素出现在正常的文档流中。\nsticky:生成粘性定位的元素，容器的位置根据正常文档流计算得出。\n\n10、\n\n## 10、画一条0.5px的直线？\n\n> 考查的是css3的transform\n\n```\nheight: 1px;\ntransform: scale(0.5);\n```\n\n## 11、BFC 是什么？\n\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n只要元素满足下面任一条件即可触发 BFC 特性\n\nbody 根元素\n浮动元素：float 除 none 以外的值\n绝对定位元素：position (absolute、fixed)\ndisplay 为 inline-block、table-cells、flex\noverflow 除了 visible 以外的值 (hidden、auto、scroll)\n\n## 8、前端常见的布局方式\n\n### 一、静态布局\n\n静态布局是最为原始的布局方式，没有什么技术性可言，往往是计算机行业刚刚入门的小白使用的布局方式。制作的网页上的元素尺寸一律以px为单位\n\n布局特点： 页面上的布局是按最初写代码时候的布局方式进行布局的，常规的pc网站是进行设置了宽度值进行布局的，不会随着pc端的屏幕的大小而变化。\n优点: 这种布局方式不管是对资深的前端开发工程师还是刚入门的小白来说都是最简单的，最让人容易以接受、学习的，没有我们所说的兼容性的问题。这种布局方式大多用在门户网站和企业的官网上，这些官网的设备的尺寸是固定的，这种布局方式往往是最简单的方法。\n缺点： 不会随着pc端的屏幕大小而变化。\n\n### 二、弹性布局（flexbox）\n\n弹性布局可以简便、完整、响应的实现各种页面上的布局。与静态不同的是，使用em或rem单位（lem=16px，1rem=10px）进行相对布局，相对使用百分比更加方便、灵活，相应同时支持浏览器的字体大小调整和缩放的等正常显示。\n优点：\n1.适应性强，在做多种不同的屏幕分辨率不同的界面是非常使用。\n2.随意按照宽度、比例划分元素的宽高。\n3.可以轻松的改变元素的显示顺序。\n4.网页布局实现快捷，维护起来更加容易。\n如果做移动端时，如果客户对细微的之处的要求不高，使用弹性布局进行制作是最好的选择，一份css+一份js调节font-size搞定。\n缺点： 浏览器兼容性较差，只能兼容到IE9及以上。\n\n### 三、自适应布局（bootstrap）\n\n自适应布局分别为不同屏幕不同分辨率定义布局，即是创建多个静态页面，每个静态页面对应一个屏幕分辨率的一个范围内。在改变不同的屏幕分辨率可以切换到不同的静态布局上，但是布局中的元素位置会发生改变，但是在每个静态布局中，页面中的元素不会随着窗口大小的调整发生变化。使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。\n优点：\n1.对网站的复杂程度兼容性更大；\n2.对开发工程师来说制作的成本代价更低；\n3.代码执行效果更高效；\n4.测试时更加容易，运营相对更加精准。\n缺点： 在现如今的移动端设计百花齐放的时期之下，同一个网站往往需要为不同的设备制作不同的页面，不但会增加开发成本，还会因为客户的需求改变时，可能会改动多套代码、流程相比较来说较繁琐。\n\n### 四、流式布局（fluid）\n\n流式布局的布局方式是页面的元素的宽度按照屏幕的分辨率进行适配的调整，但是整体布局不变，也称之为栅栏系统。使用%百分比定义宽度，高度大都是用px来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。\n缺点： 屏幕大小变化时，页面元素也随之变化但是布局不变。这就会因为如果屏幕太大或太小都会布局时元素无法正常显示。\n\n### 五、响应式布局\n\n响应式布局是css3增加的新布局方式，该布局方式2010年提出来的一个概念，说白了就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。响应式几乎成为优秀页面布局的标准。\n设计方法： 媒体查询+流式布局。通常使用@media媒体查询，和网格系统配合相对布局单位进行布局，实际上说白了就是综合响应式等技术通过css给单一网页不同设备分辨率返回不式时的技术。\n优点： 适应pc端和移动端，如果有足够的耐心，页面效果会很完美。\n缺点：\n1.只能适应主流的宽高；\n2.如果匹配足够多的设备屏幕的大小，对于工程师来说工作量不小，设计更需要多个版本，工作量增大。\n\n### 六、浮动布局\n\n浮动布局进行调用浮动属性改变页面中元素的位置，浮动布局应该是目前各大网站用的最多的一种布局方式了，但是也特别复杂。浮动元素是脱离文档流的，但不脱离文本流。浮动元素有左浮动（float : left）和右浮动（float : right）两种\n\n优点： 兼容性比较好\n缺点： 浮动带来的影响比较多，页面宽度不够的时候会影响布局。\n\n### 七、定位布局\n\n定位布局时利用position属性控制页面元素设置一些不规则布局。\n\n# 3、js\n\n\n## 什么是async？\n\nasync 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用 await 来表示异步。相较于 Generator，async 函数的改进在于下面四点：\n\n内置执行器。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，调用方式跟普通函数的调用一样\n更好的语义。async 和 await 相较于 * 和 yield 更加语义化\n更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise对象。而 async 函数的 await 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）\n返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用\n\n\n## await是什么？\n\nawait意思是async wait(异步等待)。这个关键字只能在使用async定义的函数里面使用。任何async函数都会默认返回promise，并且这个promise解析的值都将会是这个函数的返回值，而async函数必须等到内部所有的 await 命令的 Promise 对象执行完，才会发生状态改变。\n\n打个比方，await是学生，async是校车，必须等人齐了再开车。\n\n就是说，必须等所有await 函数执行完毕后，才会告诉promise我成功了还是失败了，执行then或者catch\n\n\n## 19、var,let ,const 三者区别？\n\n共同点：都是可以声明变量\n\n区别1：var具有变量提升的机制，let和const 没有变量提升机制，\n\n区别2：var可以多次声明同一个变量，let和const 不可以多次声明同一个变量，\n\n区别3：var和let声明的是常量，const声明常量，var和let声明的变量可以再一次赋值，而const 不可以再次赋值\n\n面试的时候会问const 一个对象，里面是a:1，我现在想打印console.log(obj.a)这个结果是1，我想改变a:2,打印的就是2因为里面的值不是const,从内存的角度看，一个对象里面修改了对量里面的属性值，那么再次打印会打印出新的值，\n\n什么是常量：常量是一个在程序执行过程中不能被改变或修改的固定值。它是被赋予一个固定值后就不能再改变的变量。理解成，不能被操作所修改的变量就是常量。用途：保护数据，可以提高程序的可读性、可维护性\n\n变量：变量是用于存储和表示数据的一种命名容器。它是程序中的一个基本概念，用于在内存中存储和操作数据。变量的值可以被修改和更新。\n\n区别4：var没有作用域，在ES6之后才出现的作用域块的概念，\n\n### null 和 undefined 区别\n\n首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型\n分别都只有一个值，就是 undefined 和 null。\nundefined 代表的含义是未定义，null 代表的含义是空对象。一般\n变量声明了但还没有定义的时候会返回 undefined，null 主要用于\n赋值给一些可能会返回对象的变量，作为初始化。\n\n### 作用域链\n\n在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个\n变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域\n查找，依次向上级作用域查找，直到访问到 window 对象就被终止，\n这一层层的关系就是作用域链\n\n### **1、深拷贝、浅拷贝（笔试题）★★★★★**\n\n【{},[]】\n\n- 浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个**地址**，修改时原对象也会受到影响\n  - Object.assign\n  - 展开运算符 ...\n- 深拷贝: 完全拷贝一个新**对象**，修改时原对象不再受到任何影响\n\n## 2、作用域、作用域链\n\n作用域：变量和函数起作用的范围。\n\n作用域链：是js查找方式，决定的变量和函数向上查找的范围。\n\n作用域是可访问的变量的\n集合。在JavaScript中，作用域为可访问变量，对象，函数的集合，它分为局部作用域和全局作用域。作用域决定了这些变量的可访问性（可见性）。\n\n作用域链\n\n我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含\n父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。\n\n它由两部分组成:\n[[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO\nAO: 自身活动对象\n如此 [[scope]]包含[[scope]]，便自上而下形成一条 链式作用域。\n\n## 1、闭包★★★★★\n\n### 1、变量作用域\n\n```\n要理解闭包，首先要理解 JavasSript 的特殊的变量作用域。\n```\n\n```\n变量的作用域无非就两种：全局变量和局部变量。\n```\n\n```\nJavasSript 语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局                    部变量。\n```\n\n**注意点：**在函数内部声明变量的时候，一定要使用 var 命令。如果不用的话，你实际上声明的是一个全局变量！\n\n### 2、如何从外部读取函数内部的局部变量？\n\n出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。\n\n那就是在函数内部，再定义一个函数。\n\n```js\nfunction f1(){\n    var n=999;\n    function f2(){\n        alert(n); // 999\n    }\n}\n```\n\n在上面的代码中，函数 f2 就被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。\n\n这就是 JavasSript 语言特有的\"链式作用域\"结构（chain scope）\n\n### 3、闭包的概念\n\n上面代码中的 f2 函数，就是闭包。\n\n各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。\n\n由于在 JavaScript 中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成\"定义在一个函数内部的函数\"。\n\n所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。\n\n闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数\n\n使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。\n\n闭包有三个特性：\n\n1.函数嵌套函数\n\n2.函数内部可以引用外部的参数和变量\n\n3.参数和变量不会被垃圾回收机制回收\n\n### 4、闭包的用途\n\n闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在 f1 调用后被自动清除。\n\n为什么会这样呢？原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。\n\n这段代码中另一个值得注意的地方，就是 “nAdd=function(){n+=1}” 这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量。其次，nAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。\n\n* 使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。\n* 闭包有三个特性：\n* 函数嵌套函数\n* 函数内部可以引用外部的参数和变量\n* 参数和变量不会被垃圾回收机制回收\n\n应用场景：\n\n* 设置私有变量的方法\n* 不适用场景：返回闭包的函数是个非常大的函数\n  闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏\n\n### 5、使用闭包的注意点\n\n（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值\n\n## 2、 原型链★★★★★\n\n那什么是原型链呢？\n\n简单理解就是原型组成的链，对象的__proto__它的是原型，而原型也是一个对象，也有__proto__属性，原型的__proto__又是原型的原型，就这样可以一直通过__proto__想上找，这就是原型链，当向上找找到Object的原型的时候，这条原型链就算到头了。\n\n原型对象和实例之间有什么作用呢？\n\n通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。\n\n在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法。\n\n## 3、 请列举几种隐藏元素的方法\n\nvisibility: hidden;这个属性只是简单的隐藏某个元素，但是元素占用的空间仍然存在\nopacity: 0; CSS3属性，设置0可以使一个元素完全透明，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的\ndisplay: none;元素会变得不可见，并且不会再占用元素位置。会改变页面布局。\ntransform: scale(0);将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留。\n\n## 4、 防抖和节流★★★★★\n\n本质上是优化高频率执行代码的一种手段\n\n如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能\n\n为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（防抖）和debounce（节流）的方式来减少调用频率\n\n定义：\n\n**节流**: **n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效**\n**防抖**: **n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时**\n一个经典的比喻:\n\n想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应\n\n假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制\n\n电梯第一个人进来后，15秒后准时运送一次，这是节流。\n\n电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖。\n\n防抖应用场景\n\n搜索框搜索输入。只需用户最后一次输入完，再发送请求\n手机号、邮箱验证输入检测 onchange / oninput事件\n窗口大小计算。只需窗口调整完成后，计算窗口大小。防止重复渲染。\n节流应用场景\n\n懒加载、滚动加载、加载更多或监听滚动条位置；\n百度搜索框，搜索联想功能；\n防止高频点击提交，防止表单重复提交；\n\n## 5、==和=== 的区别?\n\n==（相等操作符）：比较时会进行类型转换，尝试将两个操作数转换为相同的类型，然后进行值的比较。如果操作数的类型不同，会进行类型转换后再比较。这种比较方式被称为弱类型相等比较。\n\n===（严格相等操作符）：比较时不进行类型转换，仅当两个操作数的类型相同且值相等时，返回true。这种比较方式要求比较的操作数类型和值都要相同。\n\n==，当且仅当两个运算数相等时，它返回 true，即不检查数据类型\n===，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型\n\n## 6、JS 数据类型 ?\n\n数据类型主要包括两部分：\n\n基本数据类型： Undefined、Null、Boolean、Number 和 String\n引用数据类型： Object (包括 Object 、Array 、Function)\nECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )\n\n## 7、null 和 undefined 的区别？\n\nnull 表示一个对象被定义了，值为“空值”；**无对象**\nundefined 表示不存在这个值。**无值**\n（1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。\n\nnull 和 undefined 区别\n\n首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型\n分别都只有一个值，就是 undefined 和 null。\nundefined 代表的含义是未定义，null 代表的含义是空对象。一般\n变量声明了但还没有定义的时候会返回 undefined，null 主要用于\n赋值给一些可能会返回对象的变量，作为初始化。\n\n## 8、★★★★★ promise理解、手写promise\n\nPromise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，避免了地狱回调\nPromise有三种状态： pending(等待态)，fulfilled(成功态)，rejected(失败态) ；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。\nPromise拥有一个then方法，用以处理resolved或rejected状态下的值\nthen方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。\nthen方法返回一个新的Promise对象，因此可以通过链式调用then方法\n\nPromise 是异步编程的一种解决方案，它是一个对象，可以获取异步\n操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，\n它比传统的解决方案回调函数和事件更合理和更强大。\n所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束\n的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一\n个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，\n各种异步操作都可以用同样的方法进行处理。\n（1）Promise 的实例有三个状态:\nPending（进行中）\nResolved（已完成）\nRejected（已拒绝）\n当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了\n状态就变成了 Resolved、没有完成失败了就变成了 Rejected。\n（2）Promise 的实例有两个过程：\npending -> fulfilled : Resolved（已完成）\npending -> rejected：Rejected（已拒绝）\n注意：一旦从进行状态变成为其他状态就永远不能更改状态了。\n\n## 9、async await函数★★★★★\n\nasync/await函数是异步代码的新方式\nasync/await是基于promise实现的\nasync/await使异步代码更像同步代码\nawait 只能在async函数中使用，不能再普通函数中使用，要成对出现\n默认返回一个promise实例，不能被改变\nawait下面的代码是异步，后面的代码是同步的\n\n### 10、异步编程的实现方式？\n\n回调函数\n\n使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。\nPromise\n\n### 使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。\n\nasync 函数\n\nasync 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。\n\n## 箭头函数与普通函数的区别？\n\n### 1、箭头函数比普通函数更加简洁\n\n如果没有参数，就直接写一个空括号即可\n\n如果只有一个参数，可以省去参数的括号\n\n如果有多个参数，用逗号分割\n\n如果函数体的返回值只有一句，可以省略大括号\n\n### 2. 箭头函数没有自己的this\n\n箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。\n\n### 3. 箭头函数继承来的this指向永远不会改变\n\n```js\nvar id = 'GLOBAL';\nvar obj = {\n  id: 'OBJ',\n  a: function(){\n    console.log(this.id);\n  },\n  b: () => {\n    console.log(this.id);\n  }\n};\nobj.a();    // 'OBJ'\nobj.b();    // 'GLOBAL'\nnew obj.a()  // undefined\nnew obj.b()  // Uncaught TypeError: obj.b is not a constructor\n```\n\n对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号**{ }**是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。\n\n### 4. call()、apply()、bind()等方法不能改变箭头函数中this的指向\n\n```js\nvar id = 'Global';\nlet fun1 = () => {\n    console.log(this.id)\n};\nfun1();                     // 'Global'\nfun1.call({id: 'Obj'});     // 'Global'\nfun1.apply({id: 'Obj'});    // 'Global'\nfun1.bind({id: 'Obj'})();   // 'Global'\n```\n\n### 5、箭头函数不能作为构造函数使用\n\n由于箭头函数时没有自己的this，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。\n\n### 6、箭头函数没有自己的arguments\n\n箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。\n\n### 7、箭头函数没有prototype\n\n### 8、箭头函数的this指向哪⾥？★★★★★\n\n箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。\n\n## 10、常见的DOM操作有哪些\n\nCreate：动态增加DOM 节点\n\nDelete：删除DOM 节点\n\nUpdate：更新DOM 节点的内容\n\nRead：获取DOM 节点\n\n1 Document.getElementById()\n\n2 Document.getElementsByTagName()\n\n3 Document.getElementsByClassName()\n\n4 Document.querySelector()\n\n5 Document.querySelectorAll()\n\n6 父节点Node.parentNode\n\n## 11、对this对象的理解\n\n##### this 关键字含义是什么？\n\n解答：this总是返回一个对象，**this就是属性或方法“当前”所在对象。\\**由于对象的属性可以赋值给另一个对象，所以属性所在的当前对象是可变的，即\\**this指向是可变的**。\n\n1.this是js 的一个关键字，随着函数的使用场合的不同，this 的值会发生变化。\n\n2.一个总原则：即this指的是调用函数的那个对象。\n\n3.一般情况下，this 是全局对象，可以作为方法调用。\n\n## 12、 call、apply 及 bind 函数 ★★★★★\n\n**call()、apply()、bind()都是用于改变this指向的方法，不同点传参方式不太相同以及返回不同。**\n\n* call( ) 是接收一个及其以上的参数，第一个参数表示this要指向的对象，其余参数表示调用函数需要传入的参数，返回调用函数的返回结果，属于立即执行函数；\n* apply( ) 是接收两个参数，第一个参数表示this要指向的对象，第二参数表示调用函数需要传入的参数所组成的数组，返回调用函数的返回结果，属于立即执行函数；\n* bind( ) 是接收一个及其以上的参数，和call(）一致，但是其返回是一个函数，而不是调用函数的返回结果；\n\n## 13 、**异步编程 ★★★★★**\n\n### 一、回调函数\n\n这是异步编程最基本的方法\n\n```js\nfunction asyncFn(callback) {\n    setTimeout(() => {\n        console.log('asyncFn');\n        callback();\n    }, 0)\n}\nfunction normalFn() {\n    console.log('normalFn');\n}\n\nasyncFn(normalFn);\n```\n\n- 缺点\n  - 容易出现回调地狱\n  - 当多个回调函数嵌套，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪\n  - 不能使用 try catch 不能直接return\n- 优点\n  - 简单、容易理解和实现\n\n### 二、事件触发模式\n\n另一种思路是采用事件驱动模式。即**异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。**\n比如一个我们注册一个按钮的点击事件或者注册一个自定义事件，然后通过点击或者trigger的方式触发这个事件。\n\n```js\nvar btn = document.getElementById('Button');\nbtn.onclick = function() {\n    console.log('展示异步操作');\n}\n```\n\n- 缺点\n  - 整个程序变成事件驱动型，运行流程不清晰\n- 优点\n  - 可以绑定多个事件，每个事件可以指定多个回调函数\n  - 可以“去耦合”，有利于实现模块化\n\n### 三、发布订阅\n\n发布/订阅模式，又称[观察者模式](https://so.csdn.net/so/search?q=观察者模式&spm=1001.2101.3001.7020)\n\n我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subcribe）这个信号，从而知道什么时候自己可以开始执行。\n\n```js\n//f2向信号中心Jquery订阅done信号\n\tjQuery.subscribe(\"done\", f2);\n\tfunction f1(){\n　　　　setTimeout(function () {\n　　　　　　// f1的任务代码\n\t\t   //发布done信号\n　　　　　　jQuery.publish(\"done\");\n　　　　}, 1000);\n　　}\n　　//f2执行完成后，取消订阅\n　　jQuery.unsubscribe(\"done\", f2);\n```\n\n发布/订阅，性质与“事件监听类似”，但是明显优于后者，因为我们可以通过查看”消息中心“，了解存在多少信号，多少个订阅者，从而监听程序的运行。\n\n### 四、Promises对象\n\nPromises对象是CommonJs工作提出的一种规范，目的是为了异步编程提供统一接口\n\n他的思想是每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数，比如f1的回调函数f2，可以写成：\n\n```js\nf1().then(f2);\n　\tfunction f1(){\n　\t\t//deferred对象就是jQuery的回调函数解决方案。\n　　　　var dfd = $.Deferred();\n　　　　setTimeout(function () {\n　　　　　　// f1的任务代码\n\t\t   //将dtd对象的执行状态从\"未完成\"改为\"已完成\"，从而触发done()方法\n　　　　　　dfd.resolve();\n　　　　}, 500);\n\t   //返回promise对象 \n\t   // deferred.promise()方法。它的作用是，在原来的deferred对象上返回另一个deferred对象，\n\t   //后者只开放与改变执行状态无关的方法（比如done()方法和fail()方法），\n\t   //屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），\n\t   //从而使得执行状态不能被改变。\n　　　　return dfd.promise;\n　　}\n \n\tf1().then(f2).then(f3); //指定多个回调函数\n\tf1().then(f2).fail(f3); //指定发生错误时的回调函数\n```\n\n### 五、生成器函数 Generator/yield\n\nGenerator函数是 ES6 提供的一种异步编程解决方案。\n\nyield表达式可以暂停函数执行，next方法用于恢复函数执行，这使得Generator函数非常适合将异步任务同步化。\nyield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n每个yield返回的是｛value:yield返回的值，done:true/false(执行状态)｝\n\n```js\nfunction *generatorDemo() {\n\t yield 'hello';\n\t yield 1 + 2;\n\t return 'ok';\n\t}\n\t \n\tvar demo = generatorDemo()\n\t \n\tdemo.next()  // { value: 'hello', done: false } \n\tdemo.next()  // { value: 3, done: false } \n\tdemo.next()  // { value: 'ok', done: ture } \n\tdemo.next()  // { value: undefined, done: ture }\n```\n\n六、async/await 函数的实现\nasync是“异步”的意思，而 await 是等待的意思。所以应该很好理解 async 用于申明一个 异步的function （实际上是asnyc function 对象）\n\nawait 用于等待一个异步任务执行完成的结果，并且await只等出现在 async 函数中\n\n一个函数如果加上 asnyc，那么该函数就会返回一个 Promise\n\n```js\nasync function async1() {\n  return \"1\"\n}\nconsole.log(async1()) // -> Promise {<resolved>: \"1\"}\n```\n\nasync函数返回的是一个 Promise 对象，可以使用 then 方法添加回调函数，async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n1.await命令后面返回的是 Promise 对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。\n\n## 14、seTimeout，Promise，Async/await的区别\n\n共同点\n\n```\n都是用来解决异步回调问题\n区别：\n```\n\n```\n1.setTimeout属于宏任务。\n```\n\n```\n2.Promise属于异步操作，只有当只有当.then(), resove(),.catch()等操作后才会进入微任务。\n```\n\n3.Async/await 在await之前都是异步操作，只有在await后才会进入微任务。\n也可以说如果函数体有一个await，async就一定会异步，没有的话就是同步。\n15、Promise理解\n（1）抽象描述：\n\n```\n①promise 是一门新的技术(ES6 规范)；\n\n②promise 是 js 中进行异步编程的新解决方案(旧方案是单纯使用回调函数)。\n```\n\n（2）具体描述：\n\n```\n①从语法上看：promise 是一个构造函数；\n\n②从功能上看：promise 对象用来封装一个异步操作并可以获取其成功或者失败的结果值。\n```\n\n## 15、async、await详解\n\nasync/awiat的使用规则:\n\n1. async 表示这是一个async函数， await只能用在async函数里面，不能单独使用\n2. async 返回的是一个Promise对象，await就是等待这个promise的返回结果后，再继续执行\n3. await 等待的是一个Promise对象，后面必须跟一个Promise对象，但是不必写then()，直接就可以得到返回值\n\n## 16、什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？\n\n[回调函数](https://so.csdn.net/so/search?q=回调函数&spm=1001.2101.3001.7020)：就是把一个函数当作一个函数的参数\n\n## 回调地狱：\n\n当[异步操作](https://so.csdn.net/so/search?q=异步操作&spm=1001.2101.3001.7020)想要有顺序时，只能在一个异步成功以后的回调函数里面嵌套另一个异步的操作，如果嵌套的层数过多就形成了回调地狱\n\n回调地狱的弊端：后期代码维护比较困难\n\n**async await  回调地狱的最终解决方法 （es7）**\n\n**原理：**实际上就是生成器函数的语法糖\n\n可以将异步嵌套的语法，改成像是同步一样。不需要嵌套，就可以有先后顺序\n\n# vue\n\n一、var、let、const的相同点\n\n二、var、let、const的不同\n\n区别一：var 存在变量提升 而 let 与 const 不存在变量提升\n\n区别二：var定义的变量可以声明多次，而let、const定义的变量只能声明\n\n区别三：var、let声明的变量可以再次赋值，而const声明的变量不能再次赋值\n\n## v-if和v-show的详解\n\nv-if:通过移除元素来实现元素的显示与隐藏，每次显示都会触发组件的mouted钩子函数。可以用来表面意义上的刷新组件\nv-show:通过设置元素的display属性来控制元素的显示与隐藏。elementui的弹窗组件就是利用v-show来控制显示与隐藏的。\n二.v-if和v-show的区别\n加载速度不同，v-show要比v-if快，实际项目中就是这样。\n原理不同。\n应用场景不同，v-if多用于需要刷新的组件。v-show多用于不需要刷新组件的显示与隐藏。\n组件内缓存子组件就是用的v-show。\n做项目优化的时候可以尽量使用v-show,具体看需求。\n\n## vue2和vue3的区别\n\n### 1、双向数据绑定原理不同\n\n**vue2**：[vue2](https://so.csdn.net/so/search?q=vue2&spm=1001.2101.3001.7020)的双向数据绑定是利用**ES5的一个APIObject.definePropert()** 对数据进行劫持，结合发布订阅模式的方式来实现的。\n\n**vue3**：[vue3](https://so.csdn.net/so/search?q=vue3&spm=1001.2101.3001.7020)中使用了**ES6的Proxy API**对数据代理。相比vue2.x，使用proxy的优势如下：\n\n* defineProperty只能监听某个属性，不能对全对象监听\n* 可以省去for in，闭包等内容来提升效率(直接绑定整个对象即可)\n* 可以监听数组，不用再去单独的对数组做特异性操作vue3.x可以检测到数组内部数据的变化。\n\n### 2、是否支持碎片\n\n**vue2**：vue2**不支持**碎片。\n\n**vue3**：vue3**支持碎片（Fragments）** ，就是说可以拥有多个根节点。\n\n### 3、API类型不同\n\n**vue2**：vue2使用**选项类型api**，选项型api在代码里分割了不同的属性：data,computed,methods等。\n\n**vue3**：vue3使用**合成型api**，新的合成型api能让我们使用方法来分割，相比于旧的api使用属性来分组，这样代码会更加简便和整洁。\n\n### 4、定义数据变量和方法不同\n\n**vue2**：vue2是把数据放入data中，在vue2中定义数据变量是**data(){}** ，创建的方法要在**methods:{}** 中。\n\n**vue3**：，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。使用以下三个步骤来建立反应性数据：\n\n* 从vue引入**reactive**；\n* 使用**reactive()** 方法来声明数据为响应性数据；\n* 使用setup()方法来返回我们的响应性数据，从而**template**可以获取这些响应性数据。\n\n### 5、生命周期钩子函数不同\n\n**vue2**：**vue2中的生命周期**：\n\n* beforeCreate 组件创建之前\n* created 组件创建之后\n* beforeMount 组价挂载到页面之前执行\n* mounted 组件挂载到页面之后执行\n* beforeUpdate 组件更新之前\n* updated 组件更新之后\n\n**vue3**：**vue3中的生命周期**：\n\n* setup 开始创建组件\n* onBeforeMount 组价挂载到页面之前执行\n* onMounted 组件挂载到页面之后执行\n* onBeforeUpdate 组件更新之前\n* onUpdated 组件更新之后\n\n而且vue3.x 生命周期在调用前需要先进行引入。除了这些钩子函数外，vue3.x还增加了onRenderTracked 和onRenderTriggered函数。\n\n### 6、父子传参不同\n\n**vue2**：父传子，用props,子传父用事件 Emitting Events。在vue2中，会**调用this\\$emit**然后传入事件名和对象。\n\n**vue3**：父传子，用props,子传父用事件 Emitting Events。在vue3中的setup()中的第二个参数content对象中就有emit，那么我们只要在setup()接收**第二个参数中使用分解对象法取出emit**就可以在setup方法中随意使用了。\n\n### 7、指令与插槽不同\n\n**vue2**：vue2中使用slot可以**直接使用slot**；v-for与v-if在vue2中优先级高的是**v-for指令**，而且不建议一起使用。\n\n**vue3**：vue3中必须使用**v-slot的形式**；vue3中v-for与v-if,只会把当前v-if当做v-for中的一个判断语句，**不会相互冲突**；vue3中移除keyCode作为v-on的修饰符，当然也不支持config.keyCodes；vue3中**移除v-on.native修饰符**；vue3中**移除过滤器filter**。\n\n### 8、main.js文件不同\n\n**vue2**：vue2中我们可以使用**pototype(原型)** 的形式去进行操作，引入的是**构造函数**。\n\n**vue3**：vue3中需要使用**结构**的形式进行操作，引入的是**工厂函数**；vue3中app组件中可以**没有根标签**。\n\n#### 拓展阅读\n\n### setup()函数特性\n\n* setup()函数接收两个参数：props、context(包含attrs、slots、emit)。\n* setup函数是处于生命周期beforeCreated和created俩个钩子函数之前。\n* 执行setup时，组件实例尚未被创建（在setup()内部，this不会是该活跃实例得引用，即不指向vue实例，Vue为了避免我们错误得使用，直接将setup函数中得this修改成了undefined）。\n* 与模板一起使用时，需要返回一个对象。\n* 因为setup函数中，props是响应式得，当传入新的prop时，它将会被更新，所以不能使用es6解构，因为它会消除prop得响应性，如需解构prop，可以通过使用setup函数中得toRefs来完成此操作。\n* 在setup()内使用响应式数据时，需要通过 .value 获取。\n* 从setup() 中返回得对象上得property 返回并可以在模板中被访问时，它将自动展开为内部值。不需要在模板中追加.value。\n* setup函数只能是同步的不能是异步的。\n\n### 1.vuex\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\n\n（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。\n主要包括以下几个模块：\n\n- **State =>** 基本数据，定义了应用状态的数据结构，可以在这里设置默认的初始状态。页面状态管理容器对象。集中存储 Vuecomponents 中 data对象的零散数据\n- **Getter =>** 从基本数据派生的数据，允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。\n- **Mutation =>** 是唯一更改 store 中状态的方法，且必须是同步函数。状态改变操作方法\n- **Actions =>** 像一个装饰器，包裹mutations，使之可以异步。用于提**交 mutation**，而不是直接变更状态，可以包含任意异步操作。操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。\n- **Module =>** 模块化Vuex，允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。\n\n### 为什么 Vuex 的 mutation 中不能做异步操作？\n\nVuex 中所有的状态更新的唯一途径都是 mutation，异步操作通过\nAction 来提交 mutation 实现，这样可以方便地跟踪每一个状态的\n变化，从而能够实现一些工具帮助更好地了解我们的应用。\n每个 mutation 执行完成后都会对应到一个新的状态变更，这样\ndevtools 就可以打个快照存下来，然后就可以实现 time-travel 了。\n如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，\n无法很好的进行状态的追踪，给调试带来困难。\n\n## 2、生命周期\n\nbeforeCreate\t组件实例被创建之初，组件的属性生效之前\ncreated\t组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用\nbeforeMount\t在挂载开始之前被调用：相关的 render 函数首次被调用\nmounted\tel 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子\nbeforeUpdate\t组件数据更新之前调用，发生在虚拟 DOM 打补丁之前\nupdated\t组件数据更新之后\nactivited\tkeep-alive 专属，组件被激活时调用\ndeadctivated\tkeep-alive 专属，组件被销毁时调用\nbeforeDestory\t组件销毁前调用\ndestoryed\t组件销毁后调用\n\n**beforeCreate** 在实例初始化之后，数据观测（data observe）和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。\n\n**created** 实例已经创建完成之后被调用。在这一步，实例已经完成以下的配置：数据观测（data observe ），属性和方法的运算，watch/event 事件回调。这里没有 $el，如果非要想与 DOM 进行交互，可以通过vm.$nextTick 来访问 DOM。\n\n**beforeMount** 在挂载开始之前被调用：相关的 render 函数首次被调用。\n\n**mounted** 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom节点。\n\n**beforeUpdate** 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁 （patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。（数据修改页面未修改）\n\n**updated** 发生在更新完成之后，当前阶段组件 Dom 已经完成更新。要注意的是避免在此期间更新数据，因为这个可能导致无限循环的更新，该钩子在服务器渲染期间不被调用。\n\n**beforeDestroy** 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行 善后收尾工作，比如清除定时器。\n\n**destroyed**  Vue实例销毁后调用。调用后，Vue实例指示的东西都会解绑定，所有的事件监听器会被移除，左右的子实例也会被销毁，该钩子在服务器端渲染不被调用。\n\n**activated keep-alive** 专属，组件被激活时调用\n\n## 3、Vue 组件间通信有哪几种方式？\n\nVue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。\n（1）props / $emit 适用 父子组件通信\n\n这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。\n（2）ref 与 $parent / $children适用 父子组件通信\n\nref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例\n$parent / $children：访问父 / 子实例\n（3）EventBus （$emit / $on）适用于 父子、隔代、兄弟组件通信\n\n这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。\n（4）$attrs/$listeners适用于 隔代组件通信\n\n$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=\"$attrs\" 传入内部组件。通常配合 inheritAttrs 选项一起使用。\n$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件\n（5）provide / inject适用于 隔代组件通信\n\n祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。\n（6）Vuex适用于 父子、隔代、兄弟组件通信\n\n### Vue组件通讯有哪些方式？\n\n1、props 和 $emit。父组件向子组件传递数据是通过props传递的，子组件传递给父组件是通过$emit触发事件来做到的。\n\n2、$parent 和 $children 获取单签组件的父组件和当前组件的子组件。\n\n3、$attrs 和 $listeners A -> B -> C。Vue2.4开始提供了$attrs和$listeners来解决这个问题。\n\n4、父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。（官方不推荐在实际业务中适用，但是写组件库时很常用。）\n\n5、$refs 获取组件实例。\n\n6、envetBus 兄弟组件数据传递，这种情况下可以使用事件总线的方式。\n\n7、vuex 状态管理\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\nVuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。\n\n## 4、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？\n\n### （1）hash 模式的实现原理\n\n早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：\nhttps://www.word.com#search\nhash 路由模式的实现主要是基于下面几个特性：\n\nURL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；\nhash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；\n可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；\n我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。\n\n### （2）history 模式的实现原理\n\nHTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。\n唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：\nwindow.history.pushState(null, null, path);\nwindow.history.replaceState(null, null, path);\nhistory 路由模式的实现主要基于存在下面几个特性：\n\npushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；\n我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；\nhistory.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。\n\n## 5、computed 和 watch 区分使用场景\n\n### computed：\n\n是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；\n\n### watch：\n\n更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；\n\n### 运用场景：\n\n当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；\n当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n\ncomputed： 是**计算属性**，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；\nwatch： 更多的是「**观察**」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；\n运用场景：\n当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；\n当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n\n## 6、v-if 和 v-show 有什么区别？\n\nv-if 是真正的条件渲染，会控制这个 DOM 节点的存在与否。因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：**如果在初始渲染时条件为假**，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n**v-show 就简单得多——不管初始条件是什么，元素总是会被渲染**，并且只是简单地基于 CSS 的 “display” 属性进行切换。\n当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。\n\n## 7、怎样理解 Vue 的单向数据流？\n\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。\n这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。\n额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。\n这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。\n子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。\n\n## 8、v-model 的原理？\n\n我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：\n\n* text 和 textarea 元素使用 value 属性和 input 事件；\n* checkbox 和 radio 使用 checked 属性和 change 事件\n* select 字段将 value 作为 prop 并将 change 作为事件。\n\n## 9、vue-router历史模式和hash模式的区别？\n\n**hash模式**：\nurl里面带有#号，开发中默认的就是hash模式，hash虽然出现在URL中，但是不会被包括在HTTP请求中，所以改变hash不会重新刷新页面\n\n路由的哈希模式就是利用了window.onhashchange事件，也就是url中的hash值（#号后面的值）如果有变化，就会自动调用hashchange的监听事件，在hashchange的监听事件内可以得到改变后的url，这样就能找到对应页面进行加载\n\n**历史模式**：\n利用了H5新增的pushState()、replaceState()方法。当这两个方法执行时，只能改变当前地址栏的URL，但是浏览器不会像后端发起请求，也不会触发popstate事件的执行。\n\n## 10、created和mounted的区别\n\n**created**：**在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成识图。**\n**mounted**：**在模板渲染成html后调用，通常初始化页面完成后，再对html的dom节点进行一些需要的操作**。\n\n## 11、v-[model]是如何实现的实现原理\n\n### 1. 作用在普通表单元素上\n\n- 动态绑定了 `input` 的 `value` 指向了 `message` 变量，并且在触发 `input` 事件的时候去动态把 `message` 设置为目标值\n- ### 作用在组件上\n\n  - 在自定义组件中，`v-model` 默认会利用名为 `value` 的 `prop` 和名为 `input` 的事件\n  - 本质是一个父子组件通信的语法糖，通过 prop 和 $emit 实现\n\n## 12、vue列表为什么加key\n\n* 1、性能优化\n* 2、diff算法节点比对\n* 3、key不能是index\n\n## 13路由的 hash 和 history 模式的区别\n\nVue-Router 有两种模式：hash 模式和 history 模式。默认的路由模\n式是 hash 模式。\n\nhash 模式是开发中默认的模式，它的 URL 带着一个#，例如：\nhttp://www.abc.com/#/vue，它的 hash 值就是#/vue。\n特点：hash 值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对\n后端完全没有影响。所以改变 hash 值，不会重新加载页面。这种模\n式的浏览器支持度很好，低版本的 IE 浏览器也支持这种模式。hash\n路由被称为是前端路由，已经成为 SPA（单页面应用）的标配。\n\n原理： hash 模式的主要原理就是 onhashchange()事件：\n\n![1709212160938](images/前端八股文/1709212160938.png)\n\n2. history 模式\n   简介： history 模式的 URL 中没有#，它使用的是传统的路由分发模\n   式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个\n   URL，然后做出相应的逻辑处理。\n   特 点 ： 当 使 用 history 模 式 时 ， URL 就 像 这 样 ：\n   http://abc.com/user/id。相比 hash 模式更加好看。但是，history\n   模式需要后台配置支持。如果后台没有正确配置，访问时会返回 404。\n   API： history api 可以分为两大部分，切换历史状态和修改历史状\n   态：\n   修 改 历 史 状 态 ： 包 括 了 HTML5 History Interface 中 新 增 的\n   pushState() 和 replaceState() 方法，这两个方法应用于浏览器的\n   历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修\n   改时，虽然修改了 url，但浏览器不会立即向后端发送请求。如果要\n   做到改变 url 但又不刷新页面的效果，就需要前端用上这两个 API。\n   切换历史状态： 包括 forward()、back()、go()三个方法，对应浏\n   览器的前进，后退，跳转操作。\n   虽然 history 模式丢弃了丑陋的#。但是，它也有自己的缺点，就是\n   在刷新页面的时候，如果没有相应的路由或资源，就会刷出 404 来。\n   如果想要切换到 history 模式，就要进行以下配置（后端也要进行配\n   置）：\n3. 两种模式对比\n   调用 history.pushState() 相比于直接修改 hash，存在以下优势:\n   pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而\n   hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的\n   URL；\n   pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把\n   记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动\n   作将记录添加到栈中；\n   pushState() 通过 stateObject 参数可以添加任意类型的数据到记\n   录中；而 hash 只可添加短字符串；\n   pushState() 可额外设置 title 属性供后续使用。\n   hash 模式下，仅 hash 符号之前的 url 会被包含在请求中，后端如果\n   没有做到对路由的全覆盖，也不会返回 404 错误；history 模式下，\n   前端的 url 必须和实际向后端发起请求的 url 一致，如果没有对用的\n   路由处理，将返回 404 错误。\n   hash 模式和 history 模式都有各自的优势和缺陷，还是要根据实际\n   情况选择性的使用。\n\n# 5、状态码\n\n常用的请求状态码\n\n### 500 内部服务器错误\n\nInternal Server Error 500内部服务器错误，服务器遇到未知无法解决的问题。\n\n一般情况下，出现500响应状态的原因有很多种，但是主要的是“程序代码和服务器配置”两个问题。相对于代码而言，就是对站点进行升级，网页改版，新增加了一些常用的插件。就比如WordPress插件的版本可能就需要更高版本的PHP才能兼容。\n\n而相对服务器而言的话，更多的是在系统版本升级导致，就比如最开始使用的是Windows Server 2003，后期想要升级2008、2012等版本的时候配置稍有不慎就会导致Internal Server Error 500。\n\n### 404 请求错误\n\nNot Found 404 错误请求，因发送的请求语法错误,服务器无法正常读取。\n\n相信绝大多数的人都见过404的状态码，当用户试图请求Web服务器上一个不存在的资源时，就会触发Not Found404。出现404状态码可能是链接失效导致，也有可能是URL拼写错误，还有可能是因为Web服务器将所请求的资源移到了其他的地方。一般的网站都会设置自定义页面以防链接失效所产生不良的影响。\n\n403 禁止访问\nForbidden 403 禁止访问，客户端没有权利访问所请求内容,服务器拒绝本次请求。\n\n### 状态码403通常代表客户端错误\n\n是指的服务器端有能力处理该请求，但是拒绝授权访问。这个状态码类似于401，但是进入该状态后不能再继续进行验证，该访问是长期禁止的，并且与应用逻辑密切相关，比如密码不正确等。\n\n### 400 错误请求\n\nBad Request 400 错误请求，因发送的请求语法错误,服务器无法正常读取。\n\n状态码400表示该语法无效，服务器无法理解该请求。客服端不应该在未经修改的情况下重复此请求。一般会因为前端提交数据的字段名称，或者是字段类型和后台的实体类不一致，导致无法封装。\n\n### 401 未经授权\n\nUnauthorized 401 未经授权，需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过。\n\n状态码401就是Web服务器认为，客户端发送的HTTP数据流浪是正确的，但是进入URL资源的时候需要身份验证，而客户端尚未提供相关的验证信息，或者是已提供但是没有通过验证。这也是通常所知的“HTTP基本验证”。\n\n### 200 请求成功\n\n200 OK 请求成功，表示已经请求成功，默认情况下的状态码为200的响应就可以被缓存了。\n\n不同请求方式对于请求成功的意义如下：\n\nGET: 已经取得资源，并将资源添加到响应的消息体中。\nHEAD: 响应的消息体为头部信息。\nPOST: 响应的消息体中包含此次请求的结果。\nTRACE: 响应的消息体中包含服务器接收到的请求信息。\n\nPUT 和 DELETE 的请求成功通常并不是响应200OK的状态码而是 204No Content 表示无内容(或者 201Created表示一个资源首次被创建成功)。\n\n### 206 部分内容\n\nPartial Content 206 部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码。\n\n状态码206表示服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。\n\n### 301 永久重定向\n\nMoved Permanently 301 永久移动，该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的Location:头字段里找到。\n\n尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用301，其他情况使用308 来替代301。\n\n### 302 临时重定向\n\nFound 302临时移动，该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的Location:头字段里找到。\n\n即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代，因为在这些场景下方法变换是明确禁止的。\n\n### 502 无效网关\n\nBad Gateway 502 网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应。\n\n### 404 请求错误\n\nNot Found 404 错误请求，因发送的请求语法错误,服务器无法正常读取。\n\n相信绝大多数的人都见过404的状态码，当用户试图请求Web服务器上一个不存在的资源时，就会触发Not Found404。出现404状态码可能是链接失效导致，也有可能是URL拼写错误，还有可能是因为Web服务器将所请求的资源移到了其他的地方。一般的网站都会设置自定义页面以防链接失效所产生不良的影响。\n\n### 403 禁止访问\n\nForbidden 403 禁止访问，客户端没有权利访问所请求内容,服务器拒绝本次请求。\n\n状态码403通常代表客户端错误，是指的服务器端有能力处理该请求，但是拒绝授权访问。这个状态码类似于401，但是进入该状态后不能再继续进行验证，该访问是长期禁止的，并且与应用逻辑密切相关，比如密码不正确等。\n\n### 400 错误请求\n\nBad Request 400 错误请求，因发送的请求语法错误,服务器无法正常读取。\n\n状态码400表示该语法无效，服务器无法理解该请求。客服端不应该在未经修改的情况下重复此请求。一般会因为前端提交数据的字段名称，或者是字段类型和后台的实体类不一致，导致无法封装。\n\n### 401 未经授权\n\nUnauthorized 401 未经授权，需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过。\n\n状态码401就是Web服务器认为，客户端发送的HTTP数据流浪是正确的，但是进入URL资源的时候需要身份验证，而客户端尚未提供相关的验证信息，或者是已提供但是没有通过验证。这也是通常所知的“HTTP基本验证”。\n\n### 200 请求成功\n\n200 OK 请求成功，表示已经请求成功，默认情况下的状态码为200的响应就可以被缓存了。\n\n不同请求方式对于请求成功的意义如下：\n\nGET: 已经取得资源，并将资源添加到响应的消息体中。\nHEAD: 响应的消息体为头部信息。\nPOST: 响应的消息体中包含此次请求的结果。\nTRACE: 响应的消息体中包含服务器接收到的请求信息。\n\nPUT 和 DELETE 的请求成功通常并不是响应200OK的状态码而是 204No Content 表示无内容(或者 201Created表示一个资源首次被创建成功)。\n\n### 206 部分内容\n\nPartial Content 206 部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码。\n\n状态码206表示服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。\n\n### 301 永久重定向\n\nMoved Permanently 301 永久移动，该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的Location:头字段里找到。\n\n尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用301，其他情况使用308 来替代301。\n\n### 302 临时重定向\n\nFound 302临时移动，该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的Location:头字段里找到。\n\n即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代，因为在这些场景下方法变换是明确禁止的。\n\n### 502 无效网关\n\nBad Gateway 502 网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应。\n\nbad gateway502代表您所访问的网站出了问题，因为502 Bad Gateway 服务器作为网关或者代理时，是为了完成访问下一个服务器，但该服务器返回了非法的应答。也许是暂时的，也许是永久的。建议大家稍等一下再从新访问试试。\n","source":"_posts/前端八股文.md","raw":"---\ntitle: HTML八股文\ndate: 2024-03-18 17:27:43\nCATEGORYS: 前端\ntags:\n  - Tag\n  - HTML\n  - CSS\n  - JavaScript\n  - Vue\n  - React\n  - Node.js\n  - Webpack\n  - Babel\n  - TypeScript\n  - Vuex\ncategories: 前端\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/屏幕截图(1).png\nfeature: true\n---\n# 1、HTML\n\n![1709997145390](https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg)\n\n## 1.你对 HTML 语义化的理解？★★★★★\n\n1. html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、[搜索引擎](https://so.csdn.net/so/search?q=搜索引擎&spm=1001.2101.3001.7020)解析；即使在没有样式 CSS 情况下也以    一种文档格式显示，并且是容易阅读的;\n2. 搜索引擎的[爬虫](https://so.csdn.net/so/search?q=爬虫&spm=1001.2101.3001.7020)也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;\n\n## 2、 title 与 alt 属性的区别是什么？\n\n1. alt 是给搜索引擎识别，在图像无法显示时的替代文本；\n2. title 是关于元素的注释信息，主要是给用户解读。\n3. 当鼠标放到文字或是图片上时有 title 文字显示。（因为 IE 不标准）在 IE 浏览器中 alt 起到了 title 的作用，变成文字提示。\n\n## 3、href 与 src？\n\n> href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。（目的不是为了引用资源，而是为了建立联系，让当前标签能够链接到目标地址。）\n> src source（缩写），指向外部资源的位置，指向的内容将会应用到文档中当前标签所在位置。\n> href与src的区别\n> 1、请求资源类型不同：href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；\n> 2、作用结果不同：href 用于在当前文档和引用资源之间确立联系；src 用于替换当前内容；\n> 3、浏览器解析方式不同：当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。\n\nsrc和href都是对外部资源的引用，区别如下：\n\nsrc: 表示对资源的引用，用在js脚本、img、frame等元素上，当浏览器解析到该元素时，会**暂停**其他资源的下载和处理，直到该资源加载、编译、执行完成，所以js脚本会放在页面的底部，而不是头部。\n\nhref：表示超文本引用，指向一些网络资源，当浏览器识别它指向的文件时，就会**并行**下载资源，不会停止对当前文件的处理，用在a、link上\n\n## 4、HTML5、CSS3 里面都新增了那些新特性？\n\nHTML5\n\n- [ ]  新的语义标签\n  article 独立的内容。\n  aside 侧边栏。\n  header 头部。\n  nav 导航。\n  section 文档中的节。\n  footer 页脚。\n  画布(Canvas) API\n  地理(Geolocation) API\n  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；\n  sessionStorage 的数据在浏览器关闭后自动删除\n  新的技术webworker, websocket, Geolocation\n  拖拽释放(Drag and drop) API\n  音频、视频API(audio,video)\n  表单控件，calendar、date、time、email、url、searc\n  CSS3\n\n- 2d，3d变换\n  Transition, animation\n  媒体查询\n  新的单位（rem, vw，vh 等）\n  圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜\n  rgba\n\n## 5、行内元素与块级元素\n\n### 块级元素： 独占一行，可以设置宽高，设置margin和padding都有效，代表如下：\n\ndiv、p、h1…h6、table、tr、ol、li、ul\n\n### 行内元素元素： 可以排成一行，设置宽高无效，对margin设置左右方向有效，而上下无效，padding设置都无效，代表如下：\n\n基本上都是文本标签\n\nspan、img、b、strong、font、br、a\n\n## 什么是BFC?\n\nBFC全称是Block Formatting Context，意思就是块级格式化上下文。你可以把BFC看做一个容器，容器里边的元素不会影响到容器外部的元素。\n\nBFC有什么特性？\nBFC是一个块级元素，块级元素在垂直方向上依次排列。\n\nBFC是一个独立的容器，内部元素不会影响容器外部的元素。\n\n属于同一个BFC的两个盒子，外边距margin会发生重叠，并且取最大外边距。\n\n[[面试官：什么是BFC？BFC有什么特性？如何创建BFC？BFC有什么作用？-CSDN博客](https://blog.csdn.net/guoao20000915/article/details/125685983?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170929193616777224499886%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170929193616777224499886&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125685983-null-null.142^v99^pc_search_result_base2&utm_term=bfc&spm=1018.2226.3001.4187)](https://)\n\n解决当父级元素没有高度时，子级元素浮动会使父级元素高度塌陷的问题\n\n解决子级元素外边距会使父级元素塌陷的问题\n\n# 2、CSS\n\n## 1、介绍一下 CSS 的盒子模型？★★★★★\n\n有两种， IE 盒子模型、W3C 盒子模型；\n盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n区 别： IE 的 content 部分把 border 和 padding 计算了进去;\n\n## 2、css 选择器优先级？★★★★★\n\n!important > 行内样式（比重1000）> ID 选择器（比重100） > 类选择器（比重10） > 标签（比重1） > 通配符 > 继承 > 浏览器默认属性\n\n## 3、垂直居中几种方式？★★★★★\n\n单行文本: line-height = height\n图片: vertical-align: middle;\nabsolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);\nflex: display:flex;margin\n\n- 1 使用flex布局\n  利用flex的alignItems:center垂直居中，justifycontent:center水平居中\n- 2 利用相对定位和绝对定位的margin:auto\n- 相对定位下，使用绝对定位将上下左右都设置为0，再设置margin:auto即可实现居中\n- 3 利用相对定位和绝对定位，再加上外边距和平移的配合\n  相对定位下，使用绝对定位，利用margin偏移外容器的50%，再利用translate平移回补自身宽高的50%即可\n- 4 利用textAlign和verticalAlign\n  利用textAlign:center实现行内元素的水平居中，再利用verticalAlign:middle实现行内元素的垂直居中，前提是要先加上伪元素并给设置高度为100%，用过elementUI的可以去看看其消息弹窗居中实现方式就是如此\n\n**四种方式：**\n\n**利用绝对定位**，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。\n\n```css\n.div {\n        position: absolute;\n        width: 200px;height: 200px;\n         left: 50%;top: 50%;\n        transform: translate(-50%, -50%);\n        或//margin-left:-50px;margin-top:-50px;\n      }\n```\n\n**利用绝对定位**，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于盒子有宽高的情况。\n\n```css\n.div {\n        position: relative;\n        width: 200px;height: 200px;\n        left: 50%; top: 50%;\n       transfrom:trable(-50%,-50%)\n      }\n```\n\n使用**flex布局****，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。\n\n```\n.div {\n       // width: 100%; //height: 100%;\n        display: flex;\n        justify-content: center;\n        align-items:center;\n      }\n```\n\n## 4.flex布局的父级元素中有哪些常用属性。\n\n答：\n\nflex-direction: 设置主轴的方向\n\njustify-content: 设置主轴上的子元素对齐方式\n\nflex-wrap: 设置子元素是否换行\n\nalign-content: 设置侧轴上的子元素的排列方式(多行)\n\nalign-items:  设置侧轴上的子元素排列方式 (单行)\n\nflex-flow: 复合属性, 相当于同时设置了 flex-direction 和 flex-wrap\n\n## 5、var、let、const 区别？★★★★★\n\nvar 存在变量提升。\nlet 只能在块级作用域内访问。\nconst 用来定义常量，必须初始化，不能修改（对象特殊）\n\nvar 全局作用域 变量更新 重新声明 可以变量提升(**将var变量放到第一行**)\n\nlet 块作用域  变量更新 不能重新声明\n\nconst 块作用域  不能变量更新 不能重新声明\n\nvar 初始化为undefined\n\n## 6、1rem、1em、1vh、1px各自代表的含义？\n\nrem\nrem是全部的长度都相对于根元素元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。\nem\n子元素字体大小的em是相对于父元素字体大小\n元素的width/height/padding/margin用em的话是相对于该元素的font-size\nvw/vh\n全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。\npx\npx像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。\n一般电脑的分辨率有{19201024}等不同的分辨率\n19201024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素\n\n## 7、怎么解决浮动中塌陷的问题\n\n### 第一种：开启BFC\n\n根据W3C的标准，在页面中元素都有一个隐含的属性 Block Formatting Context,简称BFC，默认是关闭的；\n\n开启元素BFC后，元素将会具有以下特性：\n\n父元素的垂直外边距不会和子元素重叠\n开启BFC的元素不会被浮动元素所覆盖\n开启BFC的元素可以包含浮动元素\n开启BFC的方法：。\n\n** overflow【常见，副作用最小】**\n\noverflow设置为非visible的值。推荐使用hidden（副作用最小）\n\na) auto （溢出显示滚动条）\n\nb) scroll （默认就显示滚动条）\n\nc) hidden （溢出隐藏）[常用]\n\n注：但在IE6及以下的浏览器中不支持BFC，所以使用这种方式不兼容IE6。在IE6中有类似BFC的隐含属性 hasLayout，开启方式很多，推荐使用zoom:1\n\n### 第二种：在浮动元素后添加元素，并设置其clear属性\n\n### 第三种：br元素的clear属性\n\nbr元素本身没有高度，所以也就不会存在IE低版本下最小高度问题。只需要在浮动元素下添加一句 :\n\n※第四种：after伪类【各大公司推荐】\n\n可以通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动，和第二种方法原理相同，可达到相同的效果，而且不会在页面中添加多余的div，这是最推荐的方式，几乎没有副作用\n\n## 8、display:none和visibility:hidden的区别？\n\ndisplay:none：     隐藏元素,不占空间 继承属性\n\nvisibility:hidden：隐藏元素,不占空间 继承属性\n\n> display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。\n> visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。\n\n## 9、position的值， relative和absolute分别是相对于谁进行定位的？\n\nrelative:相对定位，相对于自己本身在正常文档流中的位置进行定位。\nabsolute:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。\nfixed: （老版本IE不支持）生成绝对定位，相对于浏览器窗口或者frame进行定位。\nstatic:默认值，没有定位，元素出现在正常的文档流中。\nsticky:生成粘性定位的元素，容器的位置根据正常文档流计算得出。\n\n10、\n\n## 10、画一条0.5px的直线？\n\n> 考查的是css3的transform\n\n```\nheight: 1px;\ntransform: scale(0.5);\n```\n\n## 11、BFC 是什么？\n\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n只要元素满足下面任一条件即可触发 BFC 特性\n\nbody 根元素\n浮动元素：float 除 none 以外的值\n绝对定位元素：position (absolute、fixed)\ndisplay 为 inline-block、table-cells、flex\noverflow 除了 visible 以外的值 (hidden、auto、scroll)\n\n## 8、前端常见的布局方式\n\n### 一、静态布局\n\n静态布局是最为原始的布局方式，没有什么技术性可言，往往是计算机行业刚刚入门的小白使用的布局方式。制作的网页上的元素尺寸一律以px为单位\n\n布局特点： 页面上的布局是按最初写代码时候的布局方式进行布局的，常规的pc网站是进行设置了宽度值进行布局的，不会随着pc端的屏幕的大小而变化。\n优点: 这种布局方式不管是对资深的前端开发工程师还是刚入门的小白来说都是最简单的，最让人容易以接受、学习的，没有我们所说的兼容性的问题。这种布局方式大多用在门户网站和企业的官网上，这些官网的设备的尺寸是固定的，这种布局方式往往是最简单的方法。\n缺点： 不会随着pc端的屏幕大小而变化。\n\n### 二、弹性布局（flexbox）\n\n弹性布局可以简便、完整、响应的实现各种页面上的布局。与静态不同的是，使用em或rem单位（lem=16px，1rem=10px）进行相对布局，相对使用百分比更加方便、灵活，相应同时支持浏览器的字体大小调整和缩放的等正常显示。\n优点：\n1.适应性强，在做多种不同的屏幕分辨率不同的界面是非常使用。\n2.随意按照宽度、比例划分元素的宽高。\n3.可以轻松的改变元素的显示顺序。\n4.网页布局实现快捷，维护起来更加容易。\n如果做移动端时，如果客户对细微的之处的要求不高，使用弹性布局进行制作是最好的选择，一份css+一份js调节font-size搞定。\n缺点： 浏览器兼容性较差，只能兼容到IE9及以上。\n\n### 三、自适应布局（bootstrap）\n\n自适应布局分别为不同屏幕不同分辨率定义布局，即是创建多个静态页面，每个静态页面对应一个屏幕分辨率的一个范围内。在改变不同的屏幕分辨率可以切换到不同的静态布局上，但是布局中的元素位置会发生改变，但是在每个静态布局中，页面中的元素不会随着窗口大小的调整发生变化。使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。\n优点：\n1.对网站的复杂程度兼容性更大；\n2.对开发工程师来说制作的成本代价更低；\n3.代码执行效果更高效；\n4.测试时更加容易，运营相对更加精准。\n缺点： 在现如今的移动端设计百花齐放的时期之下，同一个网站往往需要为不同的设备制作不同的页面，不但会增加开发成本，还会因为客户的需求改变时，可能会改动多套代码、流程相比较来说较繁琐。\n\n### 四、流式布局（fluid）\n\n流式布局的布局方式是页面的元素的宽度按照屏幕的分辨率进行适配的调整，但是整体布局不变，也称之为栅栏系统。使用%百分比定义宽度，高度大都是用px来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。\n缺点： 屏幕大小变化时，页面元素也随之变化但是布局不变。这就会因为如果屏幕太大或太小都会布局时元素无法正常显示。\n\n### 五、响应式布局\n\n响应式布局是css3增加的新布局方式，该布局方式2010年提出来的一个概念，说白了就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。响应式几乎成为优秀页面布局的标准。\n设计方法： 媒体查询+流式布局。通常使用@media媒体查询，和网格系统配合相对布局单位进行布局，实际上说白了就是综合响应式等技术通过css给单一网页不同设备分辨率返回不式时的技术。\n优点： 适应pc端和移动端，如果有足够的耐心，页面效果会很完美。\n缺点：\n1.只能适应主流的宽高；\n2.如果匹配足够多的设备屏幕的大小，对于工程师来说工作量不小，设计更需要多个版本，工作量增大。\n\n### 六、浮动布局\n\n浮动布局进行调用浮动属性改变页面中元素的位置，浮动布局应该是目前各大网站用的最多的一种布局方式了，但是也特别复杂。浮动元素是脱离文档流的，但不脱离文本流。浮动元素有左浮动（float : left）和右浮动（float : right）两种\n\n优点： 兼容性比较好\n缺点： 浮动带来的影响比较多，页面宽度不够的时候会影响布局。\n\n### 七、定位布局\n\n定位布局时利用position属性控制页面元素设置一些不规则布局。\n\n# 3、js\n\n\n## 什么是async？\n\nasync 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用 await 来表示异步。相较于 Generator，async 函数的改进在于下面四点：\n\n内置执行器。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，调用方式跟普通函数的调用一样\n更好的语义。async 和 await 相较于 * 和 yield 更加语义化\n更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise对象。而 async 函数的 await 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）\n返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用\n\n\n## await是什么？\n\nawait意思是async wait(异步等待)。这个关键字只能在使用async定义的函数里面使用。任何async函数都会默认返回promise，并且这个promise解析的值都将会是这个函数的返回值，而async函数必须等到内部所有的 await 命令的 Promise 对象执行完，才会发生状态改变。\n\n打个比方，await是学生，async是校车，必须等人齐了再开车。\n\n就是说，必须等所有await 函数执行完毕后，才会告诉promise我成功了还是失败了，执行then或者catch\n\n\n## 19、var,let ,const 三者区别？\n\n共同点：都是可以声明变量\n\n区别1：var具有变量提升的机制，let和const 没有变量提升机制，\n\n区别2：var可以多次声明同一个变量，let和const 不可以多次声明同一个变量，\n\n区别3：var和let声明的是常量，const声明常量，var和let声明的变量可以再一次赋值，而const 不可以再次赋值\n\n面试的时候会问const 一个对象，里面是a:1，我现在想打印console.log(obj.a)这个结果是1，我想改变a:2,打印的就是2因为里面的值不是const,从内存的角度看，一个对象里面修改了对量里面的属性值，那么再次打印会打印出新的值，\n\n什么是常量：常量是一个在程序执行过程中不能被改变或修改的固定值。它是被赋予一个固定值后就不能再改变的变量。理解成，不能被操作所修改的变量就是常量。用途：保护数据，可以提高程序的可读性、可维护性\n\n变量：变量是用于存储和表示数据的一种命名容器。它是程序中的一个基本概念，用于在内存中存储和操作数据。变量的值可以被修改和更新。\n\n区别4：var没有作用域，在ES6之后才出现的作用域块的概念，\n\n### null 和 undefined 区别\n\n首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型\n分别都只有一个值，就是 undefined 和 null。\nundefined 代表的含义是未定义，null 代表的含义是空对象。一般\n变量声明了但还没有定义的时候会返回 undefined，null 主要用于\n赋值给一些可能会返回对象的变量，作为初始化。\n\n### 作用域链\n\n在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个\n变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域\n查找，依次向上级作用域查找，直到访问到 window 对象就被终止，\n这一层层的关系就是作用域链\n\n### **1、深拷贝、浅拷贝（笔试题）★★★★★**\n\n【{},[]】\n\n- 浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个**地址**，修改时原对象也会受到影响\n  - Object.assign\n  - 展开运算符 ...\n- 深拷贝: 完全拷贝一个新**对象**，修改时原对象不再受到任何影响\n\n## 2、作用域、作用域链\n\n作用域：变量和函数起作用的范围。\n\n作用域链：是js查找方式，决定的变量和函数向上查找的范围。\n\n作用域是可访问的变量的\n集合。在JavaScript中，作用域为可访问变量，对象，函数的集合，它分为局部作用域和全局作用域。作用域决定了这些变量的可访问性（可见性）。\n\n作用域链\n\n我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含\n父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。\n\n它由两部分组成:\n[[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO\nAO: 自身活动对象\n如此 [[scope]]包含[[scope]]，便自上而下形成一条 链式作用域。\n\n## 1、闭包★★★★★\n\n### 1、变量作用域\n\n```\n要理解闭包，首先要理解 JavasSript 的特殊的变量作用域。\n```\n\n```\n变量的作用域无非就两种：全局变量和局部变量。\n```\n\n```\nJavasSript 语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局                    部变量。\n```\n\n**注意点：**在函数内部声明变量的时候，一定要使用 var 命令。如果不用的话，你实际上声明的是一个全局变量！\n\n### 2、如何从外部读取函数内部的局部变量？\n\n出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。\n\n那就是在函数内部，再定义一个函数。\n\n```js\nfunction f1(){\n    var n=999;\n    function f2(){\n        alert(n); // 999\n    }\n}\n```\n\n在上面的代码中，函数 f2 就被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。\n\n这就是 JavasSript 语言特有的\"链式作用域\"结构（chain scope）\n\n### 3、闭包的概念\n\n上面代码中的 f2 函数，就是闭包。\n\n各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。\n\n由于在 JavaScript 中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成\"定义在一个函数内部的函数\"。\n\n所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。\n\n闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数\n\n使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。\n\n闭包有三个特性：\n\n1.函数嵌套函数\n\n2.函数内部可以引用外部的参数和变量\n\n3.参数和变量不会被垃圾回收机制回收\n\n### 4、闭包的用途\n\n闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在 f1 调用后被自动清除。\n\n为什么会这样呢？原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。\n\n这段代码中另一个值得注意的地方，就是 “nAdd=function(){n+=1}” 这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量。其次，nAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。\n\n* 使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。\n* 闭包有三个特性：\n* 函数嵌套函数\n* 函数内部可以引用外部的参数和变量\n* 参数和变量不会被垃圾回收机制回收\n\n应用场景：\n\n* 设置私有变量的方法\n* 不适用场景：返回闭包的函数是个非常大的函数\n  闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏\n\n### 5、使用闭包的注意点\n\n（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值\n\n## 2、 原型链★★★★★\n\n那什么是原型链呢？\n\n简单理解就是原型组成的链，对象的__proto__它的是原型，而原型也是一个对象，也有__proto__属性，原型的__proto__又是原型的原型，就这样可以一直通过__proto__想上找，这就是原型链，当向上找找到Object的原型的时候，这条原型链就算到头了。\n\n原型对象和实例之间有什么作用呢？\n\n通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。\n\n在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法。\n\n## 3、 请列举几种隐藏元素的方法\n\nvisibility: hidden;这个属性只是简单的隐藏某个元素，但是元素占用的空间仍然存在\nopacity: 0; CSS3属性，设置0可以使一个元素完全透明，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的\ndisplay: none;元素会变得不可见，并且不会再占用元素位置。会改变页面布局。\ntransform: scale(0);将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留。\n\n## 4、 防抖和节流★★★★★\n\n本质上是优化高频率执行代码的一种手段\n\n如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能\n\n为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（防抖）和debounce（节流）的方式来减少调用频率\n\n定义：\n\n**节流**: **n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效**\n**防抖**: **n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时**\n一个经典的比喻:\n\n想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应\n\n假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制\n\n电梯第一个人进来后，15秒后准时运送一次，这是节流。\n\n电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖。\n\n防抖应用场景\n\n搜索框搜索输入。只需用户最后一次输入完，再发送请求\n手机号、邮箱验证输入检测 onchange / oninput事件\n窗口大小计算。只需窗口调整完成后，计算窗口大小。防止重复渲染。\n节流应用场景\n\n懒加载、滚动加载、加载更多或监听滚动条位置；\n百度搜索框，搜索联想功能；\n防止高频点击提交，防止表单重复提交；\n\n## 5、==和=== 的区别?\n\n==（相等操作符）：比较时会进行类型转换，尝试将两个操作数转换为相同的类型，然后进行值的比较。如果操作数的类型不同，会进行类型转换后再比较。这种比较方式被称为弱类型相等比较。\n\n===（严格相等操作符）：比较时不进行类型转换，仅当两个操作数的类型相同且值相等时，返回true。这种比较方式要求比较的操作数类型和值都要相同。\n\n==，当且仅当两个运算数相等时，它返回 true，即不检查数据类型\n===，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型\n\n## 6、JS 数据类型 ?\n\n数据类型主要包括两部分：\n\n基本数据类型： Undefined、Null、Boolean、Number 和 String\n引用数据类型： Object (包括 Object 、Array 、Function)\nECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )\n\n## 7、null 和 undefined 的区别？\n\nnull 表示一个对象被定义了，值为“空值”；**无对象**\nundefined 表示不存在这个值。**无值**\n（1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。\n\nnull 和 undefined 区别\n\n首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型\n分别都只有一个值，就是 undefined 和 null。\nundefined 代表的含义是未定义，null 代表的含义是空对象。一般\n变量声明了但还没有定义的时候会返回 undefined，null 主要用于\n赋值给一些可能会返回对象的变量，作为初始化。\n\n## 8、★★★★★ promise理解、手写promise\n\nPromise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，避免了地狱回调\nPromise有三种状态： pending(等待态)，fulfilled(成功态)，rejected(失败态) ；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。\nPromise拥有一个then方法，用以处理resolved或rejected状态下的值\nthen方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。\nthen方法返回一个新的Promise对象，因此可以通过链式调用then方法\n\nPromise 是异步编程的一种解决方案，它是一个对象，可以获取异步\n操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，\n它比传统的解决方案回调函数和事件更合理和更强大。\n所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束\n的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一\n个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，\n各种异步操作都可以用同样的方法进行处理。\n（1）Promise 的实例有三个状态:\nPending（进行中）\nResolved（已完成）\nRejected（已拒绝）\n当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了\n状态就变成了 Resolved、没有完成失败了就变成了 Rejected。\n（2）Promise 的实例有两个过程：\npending -> fulfilled : Resolved（已完成）\npending -> rejected：Rejected（已拒绝）\n注意：一旦从进行状态变成为其他状态就永远不能更改状态了。\n\n## 9、async await函数★★★★★\n\nasync/await函数是异步代码的新方式\nasync/await是基于promise实现的\nasync/await使异步代码更像同步代码\nawait 只能在async函数中使用，不能再普通函数中使用，要成对出现\n默认返回一个promise实例，不能被改变\nawait下面的代码是异步，后面的代码是同步的\n\n### 10、异步编程的实现方式？\n\n回调函数\n\n使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。\nPromise\n\n### 使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。\n\nasync 函数\n\nasync 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。\n\n## 箭头函数与普通函数的区别？\n\n### 1、箭头函数比普通函数更加简洁\n\n如果没有参数，就直接写一个空括号即可\n\n如果只有一个参数，可以省去参数的括号\n\n如果有多个参数，用逗号分割\n\n如果函数体的返回值只有一句，可以省略大括号\n\n### 2. 箭头函数没有自己的this\n\n箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。\n\n### 3. 箭头函数继承来的this指向永远不会改变\n\n```js\nvar id = 'GLOBAL';\nvar obj = {\n  id: 'OBJ',\n  a: function(){\n    console.log(this.id);\n  },\n  b: () => {\n    console.log(this.id);\n  }\n};\nobj.a();    // 'OBJ'\nobj.b();    // 'GLOBAL'\nnew obj.a()  // undefined\nnew obj.b()  // Uncaught TypeError: obj.b is not a constructor\n```\n\n对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号**{ }**是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。\n\n### 4. call()、apply()、bind()等方法不能改变箭头函数中this的指向\n\n```js\nvar id = 'Global';\nlet fun1 = () => {\n    console.log(this.id)\n};\nfun1();                     // 'Global'\nfun1.call({id: 'Obj'});     // 'Global'\nfun1.apply({id: 'Obj'});    // 'Global'\nfun1.bind({id: 'Obj'})();   // 'Global'\n```\n\n### 5、箭头函数不能作为构造函数使用\n\n由于箭头函数时没有自己的this，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。\n\n### 6、箭头函数没有自己的arguments\n\n箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。\n\n### 7、箭头函数没有prototype\n\n### 8、箭头函数的this指向哪⾥？★★★★★\n\n箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。\n\n## 10、常见的DOM操作有哪些\n\nCreate：动态增加DOM 节点\n\nDelete：删除DOM 节点\n\nUpdate：更新DOM 节点的内容\n\nRead：获取DOM 节点\n\n1 Document.getElementById()\n\n2 Document.getElementsByTagName()\n\n3 Document.getElementsByClassName()\n\n4 Document.querySelector()\n\n5 Document.querySelectorAll()\n\n6 父节点Node.parentNode\n\n## 11、对this对象的理解\n\n##### this 关键字含义是什么？\n\n解答：this总是返回一个对象，**this就是属性或方法“当前”所在对象。\\**由于对象的属性可以赋值给另一个对象，所以属性所在的当前对象是可变的，即\\**this指向是可变的**。\n\n1.this是js 的一个关键字，随着函数的使用场合的不同，this 的值会发生变化。\n\n2.一个总原则：即this指的是调用函数的那个对象。\n\n3.一般情况下，this 是全局对象，可以作为方法调用。\n\n## 12、 call、apply 及 bind 函数 ★★★★★\n\n**call()、apply()、bind()都是用于改变this指向的方法，不同点传参方式不太相同以及返回不同。**\n\n* call( ) 是接收一个及其以上的参数，第一个参数表示this要指向的对象，其余参数表示调用函数需要传入的参数，返回调用函数的返回结果，属于立即执行函数；\n* apply( ) 是接收两个参数，第一个参数表示this要指向的对象，第二参数表示调用函数需要传入的参数所组成的数组，返回调用函数的返回结果，属于立即执行函数；\n* bind( ) 是接收一个及其以上的参数，和call(）一致，但是其返回是一个函数，而不是调用函数的返回结果；\n\n## 13 、**异步编程 ★★★★★**\n\n### 一、回调函数\n\n这是异步编程最基本的方法\n\n```js\nfunction asyncFn(callback) {\n    setTimeout(() => {\n        console.log('asyncFn');\n        callback();\n    }, 0)\n}\nfunction normalFn() {\n    console.log('normalFn');\n}\n\nasyncFn(normalFn);\n```\n\n- 缺点\n  - 容易出现回调地狱\n  - 当多个回调函数嵌套，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪\n  - 不能使用 try catch 不能直接return\n- 优点\n  - 简单、容易理解和实现\n\n### 二、事件触发模式\n\n另一种思路是采用事件驱动模式。即**异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。**\n比如一个我们注册一个按钮的点击事件或者注册一个自定义事件，然后通过点击或者trigger的方式触发这个事件。\n\n```js\nvar btn = document.getElementById('Button');\nbtn.onclick = function() {\n    console.log('展示异步操作');\n}\n```\n\n- 缺点\n  - 整个程序变成事件驱动型，运行流程不清晰\n- 优点\n  - 可以绑定多个事件，每个事件可以指定多个回调函数\n  - 可以“去耦合”，有利于实现模块化\n\n### 三、发布订阅\n\n发布/订阅模式，又称[观察者模式](https://so.csdn.net/so/search?q=观察者模式&spm=1001.2101.3001.7020)\n\n我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subcribe）这个信号，从而知道什么时候自己可以开始执行。\n\n```js\n//f2向信号中心Jquery订阅done信号\n\tjQuery.subscribe(\"done\", f2);\n\tfunction f1(){\n　　　　setTimeout(function () {\n　　　　　　// f1的任务代码\n\t\t   //发布done信号\n　　　　　　jQuery.publish(\"done\");\n　　　　}, 1000);\n　　}\n　　//f2执行完成后，取消订阅\n　　jQuery.unsubscribe(\"done\", f2);\n```\n\n发布/订阅，性质与“事件监听类似”，但是明显优于后者，因为我们可以通过查看”消息中心“，了解存在多少信号，多少个订阅者，从而监听程序的运行。\n\n### 四、Promises对象\n\nPromises对象是CommonJs工作提出的一种规范，目的是为了异步编程提供统一接口\n\n他的思想是每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数，比如f1的回调函数f2，可以写成：\n\n```js\nf1().then(f2);\n　\tfunction f1(){\n　\t\t//deferred对象就是jQuery的回调函数解决方案。\n　　　　var dfd = $.Deferred();\n　　　　setTimeout(function () {\n　　　　　　// f1的任务代码\n\t\t   //将dtd对象的执行状态从\"未完成\"改为\"已完成\"，从而触发done()方法\n　　　　　　dfd.resolve();\n　　　　}, 500);\n\t   //返回promise对象 \n\t   // deferred.promise()方法。它的作用是，在原来的deferred对象上返回另一个deferred对象，\n\t   //后者只开放与改变执行状态无关的方法（比如done()方法和fail()方法），\n\t   //屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），\n\t   //从而使得执行状态不能被改变。\n　　　　return dfd.promise;\n　　}\n \n\tf1().then(f2).then(f3); //指定多个回调函数\n\tf1().then(f2).fail(f3); //指定发生错误时的回调函数\n```\n\n### 五、生成器函数 Generator/yield\n\nGenerator函数是 ES6 提供的一种异步编程解决方案。\n\nyield表达式可以暂停函数执行，next方法用于恢复函数执行，这使得Generator函数非常适合将异步任务同步化。\nyield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n每个yield返回的是｛value:yield返回的值，done:true/false(执行状态)｝\n\n```js\nfunction *generatorDemo() {\n\t yield 'hello';\n\t yield 1 + 2;\n\t return 'ok';\n\t}\n\t \n\tvar demo = generatorDemo()\n\t \n\tdemo.next()  // { value: 'hello', done: false } \n\tdemo.next()  // { value: 3, done: false } \n\tdemo.next()  // { value: 'ok', done: ture } \n\tdemo.next()  // { value: undefined, done: ture }\n```\n\n六、async/await 函数的实现\nasync是“异步”的意思，而 await 是等待的意思。所以应该很好理解 async 用于申明一个 异步的function （实际上是asnyc function 对象）\n\nawait 用于等待一个异步任务执行完成的结果，并且await只等出现在 async 函数中\n\n一个函数如果加上 asnyc，那么该函数就会返回一个 Promise\n\n```js\nasync function async1() {\n  return \"1\"\n}\nconsole.log(async1()) // -> Promise {<resolved>: \"1\"}\n```\n\nasync函数返回的是一个 Promise 对象，可以使用 then 方法添加回调函数，async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n1.await命令后面返回的是 Promise 对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。\n\n## 14、seTimeout，Promise，Async/await的区别\n\n共同点\n\n```\n都是用来解决异步回调问题\n区别：\n```\n\n```\n1.setTimeout属于宏任务。\n```\n\n```\n2.Promise属于异步操作，只有当只有当.then(), resove(),.catch()等操作后才会进入微任务。\n```\n\n3.Async/await 在await之前都是异步操作，只有在await后才会进入微任务。\n也可以说如果函数体有一个await，async就一定会异步，没有的话就是同步。\n15、Promise理解\n（1）抽象描述：\n\n```\n①promise 是一门新的技术(ES6 规范)；\n\n②promise 是 js 中进行异步编程的新解决方案(旧方案是单纯使用回调函数)。\n```\n\n（2）具体描述：\n\n```\n①从语法上看：promise 是一个构造函数；\n\n②从功能上看：promise 对象用来封装一个异步操作并可以获取其成功或者失败的结果值。\n```\n\n## 15、async、await详解\n\nasync/awiat的使用规则:\n\n1. async 表示这是一个async函数， await只能用在async函数里面，不能单独使用\n2. async 返回的是一个Promise对象，await就是等待这个promise的返回结果后，再继续执行\n3. await 等待的是一个Promise对象，后面必须跟一个Promise对象，但是不必写then()，直接就可以得到返回值\n\n## 16、什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？\n\n[回调函数](https://so.csdn.net/so/search?q=回调函数&spm=1001.2101.3001.7020)：就是把一个函数当作一个函数的参数\n\n## 回调地狱：\n\n当[异步操作](https://so.csdn.net/so/search?q=异步操作&spm=1001.2101.3001.7020)想要有顺序时，只能在一个异步成功以后的回调函数里面嵌套另一个异步的操作，如果嵌套的层数过多就形成了回调地狱\n\n回调地狱的弊端：后期代码维护比较困难\n\n**async await  回调地狱的最终解决方法 （es7）**\n\n**原理：**实际上就是生成器函数的语法糖\n\n可以将异步嵌套的语法，改成像是同步一样。不需要嵌套，就可以有先后顺序\n\n# vue\n\n一、var、let、const的相同点\n\n二、var、let、const的不同\n\n区别一：var 存在变量提升 而 let 与 const 不存在变量提升\n\n区别二：var定义的变量可以声明多次，而let、const定义的变量只能声明\n\n区别三：var、let声明的变量可以再次赋值，而const声明的变量不能再次赋值\n\n## v-if和v-show的详解\n\nv-if:通过移除元素来实现元素的显示与隐藏，每次显示都会触发组件的mouted钩子函数。可以用来表面意义上的刷新组件\nv-show:通过设置元素的display属性来控制元素的显示与隐藏。elementui的弹窗组件就是利用v-show来控制显示与隐藏的。\n二.v-if和v-show的区别\n加载速度不同，v-show要比v-if快，实际项目中就是这样。\n原理不同。\n应用场景不同，v-if多用于需要刷新的组件。v-show多用于不需要刷新组件的显示与隐藏。\n组件内缓存子组件就是用的v-show。\n做项目优化的时候可以尽量使用v-show,具体看需求。\n\n## vue2和vue3的区别\n\n### 1、双向数据绑定原理不同\n\n**vue2**：[vue2](https://so.csdn.net/so/search?q=vue2&spm=1001.2101.3001.7020)的双向数据绑定是利用**ES5的一个APIObject.definePropert()** 对数据进行劫持，结合发布订阅模式的方式来实现的。\n\n**vue3**：[vue3](https://so.csdn.net/so/search?q=vue3&spm=1001.2101.3001.7020)中使用了**ES6的Proxy API**对数据代理。相比vue2.x，使用proxy的优势如下：\n\n* defineProperty只能监听某个属性，不能对全对象监听\n* 可以省去for in，闭包等内容来提升效率(直接绑定整个对象即可)\n* 可以监听数组，不用再去单独的对数组做特异性操作vue3.x可以检测到数组内部数据的变化。\n\n### 2、是否支持碎片\n\n**vue2**：vue2**不支持**碎片。\n\n**vue3**：vue3**支持碎片（Fragments）** ，就是说可以拥有多个根节点。\n\n### 3、API类型不同\n\n**vue2**：vue2使用**选项类型api**，选项型api在代码里分割了不同的属性：data,computed,methods等。\n\n**vue3**：vue3使用**合成型api**，新的合成型api能让我们使用方法来分割，相比于旧的api使用属性来分组，这样代码会更加简便和整洁。\n\n### 4、定义数据变量和方法不同\n\n**vue2**：vue2是把数据放入data中，在vue2中定义数据变量是**data(){}** ，创建的方法要在**methods:{}** 中。\n\n**vue3**：，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。使用以下三个步骤来建立反应性数据：\n\n* 从vue引入**reactive**；\n* 使用**reactive()** 方法来声明数据为响应性数据；\n* 使用setup()方法来返回我们的响应性数据，从而**template**可以获取这些响应性数据。\n\n### 5、生命周期钩子函数不同\n\n**vue2**：**vue2中的生命周期**：\n\n* beforeCreate 组件创建之前\n* created 组件创建之后\n* beforeMount 组价挂载到页面之前执行\n* mounted 组件挂载到页面之后执行\n* beforeUpdate 组件更新之前\n* updated 组件更新之后\n\n**vue3**：**vue3中的生命周期**：\n\n* setup 开始创建组件\n* onBeforeMount 组价挂载到页面之前执行\n* onMounted 组件挂载到页面之后执行\n* onBeforeUpdate 组件更新之前\n* onUpdated 组件更新之后\n\n而且vue3.x 生命周期在调用前需要先进行引入。除了这些钩子函数外，vue3.x还增加了onRenderTracked 和onRenderTriggered函数。\n\n### 6、父子传参不同\n\n**vue2**：父传子，用props,子传父用事件 Emitting Events。在vue2中，会**调用this\\$emit**然后传入事件名和对象。\n\n**vue3**：父传子，用props,子传父用事件 Emitting Events。在vue3中的setup()中的第二个参数content对象中就有emit，那么我们只要在setup()接收**第二个参数中使用分解对象法取出emit**就可以在setup方法中随意使用了。\n\n### 7、指令与插槽不同\n\n**vue2**：vue2中使用slot可以**直接使用slot**；v-for与v-if在vue2中优先级高的是**v-for指令**，而且不建议一起使用。\n\n**vue3**：vue3中必须使用**v-slot的形式**；vue3中v-for与v-if,只会把当前v-if当做v-for中的一个判断语句，**不会相互冲突**；vue3中移除keyCode作为v-on的修饰符，当然也不支持config.keyCodes；vue3中**移除v-on.native修饰符**；vue3中**移除过滤器filter**。\n\n### 8、main.js文件不同\n\n**vue2**：vue2中我们可以使用**pototype(原型)** 的形式去进行操作，引入的是**构造函数**。\n\n**vue3**：vue3中需要使用**结构**的形式进行操作，引入的是**工厂函数**；vue3中app组件中可以**没有根标签**。\n\n#### 拓展阅读\n\n### setup()函数特性\n\n* setup()函数接收两个参数：props、context(包含attrs、slots、emit)。\n* setup函数是处于生命周期beforeCreated和created俩个钩子函数之前。\n* 执行setup时，组件实例尚未被创建（在setup()内部，this不会是该活跃实例得引用，即不指向vue实例，Vue为了避免我们错误得使用，直接将setup函数中得this修改成了undefined）。\n* 与模板一起使用时，需要返回一个对象。\n* 因为setup函数中，props是响应式得，当传入新的prop时，它将会被更新，所以不能使用es6解构，因为它会消除prop得响应性，如需解构prop，可以通过使用setup函数中得toRefs来完成此操作。\n* 在setup()内使用响应式数据时，需要通过 .value 获取。\n* 从setup() 中返回得对象上得property 返回并可以在模板中被访问时，它将自动展开为内部值。不需要在模板中追加.value。\n* setup函数只能是同步的不能是异步的。\n\n### 1.vuex\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\n\n（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。\n主要包括以下几个模块：\n\n- **State =>** 基本数据，定义了应用状态的数据结构，可以在这里设置默认的初始状态。页面状态管理容器对象。集中存储 Vuecomponents 中 data对象的零散数据\n- **Getter =>** 从基本数据派生的数据，允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。\n- **Mutation =>** 是唯一更改 store 中状态的方法，且必须是同步函数。状态改变操作方法\n- **Actions =>** 像一个装饰器，包裹mutations，使之可以异步。用于提**交 mutation**，而不是直接变更状态，可以包含任意异步操作。操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。\n- **Module =>** 模块化Vuex，允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。\n\n### 为什么 Vuex 的 mutation 中不能做异步操作？\n\nVuex 中所有的状态更新的唯一途径都是 mutation，异步操作通过\nAction 来提交 mutation 实现，这样可以方便地跟踪每一个状态的\n变化，从而能够实现一些工具帮助更好地了解我们的应用。\n每个 mutation 执行完成后都会对应到一个新的状态变更，这样\ndevtools 就可以打个快照存下来，然后就可以实现 time-travel 了。\n如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，\n无法很好的进行状态的追踪，给调试带来困难。\n\n## 2、生命周期\n\nbeforeCreate\t组件实例被创建之初，组件的属性生效之前\ncreated\t组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用\nbeforeMount\t在挂载开始之前被调用：相关的 render 函数首次被调用\nmounted\tel 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子\nbeforeUpdate\t组件数据更新之前调用，发生在虚拟 DOM 打补丁之前\nupdated\t组件数据更新之后\nactivited\tkeep-alive 专属，组件被激活时调用\ndeadctivated\tkeep-alive 专属，组件被销毁时调用\nbeforeDestory\t组件销毁前调用\ndestoryed\t组件销毁后调用\n\n**beforeCreate** 在实例初始化之后，数据观测（data observe）和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。\n\n**created** 实例已经创建完成之后被调用。在这一步，实例已经完成以下的配置：数据观测（data observe ），属性和方法的运算，watch/event 事件回调。这里没有 $el，如果非要想与 DOM 进行交互，可以通过vm.$nextTick 来访问 DOM。\n\n**beforeMount** 在挂载开始之前被调用：相关的 render 函数首次被调用。\n\n**mounted** 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom节点。\n\n**beforeUpdate** 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁 （patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。（数据修改页面未修改）\n\n**updated** 发生在更新完成之后，当前阶段组件 Dom 已经完成更新。要注意的是避免在此期间更新数据，因为这个可能导致无限循环的更新，该钩子在服务器渲染期间不被调用。\n\n**beforeDestroy** 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行 善后收尾工作，比如清除定时器。\n\n**destroyed**  Vue实例销毁后调用。调用后，Vue实例指示的东西都会解绑定，所有的事件监听器会被移除，左右的子实例也会被销毁，该钩子在服务器端渲染不被调用。\n\n**activated keep-alive** 专属，组件被激活时调用\n\n## 3、Vue 组件间通信有哪几种方式？\n\nVue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。\n（1）props / $emit 适用 父子组件通信\n\n这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。\n（2）ref 与 $parent / $children适用 父子组件通信\n\nref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例\n$parent / $children：访问父 / 子实例\n（3）EventBus （$emit / $on）适用于 父子、隔代、兄弟组件通信\n\n这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。\n（4）$attrs/$listeners适用于 隔代组件通信\n\n$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=\"$attrs\" 传入内部组件。通常配合 inheritAttrs 选项一起使用。\n$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件\n（5）provide / inject适用于 隔代组件通信\n\n祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。\n（6）Vuex适用于 父子、隔代、兄弟组件通信\n\n### Vue组件通讯有哪些方式？\n\n1、props 和 $emit。父组件向子组件传递数据是通过props传递的，子组件传递给父组件是通过$emit触发事件来做到的。\n\n2、$parent 和 $children 获取单签组件的父组件和当前组件的子组件。\n\n3、$attrs 和 $listeners A -> B -> C。Vue2.4开始提供了$attrs和$listeners来解决这个问题。\n\n4、父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。（官方不推荐在实际业务中适用，但是写组件库时很常用。）\n\n5、$refs 获取组件实例。\n\n6、envetBus 兄弟组件数据传递，这种情况下可以使用事件总线的方式。\n\n7、vuex 状态管理\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\nVuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。\n\n## 4、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？\n\n### （1）hash 模式的实现原理\n\n早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：\nhttps://www.word.com#search\nhash 路由模式的实现主要是基于下面几个特性：\n\nURL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；\nhash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；\n可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；\n我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。\n\n### （2）history 模式的实现原理\n\nHTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。\n唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：\nwindow.history.pushState(null, null, path);\nwindow.history.replaceState(null, null, path);\nhistory 路由模式的实现主要基于存在下面几个特性：\n\npushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；\n我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；\nhistory.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。\n\n## 5、computed 和 watch 区分使用场景\n\n### computed：\n\n是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；\n\n### watch：\n\n更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；\n\n### 运用场景：\n\n当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；\n当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n\ncomputed： 是**计算属性**，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；\nwatch： 更多的是「**观察**」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；\n运用场景：\n当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；\n当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n\n## 6、v-if 和 v-show 有什么区别？\n\nv-if 是真正的条件渲染，会控制这个 DOM 节点的存在与否。因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：**如果在初始渲染时条件为假**，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n**v-show 就简单得多——不管初始条件是什么，元素总是会被渲染**，并且只是简单地基于 CSS 的 “display” 属性进行切换。\n当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。\n\n## 7、怎样理解 Vue 的单向数据流？\n\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。\n这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。\n额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。\n这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。\n子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。\n\n## 8、v-model 的原理？\n\n我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：\n\n* text 和 textarea 元素使用 value 属性和 input 事件；\n* checkbox 和 radio 使用 checked 属性和 change 事件\n* select 字段将 value 作为 prop 并将 change 作为事件。\n\n## 9、vue-router历史模式和hash模式的区别？\n\n**hash模式**：\nurl里面带有#号，开发中默认的就是hash模式，hash虽然出现在URL中，但是不会被包括在HTTP请求中，所以改变hash不会重新刷新页面\n\n路由的哈希模式就是利用了window.onhashchange事件，也就是url中的hash值（#号后面的值）如果有变化，就会自动调用hashchange的监听事件，在hashchange的监听事件内可以得到改变后的url，这样就能找到对应页面进行加载\n\n**历史模式**：\n利用了H5新增的pushState()、replaceState()方法。当这两个方法执行时，只能改变当前地址栏的URL，但是浏览器不会像后端发起请求，也不会触发popstate事件的执行。\n\n## 10、created和mounted的区别\n\n**created**：**在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成识图。**\n**mounted**：**在模板渲染成html后调用，通常初始化页面完成后，再对html的dom节点进行一些需要的操作**。\n\n## 11、v-[model]是如何实现的实现原理\n\n### 1. 作用在普通表单元素上\n\n- 动态绑定了 `input` 的 `value` 指向了 `message` 变量，并且在触发 `input` 事件的时候去动态把 `message` 设置为目标值\n- ### 作用在组件上\n\n  - 在自定义组件中，`v-model` 默认会利用名为 `value` 的 `prop` 和名为 `input` 的事件\n  - 本质是一个父子组件通信的语法糖，通过 prop 和 $emit 实现\n\n## 12、vue列表为什么加key\n\n* 1、性能优化\n* 2、diff算法节点比对\n* 3、key不能是index\n\n## 13路由的 hash 和 history 模式的区别\n\nVue-Router 有两种模式：hash 模式和 history 模式。默认的路由模\n式是 hash 模式。\n\nhash 模式是开发中默认的模式，它的 URL 带着一个#，例如：\nhttp://www.abc.com/#/vue，它的 hash 值就是#/vue。\n特点：hash 值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对\n后端完全没有影响。所以改变 hash 值，不会重新加载页面。这种模\n式的浏览器支持度很好，低版本的 IE 浏览器也支持这种模式。hash\n路由被称为是前端路由，已经成为 SPA（单页面应用）的标配。\n\n原理： hash 模式的主要原理就是 onhashchange()事件：\n\n![1709212160938](images/前端八股文/1709212160938.png)\n\n2. history 模式\n   简介： history 模式的 URL 中没有#，它使用的是传统的路由分发模\n   式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个\n   URL，然后做出相应的逻辑处理。\n   特 点 ： 当 使 用 history 模 式 时 ， URL 就 像 这 样 ：\n   http://abc.com/user/id。相比 hash 模式更加好看。但是，history\n   模式需要后台配置支持。如果后台没有正确配置，访问时会返回 404。\n   API： history api 可以分为两大部分，切换历史状态和修改历史状\n   态：\n   修 改 历 史 状 态 ： 包 括 了 HTML5 History Interface 中 新 增 的\n   pushState() 和 replaceState() 方法，这两个方法应用于浏览器的\n   历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修\n   改时，虽然修改了 url，但浏览器不会立即向后端发送请求。如果要\n   做到改变 url 但又不刷新页面的效果，就需要前端用上这两个 API。\n   切换历史状态： 包括 forward()、back()、go()三个方法，对应浏\n   览器的前进，后退，跳转操作。\n   虽然 history 模式丢弃了丑陋的#。但是，它也有自己的缺点，就是\n   在刷新页面的时候，如果没有相应的路由或资源，就会刷出 404 来。\n   如果想要切换到 history 模式，就要进行以下配置（后端也要进行配\n   置）：\n3. 两种模式对比\n   调用 history.pushState() 相比于直接修改 hash，存在以下优势:\n   pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而\n   hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的\n   URL；\n   pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把\n   记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动\n   作将记录添加到栈中；\n   pushState() 通过 stateObject 参数可以添加任意类型的数据到记\n   录中；而 hash 只可添加短字符串；\n   pushState() 可额外设置 title 属性供后续使用。\n   hash 模式下，仅 hash 符号之前的 url 会被包含在请求中，后端如果\n   没有做到对路由的全覆盖，也不会返回 404 错误；history 模式下，\n   前端的 url 必须和实际向后端发起请求的 url 一致，如果没有对用的\n   路由处理，将返回 404 错误。\n   hash 模式和 history 模式都有各自的优势和缺陷，还是要根据实际\n   情况选择性的使用。\n\n# 5、状态码\n\n常用的请求状态码\n\n### 500 内部服务器错误\n\nInternal Server Error 500内部服务器错误，服务器遇到未知无法解决的问题。\n\n一般情况下，出现500响应状态的原因有很多种，但是主要的是“程序代码和服务器配置”两个问题。相对于代码而言，就是对站点进行升级，网页改版，新增加了一些常用的插件。就比如WordPress插件的版本可能就需要更高版本的PHP才能兼容。\n\n而相对服务器而言的话，更多的是在系统版本升级导致，就比如最开始使用的是Windows Server 2003，后期想要升级2008、2012等版本的时候配置稍有不慎就会导致Internal Server Error 500。\n\n### 404 请求错误\n\nNot Found 404 错误请求，因发送的请求语法错误,服务器无法正常读取。\n\n相信绝大多数的人都见过404的状态码，当用户试图请求Web服务器上一个不存在的资源时，就会触发Not Found404。出现404状态码可能是链接失效导致，也有可能是URL拼写错误，还有可能是因为Web服务器将所请求的资源移到了其他的地方。一般的网站都会设置自定义页面以防链接失效所产生不良的影响。\n\n403 禁止访问\nForbidden 403 禁止访问，客户端没有权利访问所请求内容,服务器拒绝本次请求。\n\n### 状态码403通常代表客户端错误\n\n是指的服务器端有能力处理该请求，但是拒绝授权访问。这个状态码类似于401，但是进入该状态后不能再继续进行验证，该访问是长期禁止的，并且与应用逻辑密切相关，比如密码不正确等。\n\n### 400 错误请求\n\nBad Request 400 错误请求，因发送的请求语法错误,服务器无法正常读取。\n\n状态码400表示该语法无效，服务器无法理解该请求。客服端不应该在未经修改的情况下重复此请求。一般会因为前端提交数据的字段名称，或者是字段类型和后台的实体类不一致，导致无法封装。\n\n### 401 未经授权\n\nUnauthorized 401 未经授权，需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过。\n\n状态码401就是Web服务器认为，客户端发送的HTTP数据流浪是正确的，但是进入URL资源的时候需要身份验证，而客户端尚未提供相关的验证信息，或者是已提供但是没有通过验证。这也是通常所知的“HTTP基本验证”。\n\n### 200 请求成功\n\n200 OK 请求成功，表示已经请求成功，默认情况下的状态码为200的响应就可以被缓存了。\n\n不同请求方式对于请求成功的意义如下：\n\nGET: 已经取得资源，并将资源添加到响应的消息体中。\nHEAD: 响应的消息体为头部信息。\nPOST: 响应的消息体中包含此次请求的结果。\nTRACE: 响应的消息体中包含服务器接收到的请求信息。\n\nPUT 和 DELETE 的请求成功通常并不是响应200OK的状态码而是 204No Content 表示无内容(或者 201Created表示一个资源首次被创建成功)。\n\n### 206 部分内容\n\nPartial Content 206 部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码。\n\n状态码206表示服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。\n\n### 301 永久重定向\n\nMoved Permanently 301 永久移动，该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的Location:头字段里找到。\n\n尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用301，其他情况使用308 来替代301。\n\n### 302 临时重定向\n\nFound 302临时移动，该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的Location:头字段里找到。\n\n即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代，因为在这些场景下方法变换是明确禁止的。\n\n### 502 无效网关\n\nBad Gateway 502 网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应。\n\n### 404 请求错误\n\nNot Found 404 错误请求，因发送的请求语法错误,服务器无法正常读取。\n\n相信绝大多数的人都见过404的状态码，当用户试图请求Web服务器上一个不存在的资源时，就会触发Not Found404。出现404状态码可能是链接失效导致，也有可能是URL拼写错误，还有可能是因为Web服务器将所请求的资源移到了其他的地方。一般的网站都会设置自定义页面以防链接失效所产生不良的影响。\n\n### 403 禁止访问\n\nForbidden 403 禁止访问，客户端没有权利访问所请求内容,服务器拒绝本次请求。\n\n状态码403通常代表客户端错误，是指的服务器端有能力处理该请求，但是拒绝授权访问。这个状态码类似于401，但是进入该状态后不能再继续进行验证，该访问是长期禁止的，并且与应用逻辑密切相关，比如密码不正确等。\n\n### 400 错误请求\n\nBad Request 400 错误请求，因发送的请求语法错误,服务器无法正常读取。\n\n状态码400表示该语法无效，服务器无法理解该请求。客服端不应该在未经修改的情况下重复此请求。一般会因为前端提交数据的字段名称，或者是字段类型和后台的实体类不一致，导致无法封装。\n\n### 401 未经授权\n\nUnauthorized 401 未经授权，需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过。\n\n状态码401就是Web服务器认为，客户端发送的HTTP数据流浪是正确的，但是进入URL资源的时候需要身份验证，而客户端尚未提供相关的验证信息，或者是已提供但是没有通过验证。这也是通常所知的“HTTP基本验证”。\n\n### 200 请求成功\n\n200 OK 请求成功，表示已经请求成功，默认情况下的状态码为200的响应就可以被缓存了。\n\n不同请求方式对于请求成功的意义如下：\n\nGET: 已经取得资源，并将资源添加到响应的消息体中。\nHEAD: 响应的消息体为头部信息。\nPOST: 响应的消息体中包含此次请求的结果。\nTRACE: 响应的消息体中包含服务器接收到的请求信息。\n\nPUT 和 DELETE 的请求成功通常并不是响应200OK的状态码而是 204No Content 表示无内容(或者 201Created表示一个资源首次被创建成功)。\n\n### 206 部分内容\n\nPartial Content 206 部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码。\n\n状态码206表示服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。\n\n### 301 永久重定向\n\nMoved Permanently 301 永久移动，该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的Location:头字段里找到。\n\n尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用301，其他情况使用308 来替代301。\n\n### 302 临时重定向\n\nFound 302临时移动，该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的Location:头字段里找到。\n\n即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代，因为在这些场景下方法变换是明确禁止的。\n\n### 502 无效网关\n\nBad Gateway 502 网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应。\n\nbad gateway502代表您所访问的网站出了问题，因为502 Bad Gateway 服务器作为网关或者代理时，是为了完成访问下一个服务器，但该服务器返回了非法的应答。也许是暂时的，也许是永久的。建议大家稍等一下再从新访问试试。\n","slug":"前端八股文","published":1,"updated":"2024-03-22T11:46:03.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgyo002viou2ffuw33g0","content":"<h1 id=\"1、HTML\"><a href=\"#1、HTML\" class=\"headerlink\" title=\"1、HTML\"></a>1、HTML</h1><p><img src=\"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\" alt=\"1709997145390\"></p>\n<h2 id=\"1-你对-HTML-语义化的理解？★★★★★\"><a href=\"#1-你对-HTML-语义化的理解？★★★★★\" class=\"headerlink\" title=\"1.你对 HTML 语义化的理解？★★★★★\"></a>1.你对 HTML 语义化的理解？★★★★★</h2><ol>\n<li>html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、<a href=\"https://so.csdn.net/so/search?q=%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E&spm=1001.2101.3001.7020\">搜索引擎</a>解析；即使在没有样式 CSS 情况下也以    一种文档格式显示，并且是容易阅读的;</li>\n<li>搜索引擎的<a href=\"https://so.csdn.net/so/search?q=%E7%88%AC%E8%99%AB&spm=1001.2101.3001.7020\">爬虫</a>也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;</li>\n</ol>\n<h2 id=\"2、-title-与-alt-属性的区别是什么？\"><a href=\"#2、-title-与-alt-属性的区别是什么？\" class=\"headerlink\" title=\"2、 title 与 alt 属性的区别是什么？\"></a>2、 title 与 alt 属性的区别是什么？</h2><ol>\n<li>alt 是给搜索引擎识别，在图像无法显示时的替代文本；</li>\n<li>title 是关于元素的注释信息，主要是给用户解读。</li>\n<li>当鼠标放到文字或是图片上时有 title 文字显示。（因为 IE 不标准）在 IE 浏览器中 alt 起到了 title 的作用，变成文字提示。</li>\n</ol>\n<h2 id=\"3、href-与-src？\"><a href=\"#3、href-与-src？\" class=\"headerlink\" title=\"3、href 与 src？\"></a>3、href 与 src？</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。（目的不是为了引用资源，而是为了建立联系，让当前标签能够链接到目标地址。）<br>src source（缩写），指向外部资源的位置，指向的内容将会应用到文档中当前标签所在位置。<br>href与src的区别<br>1、请求资源类型不同：href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；<br>2、作用结果不同：href 用于在当前文档和引用资源之间确立联系；src 用于替换当前内容；<br>3、浏览器解析方式不同：当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。</p></blockquote>\n<p>src和href都是对外部资源的引用，区别如下：</p>\n<p>src: 表示对资源的引用，用在js脚本、img、frame等元素上，当浏览器解析到该元素时，会<strong>暂停</strong>其他资源的下载和处理，直到该资源加载、编译、执行完成，所以js脚本会放在页面的底部，而不是头部。</p>\n<p>href：表示超文本引用，指向一些网络资源，当浏览器识别它指向的文件时，就会<strong>并行</strong>下载资源，不会停止对当前文件的处理，用在a、link上</p>\n<h2 id=\"4、HTML5、CSS3-里面都新增了那些新特性？\"><a href=\"#4、HTML5、CSS3-里面都新增了那些新特性？\" class=\"headerlink\" title=\"4、HTML5、CSS3 里面都新增了那些新特性？\"></a>4、HTML5、CSS3 里面都新增了那些新特性？</h2><p>HTML5</p>\n<ul>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n新的语义标签<br>article 独立的内容。<br>aside 侧边栏。<br>header 头部。<br>nav 导航。<br>section 文档中的节。<br>footer 页脚。<br>画布(Canvas) API<br>地理(Geolocation) API<br>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage 的数据在浏览器关闭后自动删除<br>新的技术webworker, websocket, Geolocation<br>拖拽释放(Drag and drop) API<br>音频、视频API(audio,video)<br>表单控件，calendar、date、time、email、url、searc<br>CSS3</p>\n</li>\n<li><p>2d，3d变换<br>Transition, animation<br>媒体查询<br>新的单位（rem, vw，vh 等）<br>圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);&#x2F;&#x2F;旋转,缩放,定位,倾斜<br>rgba</p>\n</li>\n</ul>\n<h2 id=\"5、行内元素与块级元素\"><a href=\"#5、行内元素与块级元素\" class=\"headerlink\" title=\"5、行内元素与块级元素\"></a>5、行内元素与块级元素</h2><h3 id=\"块级元素：-独占一行，可以设置宽高，设置margin和padding都有效，代表如下：\"><a href=\"#块级元素：-独占一行，可以设置宽高，设置margin和padding都有效，代表如下：\" class=\"headerlink\" title=\"块级元素： 独占一行，可以设置宽高，设置margin和padding都有效，代表如下：\"></a>块级元素： 独占一行，可以设置宽高，设置margin和padding都有效，代表如下：</h3><p>div、p、h1…h6、table、tr、ol、li、ul</p>\n<h3 id=\"行内元素元素：-可以排成一行，设置宽高无效，对margin设置左右方向有效，而上下无效，padding设置都无效，代表如下：\"><a href=\"#行内元素元素：-可以排成一行，设置宽高无效，对margin设置左右方向有效，而上下无效，padding设置都无效，代表如下：\" class=\"headerlink\" title=\"行内元素元素： 可以排成一行，设置宽高无效，对margin设置左右方向有效，而上下无效，padding设置都无效，代表如下：\"></a>行内元素元素： 可以排成一行，设置宽高无效，对margin设置左右方向有效，而上下无效，padding设置都无效，代表如下：</h3><p>基本上都是文本标签</p>\n<p>span、img、b、strong、font、br、a</p>\n<h2 id=\"什么是BFC\"><a href=\"#什么是BFC\" class=\"headerlink\" title=\"什么是BFC?\"></a>什么是BFC?</h2><p>BFC全称是Block Formatting Context，意思就是块级格式化上下文。你可以把BFC看做一个容器，容器里边的元素不会影响到容器外部的元素。</p>\n<p>BFC有什么特性？<br>BFC是一个块级元素，块级元素在垂直方向上依次排列。</p>\n<p>BFC是一个独立的容器，内部元素不会影响容器外部的元素。</p>\n<p>属于同一个BFC的两个盒子，外边距margin会发生重叠，并且取最大外边距。</p>\n<p><a href=\"https://\"><a href=\"https://blog.csdn.net/guoao20000915/article/details/125685983?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170929193616777224499886%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170929193616777224499886&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125685983-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=bfc&spm=1018.2226.3001.4187\">面试官：什么是BFC？BFC有什么特性？如何创建BFC？BFC有什么作用？-CSDN博客</a></a></p>\n<p>解决当父级元素没有高度时，子级元素浮动会使父级元素高度塌陷的问题</p>\n<p>解决子级元素外边距会使父级元素塌陷的问题</p>\n<h1 id=\"2、CSS\"><a href=\"#2、CSS\" class=\"headerlink\" title=\"2、CSS\"></a>2、CSS</h1><h2 id=\"1、介绍一下-CSS-的盒子模型？★★★★★\"><a href=\"#1、介绍一下-CSS-的盒子模型？★★★★★\" class=\"headerlink\" title=\"1、介绍一下 CSS 的盒子模型？★★★★★\"></a>1、介绍一下 CSS 的盒子模型？★★★★★</h2><p>有两种， IE 盒子模型、W3C 盒子模型；<br>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>区 别： IE 的 content 部分把 border 和 padding 计算了进去;</p>\n<h2 id=\"2、css-选择器优先级？★★★★★\"><a href=\"#2、css-选择器优先级？★★★★★\" class=\"headerlink\" title=\"2、css 选择器优先级？★★★★★\"></a>2、css 选择器优先级？★★★★★</h2><p>!important &gt; 行内样式（比重1000）&gt; ID 选择器（比重100） &gt; 类选择器（比重10） &gt; 标签（比重1） &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p>\n<h2 id=\"3、垂直居中几种方式？★★★★★\"><a href=\"#3、垂直居中几种方式？★★★★★\" class=\"headerlink\" title=\"3、垂直居中几种方式？★★★★★\"></a>3、垂直居中几种方式？★★★★★</h2><p>单行文本: line-height &#x3D; height<br>图片: vertical-align: middle;<br>absolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);<br>flex: display:flex;margin</p>\n<ul>\n<li>1 使用flex布局<br>利用flex的alignItems:center垂直居中，justifycontent:center水平居中</li>\n<li>2 利用相对定位和绝对定位的margin:auto</li>\n<li>相对定位下，使用绝对定位将上下左右都设置为0，再设置margin:auto即可实现居中</li>\n<li>3 利用相对定位和绝对定位，再加上外边距和平移的配合<br>相对定位下，使用绝对定位，利用margin偏移外容器的50%，再利用translate平移回补自身宽高的50%即可</li>\n<li>4 利用textAlign和verticalAlign<br>利用textAlign:center实现行内元素的水平居中，再利用verticalAlign:middle实现行内元素的垂直居中，前提是要先加上伪元素并给设置高度为100%，用过elementUI的可以去看看其消息弹窗居中实现方式就是如此</li>\n</ul>\n<p><strong>四种方式：</strong></p>\n<p><strong>利用绝对定位</strong>，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.div &#123;\n        position: absolute;\n        width: 200px;height: 200px;\n         left: 50%;top: 50%;\n        transform: translate(-50%, -50%);\n        或&#x2F;&#x2F;margin-left:-50px;margin-top:-50px;\n      &#125;</code></pre>\n\n<p><strong>利用绝对定位</strong>，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于盒子有宽高的情况。</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.div &#123;\n        position: relative;\n        width: 200px;height: 200px;\n        left: 50%; top: 50%;\n       transfrom:trable(-50%,-50%)\n      &#125;</code></pre>\n\n<p>使用*<em>flex布局</em>***，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.div &#123;\n       &#x2F;&#x2F; width: 100%; &#x2F;&#x2F;height: 100%;\n        display: flex;\n        justify-content: center;\n        align-items:center;\n      &#125;</code></pre>\n\n<h2 id=\"4-flex布局的父级元素中有哪些常用属性。\"><a href=\"#4-flex布局的父级元素中有哪些常用属性。\" class=\"headerlink\" title=\"4.flex布局的父级元素中有哪些常用属性。\"></a>4.flex布局的父级元素中有哪些常用属性。</h2><p>答：</p>\n<p>flex-direction: 设置主轴的方向</p>\n<p>justify-content: 设置主轴上的子元素对齐方式</p>\n<p>flex-wrap: 设置子元素是否换行</p>\n<p>align-content: 设置侧轴上的子元素的排列方式(多行)</p>\n<p>align-items:  设置侧轴上的子元素排列方式 (单行)</p>\n<p>flex-flow: 复合属性, 相当于同时设置了 flex-direction 和 flex-wrap</p>\n<h2 id=\"5、var、let、const-区别？★★★★★\"><a href=\"#5、var、let、const-区别？★★★★★\" class=\"headerlink\" title=\"5、var、let、const 区别？★★★★★\"></a>5、var、let、const 区别？★★★★★</h2><p>var 存在变量提升。<br>let 只能在块级作用域内访问。<br>const 用来定义常量，必须初始化，不能修改（对象特殊）</p>\n<p>var 全局作用域 变量更新 重新声明 可以变量提升(<strong>将var变量放到第一行</strong>)</p>\n<p>let 块作用域  变量更新 不能重新声明</p>\n<p>const 块作用域  不能变量更新 不能重新声明</p>\n<p>var 初始化为undefined</p>\n<h2 id=\"6、1rem、1em、1vh、1px各自代表的含义？\"><a href=\"#6、1rem、1em、1vh、1px各自代表的含义？\" class=\"headerlink\" title=\"6、1rem、1em、1vh、1px各自代表的含义？\"></a>6、1rem、1em、1vh、1px各自代表的含义？</h2><p>rem<br>rem是全部的长度都相对于根元素元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。<br>em<br>子元素字体大小的em是相对于父元素字体大小<br>元素的width&#x2F;height&#x2F;padding&#x2F;margin用em的话是相对于该元素的font-size<br>vw&#x2F;vh<br>全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。<br>px<br>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。<br>一般电脑的分辨率有{19201024}等不同的分辨率<br>19201024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素</p>\n<h2 id=\"7、怎么解决浮动中塌陷的问题\"><a href=\"#7、怎么解决浮动中塌陷的问题\" class=\"headerlink\" title=\"7、怎么解决浮动中塌陷的问题\"></a>7、怎么解决浮动中塌陷的问题</h2><h3 id=\"第一种：开启BFC\"><a href=\"#第一种：开启BFC\" class=\"headerlink\" title=\"第一种：开启BFC\"></a>第一种：开启BFC</h3><p>根据W3C的标准，在页面中元素都有一个隐含的属性 Block Formatting Context,简称BFC，默认是关闭的；</p>\n<p>开启元素BFC后，元素将会具有以下特性：</p>\n<p>父元素的垂直外边距不会和子元素重叠<br>开启BFC的元素不会被浮动元素所覆盖<br>开启BFC的元素可以包含浮动元素<br>开启BFC的方法：。</p>\n<p>** overflow【常见，副作用最小】**</p>\n<p>overflow设置为非visible的值。推荐使用hidden（副作用最小）</p>\n<p>a) auto （溢出显示滚动条）</p>\n<p>b) scroll （默认就显示滚动条）</p>\n<p>c) hidden （溢出隐藏）[常用]</p>\n<p>注：但在IE6及以下的浏览器中不支持BFC，所以使用这种方式不兼容IE6。在IE6中有类似BFC的隐含属性 hasLayout，开启方式很多，推荐使用zoom:1</p>\n<h3 id=\"第二种：在浮动元素后添加元素，并设置其clear属性\"><a href=\"#第二种：在浮动元素后添加元素，并设置其clear属性\" class=\"headerlink\" title=\"第二种：在浮动元素后添加元素，并设置其clear属性\"></a>第二种：在浮动元素后添加元素，并设置其clear属性</h3><h3 id=\"第三种：br元素的clear属性\"><a href=\"#第三种：br元素的clear属性\" class=\"headerlink\" title=\"第三种：br元素的clear属性\"></a>第三种：br元素的clear属性</h3><p>br元素本身没有高度，所以也就不会存在IE低版本下最小高度问题。只需要在浮动元素下添加一句 :</p>\n<p>※第四种：after伪类【各大公司推荐】</p>\n<p>可以通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动，和第二种方法原理相同，可达到相同的效果，而且不会在页面中添加多余的div，这是最推荐的方式，几乎没有副作用</p>\n<h2 id=\"8、display-none和visibility-hidden的区别？\"><a href=\"#8、display-none和visibility-hidden的区别？\" class=\"headerlink\" title=\"8、display:none和visibility:hidden的区别？\"></a>8、display:none和visibility:hidden的区别？</h2><p>display:none：     隐藏元素,不占空间 继承属性</p>\n<p>visibility:hidden：隐藏元素,不占空间 继承属性</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。<br>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p></blockquote>\n<h2 id=\"9、position的值，-relative和absolute分别是相对于谁进行定位的？\"><a href=\"#9、position的值，-relative和absolute分别是相对于谁进行定位的？\" class=\"headerlink\" title=\"9、position的值， relative和absolute分别是相对于谁进行定位的？\"></a>9、position的值， relative和absolute分别是相对于谁进行定位的？</h2><p>relative:相对定位，相对于自己本身在正常文档流中的位置进行定位。<br>absolute:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。<br>fixed: （老版本IE不支持）生成绝对定位，相对于浏览器窗口或者frame进行定位。<br>static:默认值，没有定位，元素出现在正常的文档流中。<br>sticky:生成粘性定位的元素，容器的位置根据正常文档流计算得出。</p>\n<p>10、</p>\n<h2 id=\"10、画一条0-5px的直线？\"><a href=\"#10、画一条0-5px的直线？\" class=\"headerlink\" title=\"10、画一条0.5px的直线？\"></a>10、画一条0.5px的直线？</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>考查的是css3的transform</p></blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">height: 1px;\ntransform: scale(0.5);</code></pre>\n\n<h2 id=\"11、BFC-是什么？\"><a href=\"#11、BFC-是什么？\" class=\"headerlink\" title=\"11、BFC 是什么？\"></a>11、BFC 是什么？</h2><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。<br>可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。<br>只要元素满足下面任一条件即可触发 BFC 特性</p>\n<p>body 根元素<br>浮动元素：float 除 none 以外的值<br>绝对定位元素：position (absolute、fixed)<br>display 为 inline-block、table-cells、flex<br>overflow 除了 visible 以外的值 (hidden、auto、scroll)</p>\n<h2 id=\"8、前端常见的布局方式\"><a href=\"#8、前端常见的布局方式\" class=\"headerlink\" title=\"8、前端常见的布局方式\"></a>8、前端常见的布局方式</h2><h3 id=\"一、静态布局\"><a href=\"#一、静态布局\" class=\"headerlink\" title=\"一、静态布局\"></a>一、静态布局</h3><p>静态布局是最为原始的布局方式，没有什么技术性可言，往往是计算机行业刚刚入门的小白使用的布局方式。制作的网页上的元素尺寸一律以px为单位</p>\n<p>布局特点： 页面上的布局是按最初写代码时候的布局方式进行布局的，常规的pc网站是进行设置了宽度值进行布局的，不会随着pc端的屏幕的大小而变化。<br>优点: 这种布局方式不管是对资深的前端开发工程师还是刚入门的小白来说都是最简单的，最让人容易以接受、学习的，没有我们所说的兼容性的问题。这种布局方式大多用在门户网站和企业的官网上，这些官网的设备的尺寸是固定的，这种布局方式往往是最简单的方法。<br>缺点： 不会随着pc端的屏幕大小而变化。</p>\n<h3 id=\"二、弹性布局（flexbox）\"><a href=\"#二、弹性布局（flexbox）\" class=\"headerlink\" title=\"二、弹性布局（flexbox）\"></a>二、弹性布局（flexbox）</h3><p>弹性布局可以简便、完整、响应的实现各种页面上的布局。与静态不同的是，使用em或rem单位（lem&#x3D;16px，1rem&#x3D;10px）进行相对布局，相对使用百分比更加方便、灵活，相应同时支持浏览器的字体大小调整和缩放的等正常显示。<br>优点：<br>1.适应性强，在做多种不同的屏幕分辨率不同的界面是非常使用。<br>2.随意按照宽度、比例划分元素的宽高。<br>3.可以轻松的改变元素的显示顺序。<br>4.网页布局实现快捷，维护起来更加容易。<br>如果做移动端时，如果客户对细微的之处的要求不高，使用弹性布局进行制作是最好的选择，一份css+一份js调节font-size搞定。<br>缺点： 浏览器兼容性较差，只能兼容到IE9及以上。</p>\n<h3 id=\"三、自适应布局（bootstrap）\"><a href=\"#三、自适应布局（bootstrap）\" class=\"headerlink\" title=\"三、自适应布局（bootstrap）\"></a>三、自适应布局（bootstrap）</h3><p>自适应布局分别为不同屏幕不同分辨率定义布局，即是创建多个静态页面，每个静态页面对应一个屏幕分辨率的一个范围内。在改变不同的屏幕分辨率可以切换到不同的静态布局上，但是布局中的元素位置会发生改变，但是在每个静态布局中，页面中的元素不会随着窗口大小的调整发生变化。使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。<br>优点：<br>1.对网站的复杂程度兼容性更大；<br>2.对开发工程师来说制作的成本代价更低；<br>3.代码执行效果更高效；<br>4.测试时更加容易，运营相对更加精准。<br>缺点： 在现如今的移动端设计百花齐放的时期之下，同一个网站往往需要为不同的设备制作不同的页面，不但会增加开发成本，还会因为客户的需求改变时，可能会改动多套代码、流程相比较来说较繁琐。</p>\n<h3 id=\"四、流式布局（fluid）\"><a href=\"#四、流式布局（fluid）\" class=\"headerlink\" title=\"四、流式布局（fluid）\"></a>四、流式布局（fluid）</h3><p>流式布局的布局方式是页面的元素的宽度按照屏幕的分辨率进行适配的调整，但是整体布局不变，也称之为栅栏系统。使用%百分比定义宽度，高度大都是用px来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width&#x2F;min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。<br>缺点： 屏幕大小变化时，页面元素也随之变化但是布局不变。这就会因为如果屏幕太大或太小都会布局时元素无法正常显示。</p>\n<h3 id=\"五、响应式布局\"><a href=\"#五、响应式布局\" class=\"headerlink\" title=\"五、响应式布局\"></a>五、响应式布局</h3><p>响应式布局是css3增加的新布局方式，该布局方式2010年提出来的一个概念，说白了就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。响应式几乎成为优秀页面布局的标准。<br>设计方法： 媒体查询+流式布局。通常使用@media媒体查询，和网格系统配合相对布局单位进行布局，实际上说白了就是综合响应式等技术通过css给单一网页不同设备分辨率返回不式时的技术。<br>优点： 适应pc端和移动端，如果有足够的耐心，页面效果会很完美。<br>缺点：<br>1.只能适应主流的宽高；<br>2.如果匹配足够多的设备屏幕的大小，对于工程师来说工作量不小，设计更需要多个版本，工作量增大。</p>\n<h3 id=\"六、浮动布局\"><a href=\"#六、浮动布局\" class=\"headerlink\" title=\"六、浮动布局\"></a>六、浮动布局</h3><p>浮动布局进行调用浮动属性改变页面中元素的位置，浮动布局应该是目前各大网站用的最多的一种布局方式了，但是也特别复杂。浮动元素是脱离文档流的，但不脱离文本流。浮动元素有左浮动（float : left）和右浮动（float : right）两种</p>\n<p>优点： 兼容性比较好<br>缺点： 浮动带来的影响比较多，页面宽度不够的时候会影响布局。</p>\n<h3 id=\"七、定位布局\"><a href=\"#七、定位布局\" class=\"headerlink\" title=\"七、定位布局\"></a>七、定位布局</h3><p>定位布局时利用position属性控制页面元素设置一些不规则布局。</p>\n<h1 id=\"3、js\"><a href=\"#3、js\" class=\"headerlink\" title=\"3、js\"></a>3、js</h1><h2 id=\"什么是async？\"><a href=\"#什么是async？\" class=\"headerlink\" title=\"什么是async？\"></a>什么是async？</h2><p>async 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用 await 来表示异步。相较于 Generator，async 函数的改进在于下面四点：</p>\n<p>内置执行器。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，调用方式跟普通函数的调用一样<br>更好的语义。async 和 await 相较于 * 和 yield 更加语义化<br>更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise对象。而 async 函数的 await 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）<br>返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用</p>\n<h2 id=\"await是什么？\"><a href=\"#await是什么？\" class=\"headerlink\" title=\"await是什么？\"></a>await是什么？</h2><p>await意思是async wait(异步等待)。这个关键字只能在使用async定义的函数里面使用。任何async函数都会默认返回promise，并且这个promise解析的值都将会是这个函数的返回值，而async函数必须等到内部所有的 await 命令的 Promise 对象执行完，才会发生状态改变。</p>\n<p>打个比方，await是学生，async是校车，必须等人齐了再开车。</p>\n<p>就是说，必须等所有await 函数执行完毕后，才会告诉promise我成功了还是失败了，执行then或者catch</p>\n<h2 id=\"19、var-let-const-三者区别？\"><a href=\"#19、var-let-const-三者区别？\" class=\"headerlink\" title=\"19、var,let ,const 三者区别？\"></a>19、var,let ,const 三者区别？</h2><p>共同点：都是可以声明变量</p>\n<p>区别1：var具有变量提升的机制，let和const 没有变量提升机制，</p>\n<p>区别2：var可以多次声明同一个变量，let和const 不可以多次声明同一个变量，</p>\n<p>区别3：var和let声明的是常量，const声明常量，var和let声明的变量可以再一次赋值，而const 不可以再次赋值</p>\n<p>面试的时候会问const 一个对象，里面是a:1，我现在想打印console.log(obj.a)这个结果是1，我想改变a:2,打印的就是2因为里面的值不是const,从内存的角度看，一个对象里面修改了对量里面的属性值，那么再次打印会打印出新的值，</p>\n<p>什么是常量：常量是一个在程序执行过程中不能被改变或修改的固定值。它是被赋予一个固定值后就不能再改变的变量。理解成，不能被操作所修改的变量就是常量。用途：保护数据，可以提高程序的可读性、可维护性</p>\n<p>变量：变量是用于存储和表示数据的一种命名容器。它是程序中的一个基本概念，用于在内存中存储和操作数据。变量的值可以被修改和更新。</p>\n<p>区别4：var没有作用域，在ES6之后才出现的作用域块的概念，</p>\n<h3 id=\"null-和-undefined-区别\"><a href=\"#null-和-undefined-区别\" class=\"headerlink\" title=\"null 和 undefined 区别\"></a>null 和 undefined 区别</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型<br>分别都只有一个值，就是 undefined 和 null。<br>undefined 代表的含义是未定义，null 代表的含义是空对象。一般<br>变量声明了但还没有定义的时候会返回 undefined，null 主要用于<br>赋值给一些可能会返回对象的变量，作为初始化。</p>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个<br>变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域<br>查找，依次向上级作用域查找，直到访问到 window 对象就被终止，<br>这一层层的关系就是作用域链</p>\n<h3 id=\"1、深拷贝、浅拷贝（笔试题）★★★★★\"><a href=\"#1、深拷贝、浅拷贝（笔试题）★★★★★\" class=\"headerlink\" title=\"1、深拷贝、浅拷贝（笔试题）★★★★★\"></a><strong>1、深拷贝、浅拷贝（笔试题）★★★★★</strong></h3><p>【{},[]】</p>\n<ul>\n<li>浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个<strong>地址</strong>，修改时原对象也会受到影响<ul>\n<li>Object.assign</li>\n<li>展开运算符 …</li>\n</ul>\n</li>\n<li>深拷贝: 完全拷贝一个新<strong>对象</strong>，修改时原对象不再受到任何影响</li>\n</ul>\n<h2 id=\"2、作用域、作用域链\"><a href=\"#2、作用域、作用域链\" class=\"headerlink\" title=\"2、作用域、作用域链\"></a>2、作用域、作用域链</h2><p>作用域：变量和函数起作用的范围。</p>\n<p>作用域链：是js查找方式，决定的变量和函数向上查找的范围。</p>\n<p>作用域是可访问的变量的<br>集合。在JavaScript中，作用域为可访问变量，对象，函数的集合，它分为局部作用域和全局作用域。作用域决定了这些变量的可访问性（可见性）。</p>\n<p>作用域链</p>\n<p>我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含<br>父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p>\n<p>它由两部分组成:<br>[[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO<br>AO: 自身活动对象<br>如此 [[scope]]包含[[scope]]，便自上而下形成一条 链式作用域。</p>\n<h2 id=\"1、闭包★★★★★\"><a href=\"#1、闭包★★★★★\" class=\"headerlink\" title=\"1、闭包★★★★★\"></a>1、闭包★★★★★</h2><h3 id=\"1、变量作用域\"><a href=\"#1、变量作用域\" class=\"headerlink\" title=\"1、变量作用域\"></a>1、变量作用域</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">要理解闭包，首先要理解 JavasSript 的特殊的变量作用域。</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">变量的作用域无非就两种：全局变量和局部变量。</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">JavasSript 语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局                    部变量。</code></pre>\n\n<p><strong>注意点：</strong>在函数内部声明变量的时候，一定要使用 var 命令。如果不用的话，你实际上声明的是一个全局变量！</p>\n<h3 id=\"2、如何从外部读取函数内部的局部变量？\"><a href=\"#2、如何从外部读取函数内部的局部变量？\" class=\"headerlink\" title=\"2、如何从外部读取函数内部的局部变量？\"></a>2、如何从外部读取函数内部的局部变量？</h3><p>出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。</p>\n<p>那就是在函数内部，再定义一个函数。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function f1()&#123;\n    var n&#x3D;999;\n    function f2()&#123;\n        alert(n); &#x2F;&#x2F; 999\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的代码中，函数 f2 就被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。</p>\n<p>这就是 JavasSript 语言特有的”链式作用域”结构（chain scope）</p>\n<h3 id=\"3、闭包的概念\"><a href=\"#3、闭包的概念\" class=\"headerlink\" title=\"3、闭包的概念\"></a>3、闭包的概念</h3><p>上面代码中的 f2 函数，就是闭包。</p>\n<p>各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。</p>\n<p>由于在 JavaScript 中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成”定义在一个函数内部的函数”。</p>\n<p>所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p>\n<p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数</p>\n<p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>\n<p>闭包有三个特性：</p>\n<p>1.函数嵌套函数</p>\n<p>2.函数内部可以引用外部的参数和变量</p>\n<p>3.参数和变量不会被垃圾回收机制回收</p>\n<h3 id=\"4、闭包的用途\"><a href=\"#4、闭包的用途\" class=\"headerlink\" title=\"4、闭包的用途\"></a>4、闭包的用途</h3><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在 f1 调用后被自动清除。</p>\n<p>为什么会这样呢？原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>\n<p>这段代码中另一个值得注意的地方，就是 “nAdd&#x3D;function(){n+&#x3D;1}” 这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量。其次，nAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。</p>\n<ul>\n<li>使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。</li>\n<li>闭包有三个特性：</li>\n<li>函数嵌套函数</li>\n<li>函数内部可以引用外部的参数和变量</li>\n<li>参数和变量不会被垃圾回收机制回收</li>\n</ul>\n<p>应用场景：</p>\n<ul>\n<li>设置私有变量的方法</li>\n<li>不适用场景：返回闭包的函数是个非常大的函数<br>闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏</li>\n</ul>\n<h3 id=\"5、使用闭包的注意点\"><a href=\"#5、使用闭包的注意点\" class=\"headerlink\" title=\"5、使用闭包的注意点\"></a>5、使用闭包的注意点</h3><p>（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值</p>\n<h2 id=\"2、-原型链★★★★★\"><a href=\"#2、-原型链★★★★★\" class=\"headerlink\" title=\"2、 原型链★★★★★\"></a>2、 原型链★★★★★</h2><p>那什么是原型链呢？</p>\n<p>简单理解就是原型组成的链，对象的__proto__它的是原型，而原型也是一个对象，也有__proto__属性，原型的__proto__又是原型的原型，就这样可以一直通过__proto__想上找，这就是原型链，当向上找找到Object的原型的时候，这条原型链就算到头了。</p>\n<p>原型对象和实例之间有什么作用呢？</p>\n<p>通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。</p>\n<p>在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法。</p>\n<h2 id=\"3、-请列举几种隐藏元素的方法\"><a href=\"#3、-请列举几种隐藏元素的方法\" class=\"headerlink\" title=\"3、 请列举几种隐藏元素的方法\"></a>3、 请列举几种隐藏元素的方法</h2><p>visibility: hidden;这个属性只是简单的隐藏某个元素，但是元素占用的空间仍然存在<br>opacity: 0; CSS3属性，设置0可以使一个元素完全透明，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的<br>display: none;元素会变得不可见，并且不会再占用元素位置。会改变页面布局。<br>transform: scale(0);将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留。</p>\n<h2 id=\"4、-防抖和节流★★★★★\"><a href=\"#4、-防抖和节流★★★★★\" class=\"headerlink\" title=\"4、 防抖和节流★★★★★\"></a>4、 防抖和节流★★★★★</h2><p>本质上是优化高频率执行代码的一种手段</p>\n<p>如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p>\n<p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（防抖）和debounce（节流）的方式来减少调用频率</p>\n<p>定义：</p>\n<p><strong>节流</strong>: <strong>n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</strong><br><strong>防抖</strong>: <strong>n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</strong><br>一个经典的比喻:</p>\n<p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应</p>\n<p>假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制</p>\n<p>电梯第一个人进来后，15秒后准时运送一次，这是节流。</p>\n<p>电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖。</p>\n<p>防抖应用场景</p>\n<p>搜索框搜索输入。只需用户最后一次输入完，再发送请求<br>手机号、邮箱验证输入检测 onchange &#x2F; oninput事件<br>窗口大小计算。只需窗口调整完成后，计算窗口大小。防止重复渲染。<br>节流应用场景</p>\n<p>懒加载、滚动加载、加载更多或监听滚动条位置；<br>百度搜索框，搜索联想功能；<br>防止高频点击提交，防止表单重复提交；</p>\n<h2 id=\"5、-和-的区别\"><a href=\"#5、-和-的区别\" class=\"headerlink\" title=\"5、&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D; 的区别?\"></a>5、&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D; 的区别?</h2><p>&#x3D;&#x3D;（相等操作符）：比较时会进行类型转换，尝试将两个操作数转换为相同的类型，然后进行值的比较。如果操作数的类型不同，会进行类型转换后再比较。这种比较方式被称为弱类型相等比较。</p>\n<p>&#x3D;&#x3D;&#x3D;（严格相等操作符）：比较时不进行类型转换，仅当两个操作数的类型相同且值相等时，返回true。这种比较方式要求比较的操作数类型和值都要相同。</p>\n<p>&#x3D;&#x3D;，当且仅当两个运算数相等时，它返回 true，即不检查数据类型<br>&#x3D;&#x3D;&#x3D;，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型</p>\n<h2 id=\"6、JS-数据类型\"><a href=\"#6、JS-数据类型\" class=\"headerlink\" title=\"6、JS 数据类型 ?\"></a>6、JS 数据类型 ?</h2><p>数据类型主要包括两部分：</p>\n<p>基本数据类型： Undefined、Null、Boolean、Number 和 String<br>引用数据类型： Object (包括 Object 、Array 、Function)<br>ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</p>\n<h2 id=\"7、null-和-undefined-的区别？\"><a href=\"#7、null-和-undefined-的区别？\" class=\"headerlink\" title=\"7、null 和 undefined 的区别？\"></a>7、null 和 undefined 的区别？</h2><p>null 表示一个对象被定义了，值为“空值”；<strong>无对象</strong><br>undefined 表示不存在这个值。<strong>无值</strong><br>（1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。</p>\n<p>null 和 undefined 区别</p>\n<p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型<br>分别都只有一个值，就是 undefined 和 null。<br>undefined 代表的含义是未定义，null 代表的含义是空对象。一般<br>变量声明了但还没有定义的时候会返回 undefined，null 主要用于<br>赋值给一些可能会返回对象的变量，作为初始化。</p>\n<h2 id=\"8、★★★★★-promise理解、手写promise\"><a href=\"#8、★★★★★-promise理解、手写promise\" class=\"headerlink\" title=\"8、★★★★★ promise理解、手写promise\"></a>8、★★★★★ promise理解、手写promise</h2><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，避免了地狱回调<br>Promise有三种状态： pending(等待态)，fulfilled(成功态)，rejected(失败态) ；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。<br>Promise拥有一个then方法，用以处理resolved或rejected状态下的值<br>then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。<br>then方法返回一个新的Promise对象，因此可以通过链式调用then方法</p>\n<p>Promise 是异步编程的一种解决方案，它是一个对象，可以获取异步<br>操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，<br>它比传统的解决方案回调函数和事件更合理和更强大。<br>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束<br>的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一<br>个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，<br>各种异步操作都可以用同样的方法进行处理。<br>（1）Promise 的实例有三个状态:<br>Pending（进行中）<br>Resolved（已完成）<br>Rejected（已拒绝）<br>当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了<br>状态就变成了 Resolved、没有完成失败了就变成了 Rejected。<br>（2）Promise 的实例有两个过程：<br>pending -&gt; fulfilled : Resolved（已完成）<br>pending -&gt; rejected：Rejected（已拒绝）<br>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p>\n<h2 id=\"9、async-await函数★★★★★\"><a href=\"#9、async-await函数★★★★★\" class=\"headerlink\" title=\"9、async await函数★★★★★\"></a>9、async await函数★★★★★</h2><p>async&#x2F;await函数是异步代码的新方式<br>async&#x2F;await是基于promise实现的<br>async&#x2F;await使异步代码更像同步代码<br>await 只能在async函数中使用，不能再普通函数中使用，要成对出现<br>默认返回一个promise实例，不能被改变<br>await下面的代码是异步，后面的代码是同步的</p>\n<h3 id=\"10、异步编程的实现方式？\"><a href=\"#10、异步编程的实现方式？\" class=\"headerlink\" title=\"10、异步编程的实现方式？\"></a>10、异步编程的实现方式？</h3><p>回调函数</p>\n<p>使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。<br>Promise</p>\n<h3 id=\"使用-Promise-的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个-then-的链式调用，可能会造成代码的语义不够明确。\"><a href=\"#使用-Promise-的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个-then-的链式调用，可能会造成代码的语义不够明确。\" class=\"headerlink\" title=\"使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。\"></a>使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</h3><p>async 函数</p>\n<p>async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</p>\n<h2 id=\"箭头函数与普通函数的区别？\"><a href=\"#箭头函数与普通函数的区别？\" class=\"headerlink\" title=\"箭头函数与普通函数的区别？\"></a>箭头函数与普通函数的区别？</h2><h3 id=\"1、箭头函数比普通函数更加简洁\"><a href=\"#1、箭头函数比普通函数更加简洁\" class=\"headerlink\" title=\"1、箭头函数比普通函数更加简洁\"></a>1、箭头函数比普通函数更加简洁</h3><p>如果没有参数，就直接写一个空括号即可</p>\n<p>如果只有一个参数，可以省去参数的括号</p>\n<p>如果有多个参数，用逗号分割</p>\n<p>如果函数体的返回值只有一句，可以省略大括号</p>\n<h3 id=\"2-箭头函数没有自己的this\"><a href=\"#2-箭头函数没有自己的this\" class=\"headerlink\" title=\"2. 箭头函数没有自己的this\"></a>2. 箭头函数没有自己的this</h3><p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p>\n<h3 id=\"3-箭头函数继承来的this指向永远不会改变\"><a href=\"#3-箭头函数继承来的this指向永远不会改变\" class=\"headerlink\" title=\"3. 箭头函数继承来的this指向永远不会改变\"></a>3. 箭头函数继承来的this指向永远不会改变</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var id &#x3D; &#39;GLOBAL&#39;;\nvar obj &#x3D; &#123;\n  id: &#39;OBJ&#39;,\n  a: function()&#123;\n    console.log(this.id);\n  &#125;,\n  b: () &#x3D;&gt; &#123;\n    console.log(this.id);\n  &#125;\n&#125;;\nobj.a();    &#x2F;&#x2F; &#39;OBJ&#39;\nobj.b();    &#x2F;&#x2F; &#39;GLOBAL&#39;\nnew obj.a()  &#x2F;&#x2F; undefined\nnew obj.b()  &#x2F;&#x2F; Uncaught TypeError: obj.b is not a constructor</code></pre>\n\n<p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号**{ }**是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p>\n<h3 id=\"4-call-、apply-、bind-等方法不能改变箭头函数中this的指向\"><a href=\"#4-call-、apply-、bind-等方法不能改变箭头函数中this的指向\" class=\"headerlink\" title=\"4. call()、apply()、bind()等方法不能改变箭头函数中this的指向\"></a>4. call()、apply()、bind()等方法不能改变箭头函数中this的指向</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var id &#x3D; &#39;Global&#39;;\nlet fun1 &#x3D; () &#x3D;&gt; &#123;\n    console.log(this.id)\n&#125;;\nfun1();                     &#x2F;&#x2F; &#39;Global&#39;\nfun1.call(&#123;id: &#39;Obj&#39;&#125;);     &#x2F;&#x2F; &#39;Global&#39;\nfun1.apply(&#123;id: &#39;Obj&#39;&#125;);    &#x2F;&#x2F; &#39;Global&#39;\nfun1.bind(&#123;id: &#39;Obj&#39;&#125;)();   &#x2F;&#x2F; &#39;Global&#39;</code></pre>\n\n<h3 id=\"5、箭头函数不能作为构造函数使用\"><a href=\"#5、箭头函数不能作为构造函数使用\" class=\"headerlink\" title=\"5、箭头函数不能作为构造函数使用\"></a>5、箭头函数不能作为构造函数使用</h3><p>由于箭头函数时没有自己的this，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p>\n<h3 id=\"6、箭头函数没有自己的arguments\"><a href=\"#6、箭头函数没有自己的arguments\" class=\"headerlink\" title=\"6、箭头函数没有自己的arguments\"></a>6、箭头函数没有自己的arguments</h3><p>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p>\n<h3 id=\"7、箭头函数没有prototype\"><a href=\"#7、箭头函数没有prototype\" class=\"headerlink\" title=\"7、箭头函数没有prototype\"></a>7、箭头函数没有prototype</h3><h3 id=\"8、箭头函数的this指向哪⾥？★★★★★\"><a href=\"#8、箭头函数的this指向哪⾥？★★★★★\" class=\"headerlink\" title=\"8、箭头函数的this指向哪⾥？★★★★★\"></a>8、箭头函数的this指向哪⾥？★★★★★</h3><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p>\n<h2 id=\"10、常见的DOM操作有哪些\"><a href=\"#10、常见的DOM操作有哪些\" class=\"headerlink\" title=\"10、常见的DOM操作有哪些\"></a>10、常见的DOM操作有哪些</h2><p>Create：动态增加DOM 节点</p>\n<p>Delete：删除DOM 节点</p>\n<p>Update：更新DOM 节点的内容</p>\n<p>Read：获取DOM 节点</p>\n<p>1 Document.getElementById()</p>\n<p>2 Document.getElementsByTagName()</p>\n<p>3 Document.getElementsByClassName()</p>\n<p>4 Document.querySelector()</p>\n<p>5 Document.querySelectorAll()</p>\n<p>6 父节点Node.parentNode</p>\n<h2 id=\"11、对this对象的理解\"><a href=\"#11、对this对象的理解\" class=\"headerlink\" title=\"11、对this对象的理解\"></a>11、对this对象的理解</h2><h5 id=\"this-关键字含义是什么？\"><a href=\"#this-关键字含义是什么？\" class=\"headerlink\" title=\"this 关键字含义是什么？\"></a>this 关键字含义是什么？</h5><p>解答：this总是返回一个对象，**this就是属性或方法“当前”所在对象。**由于对象的属性可以赋值给另一个对象，所以属性所在的当前对象是可变的，即**this指向是可变的**。</p>\n<p>1.this是js 的一个关键字，随着函数的使用场合的不同，this 的值会发生变化。</p>\n<p>2.一个总原则：即this指的是调用函数的那个对象。</p>\n<p>3.一般情况下，this 是全局对象，可以作为方法调用。</p>\n<h2 id=\"12、-call、apply-及-bind-函数-★★★★★\"><a href=\"#12、-call、apply-及-bind-函数-★★★★★\" class=\"headerlink\" title=\"12、 call、apply 及 bind 函数 ★★★★★\"></a>12、 call、apply 及 bind 函数 ★★★★★</h2><p><strong>call()、apply()、bind()都是用于改变this指向的方法，不同点传参方式不太相同以及返回不同。</strong></p>\n<ul>\n<li>call( ) 是接收一个及其以上的参数，第一个参数表示this要指向的对象，其余参数表示调用函数需要传入的参数，返回调用函数的返回结果，属于立即执行函数；</li>\n<li>apply( ) 是接收两个参数，第一个参数表示this要指向的对象，第二参数表示调用函数需要传入的参数所组成的数组，返回调用函数的返回结果，属于立即执行函数；</li>\n<li>bind( ) 是接收一个及其以上的参数，和call(）一致，但是其返回是一个函数，而不是调用函数的返回结果；</li>\n</ul>\n<h2 id=\"13-、异步编程-★★★★★\"><a href=\"#13-、异步编程-★★★★★\" class=\"headerlink\" title=\"13 、异步编程 ★★★★★\"></a>13 、<strong>异步编程 ★★★★★</strong></h2><h3 id=\"一、回调函数\"><a href=\"#一、回调函数\" class=\"headerlink\" title=\"一、回调函数\"></a>一、回调函数</h3><p>这是异步编程最基本的方法</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function asyncFn(callback) &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n        console.log(&#39;asyncFn&#39;);\n        callback();\n    &#125;, 0)\n&#125;\nfunction normalFn() &#123;\n    console.log(&#39;normalFn&#39;);\n&#125;\n\nasyncFn(normalFn);</code></pre>\n\n<ul>\n<li>缺点<ul>\n<li>容易出现回调地狱</li>\n<li>当多个回调函数嵌套，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪</li>\n<li>不能使用 try catch 不能直接return</li>\n</ul>\n</li>\n<li>优点<ul>\n<li>简单、容易理解和实现</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、事件触发模式\"><a href=\"#二、事件触发模式\" class=\"headerlink\" title=\"二、事件触发模式\"></a>二、事件触发模式</h3><p>另一种思路是采用事件驱动模式。即<strong>异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</strong><br>比如一个我们注册一个按钮的点击事件或者注册一个自定义事件，然后通过点击或者trigger的方式触发这个事件。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var btn &#x3D; document.getElementById(&#39;Button&#39;);\nbtn.onclick &#x3D; function() &#123;\n    console.log(&#39;展示异步操作&#39;);\n&#125;</code></pre>\n\n<ul>\n<li>缺点<ul>\n<li>整个程序变成事件驱动型，运行流程不清晰</li>\n</ul>\n</li>\n<li>优点<ul>\n<li>可以绑定多个事件，每个事件可以指定多个回调函数</li>\n<li>可以“去耦合”，有利于实现模块化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、发布订阅\"><a href=\"#三、发布订阅\" class=\"headerlink\" title=\"三、发布订阅\"></a>三、发布订阅</h3><p>发布&#x2F;订阅模式，又称<a href=\"https://so.csdn.net/so/search?q=%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020\">观察者模式</a></p>\n<p>我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subcribe）这个信号，从而知道什么时候自己可以开始执行。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;f2向信号中心Jquery订阅done信号\n\tjQuery.subscribe(&quot;done&quot;, f2);\n\tfunction f1()&#123;\n　　　　setTimeout(function () &#123;\n　　　　　　&#x2F;&#x2F; f1的任务代码\n\t\t   &#x2F;&#x2F;发布done信号\n　　　　　　jQuery.publish(&quot;done&quot;);\n　　　　&#125;, 1000);\n　　&#125;\n　　&#x2F;&#x2F;f2执行完成后，取消订阅\n　　jQuery.unsubscribe(&quot;done&quot;, f2);</code></pre>\n\n<p>发布&#x2F;订阅，性质与“事件监听类似”，但是明显优于后者，因为我们可以通过查看”消息中心“，了解存在多少信号，多少个订阅者，从而监听程序的运行。</p>\n<h3 id=\"四、Promises对象\"><a href=\"#四、Promises对象\" class=\"headerlink\" title=\"四、Promises对象\"></a>四、Promises对象</h3><p>Promises对象是CommonJs工作提出的一种规范，目的是为了异步编程提供统一接口</p>\n<p>他的思想是每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数，比如f1的回调函数f2，可以写成：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">f1().then(f2);\n　\tfunction f1()&#123;\n　\t\t&#x2F;&#x2F;deferred对象就是jQuery的回调函数解决方案。\n　　　　var dfd &#x3D; $.Deferred();\n　　　　setTimeout(function () &#123;\n　　　　　　&#x2F;&#x2F; f1的任务代码\n\t\t   &#x2F;&#x2F;将dtd对象的执行状态从&quot;未完成&quot;改为&quot;已完成&quot;，从而触发done()方法\n　　　　　　dfd.resolve();\n　　　　&#125;, 500);\n\t   &#x2F;&#x2F;返回promise对象 \n\t   &#x2F;&#x2F; deferred.promise()方法。它的作用是，在原来的deferred对象上返回另一个deferred对象，\n\t   &#x2F;&#x2F;后者只开放与改变执行状态无关的方法（比如done()方法和fail()方法），\n\t   &#x2F;&#x2F;屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），\n\t   &#x2F;&#x2F;从而使得执行状态不能被改变。\n　　　　return dfd.promise;\n　　&#125;\n \n\tf1().then(f2).then(f3); &#x2F;&#x2F;指定多个回调函数\n\tf1().then(f2).fail(f3); &#x2F;&#x2F;指定发生错误时的回调函数</code></pre>\n\n<h3 id=\"五、生成器函数-Generator-yield\"><a href=\"#五、生成器函数-Generator-yield\" class=\"headerlink\" title=\"五、生成器函数 Generator&#x2F;yield\"></a>五、生成器函数 Generator&#x2F;yield</h3><p>Generator函数是 ES6 提供的一种异步编程解决方案。</p>\n<p>yield表达式可以暂停函数执行，next方法用于恢复函数执行，这使得Generator函数非常适合将异步任务同步化。<br>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。<br>每个yield返回的是｛value:yield返回的值，done:true&#x2F;false(执行状态)｝</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function *generatorDemo() &#123;\n\t yield &#39;hello&#39;;\n\t yield 1 + 2;\n\t return &#39;ok&#39;;\n\t&#125;\n\t \n\tvar demo &#x3D; generatorDemo()\n\t \n\tdemo.next()  &#x2F;&#x2F; &#123; value: &#39;hello&#39;, done: false &#125; \n\tdemo.next()  &#x2F;&#x2F; &#123; value: 3, done: false &#125; \n\tdemo.next()  &#x2F;&#x2F; &#123; value: &#39;ok&#39;, done: ture &#125; \n\tdemo.next()  &#x2F;&#x2F; &#123; value: undefined, done: ture &#125;</code></pre>\n\n<p>六、async&#x2F;await 函数的实现<br>async是“异步”的意思，而 await 是等待的意思。所以应该很好理解 async 用于申明一个 异步的function （实际上是asnyc function 对象）</p>\n<p>await 用于等待一个异步任务执行完成的结果，并且await只等出现在 async 函数中</p>\n<p>一个函数如果加上 asnyc，那么该函数就会返回一个 Promise</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function async1() &#123;\n  return &quot;1&quot;\n&#125;\nconsole.log(async1()) &#x2F;&#x2F; -&gt; Promise &#123;&lt;resolved&gt;: &quot;1&quot;&#125;</code></pre>\n\n<p>async函数返回的是一个 Promise 对象，可以使用 then 方法添加回调函数，async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<br>1.await命令后面返回的是 Promise 对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。</p>\n<h2 id=\"14、seTimeout，Promise，Async-await的区别\"><a href=\"#14、seTimeout，Promise，Async-await的区别\" class=\"headerlink\" title=\"14、seTimeout，Promise，Async&#x2F;await的区别\"></a>14、seTimeout，Promise，Async&#x2F;await的区别</h2><p>共同点</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">都是用来解决异步回调问题\n区别：</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1.setTimeout属于宏任务。</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2.Promise属于异步操作，只有当只有当.then(), resove(),.catch()等操作后才会进入微任务。</code></pre>\n\n<p>3.Async&#x2F;await 在await之前都是异步操作，只有在await后才会进入微任务。<br>也可以说如果函数体有一个await，async就一定会异步，没有的话就是同步。<br>15、Promise理解<br>（1）抽象描述：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">①promise 是一门新的技术(ES6 规范)；\n\n②promise 是 js 中进行异步编程的新解决方案(旧方案是单纯使用回调函数)。</code></pre>\n\n<p>（2）具体描述：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">①从语法上看：promise 是一个构造函数；\n\n②从功能上看：promise 对象用来封装一个异步操作并可以获取其成功或者失败的结果值。</code></pre>\n\n<h2 id=\"15、async、await详解\"><a href=\"#15、async、await详解\" class=\"headerlink\" title=\"15、async、await详解\"></a>15、async、await详解</h2><p>async&#x2F;awiat的使用规则:</p>\n<ol>\n<li>async 表示这是一个async函数， await只能用在async函数里面，不能单独使用</li>\n<li>async 返回的是一个Promise对象，await就是等待这个promise的返回结果后，再继续执行</li>\n<li>await 等待的是一个Promise对象，后面必须跟一个Promise对象，但是不必写then()，直接就可以得到返回值</li>\n</ol>\n<h2 id=\"16、什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？\"><a href=\"#16、什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？\" class=\"headerlink\" title=\"16、什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？\"></a>16、什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</h2><p><a href=\"https://so.csdn.net/so/search?q=%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020\">回调函数</a>：就是把一个函数当作一个函数的参数</p>\n<h2 id=\"回调地狱：\"><a href=\"#回调地狱：\" class=\"headerlink\" title=\"回调地狱：\"></a>回调地狱：</h2><p>当<a href=\"https://so.csdn.net/so/search?q=%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C&spm=1001.2101.3001.7020\">异步操作</a>想要有顺序时，只能在一个异步成功以后的回调函数里面嵌套另一个异步的操作，如果嵌套的层数过多就形成了回调地狱</p>\n<p>回调地狱的弊端：后期代码维护比较困难</p>\n<p><strong>async await  回调地狱的最终解决方法 （es7）</strong></p>\n<p><strong>原理：</strong>实际上就是生成器函数的语法糖</p>\n<p>可以将异步嵌套的语法，改成像是同步一样。不需要嵌套，就可以有先后顺序</p>\n<h1 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a>vue</h1><p>一、var、let、const的相同点</p>\n<p>二、var、let、const的不同</p>\n<p>区别一：var 存在变量提升 而 let 与 const 不存在变量提升</p>\n<p>区别二：var定义的变量可以声明多次，而let、const定义的变量只能声明</p>\n<p>区别三：var、let声明的变量可以再次赋值，而const声明的变量不能再次赋值</p>\n<h2 id=\"v-if和v-show的详解\"><a href=\"#v-if和v-show的详解\" class=\"headerlink\" title=\"v-if和v-show的详解\"></a>v-if和v-show的详解</h2><p>v-if:通过移除元素来实现元素的显示与隐藏，每次显示都会触发组件的mouted钩子函数。可以用来表面意义上的刷新组件<br>v-show:通过设置元素的display属性来控制元素的显示与隐藏。elementui的弹窗组件就是利用v-show来控制显示与隐藏的。<br>二.v-if和v-show的区别<br>加载速度不同，v-show要比v-if快，实际项目中就是这样。<br>原理不同。<br>应用场景不同，v-if多用于需要刷新的组件。v-show多用于不需要刷新组件的显示与隐藏。<br>组件内缓存子组件就是用的v-show。<br>做项目优化的时候可以尽量使用v-show,具体看需求。</p>\n<h2 id=\"vue2和vue3的区别\"><a href=\"#vue2和vue3的区别\" class=\"headerlink\" title=\"vue2和vue3的区别\"></a>vue2和vue3的区别</h2><h3 id=\"1、双向数据绑定原理不同\"><a href=\"#1、双向数据绑定原理不同\" class=\"headerlink\" title=\"1、双向数据绑定原理不同\"></a>1、双向数据绑定原理不同</h3><p><strong>vue2</strong>：<a href=\"https://so.csdn.net/so/search?q=vue2&spm=1001.2101.3001.7020\">vue2</a>的双向数据绑定是利用<strong>ES5的一个APIObject.definePropert()</strong> 对数据进行劫持，结合发布订阅模式的方式来实现的。</p>\n<p><strong>vue3</strong>：<a href=\"https://so.csdn.net/so/search?q=vue3&spm=1001.2101.3001.7020\">vue3</a>中使用了<strong>ES6的Proxy API</strong>对数据代理。相比vue2.x，使用proxy的优势如下：</p>\n<ul>\n<li>defineProperty只能监听某个属性，不能对全对象监听</li>\n<li>可以省去for in，闭包等内容来提升效率(直接绑定整个对象即可)</li>\n<li>可以监听数组，不用再去单独的对数组做特异性操作vue3.x可以检测到数组内部数据的变化。</li>\n</ul>\n<h3 id=\"2、是否支持碎片\"><a href=\"#2、是否支持碎片\" class=\"headerlink\" title=\"2、是否支持碎片\"></a>2、是否支持碎片</h3><p><strong>vue2</strong>：vue2<strong>不支持</strong>碎片。</p>\n<p><strong>vue3</strong>：vue3<strong>支持碎片（Fragments）</strong> ，就是说可以拥有多个根节点。</p>\n<h3 id=\"3、API类型不同\"><a href=\"#3、API类型不同\" class=\"headerlink\" title=\"3、API类型不同\"></a>3、API类型不同</h3><p><strong>vue2</strong>：vue2使用<strong>选项类型api</strong>，选项型api在代码里分割了不同的属性：data,computed,methods等。</p>\n<p><strong>vue3</strong>：vue3使用<strong>合成型api</strong>，新的合成型api能让我们使用方法来分割，相比于旧的api使用属性来分组，这样代码会更加简便和整洁。</p>\n<h3 id=\"4、定义数据变量和方法不同\"><a href=\"#4、定义数据变量和方法不同\" class=\"headerlink\" title=\"4、定义数据变量和方法不同\"></a>4、定义数据变量和方法不同</h3><p><strong>vue2</strong>：vue2是把数据放入data中，在vue2中定义数据变量是<strong>data(){}</strong> ，创建的方法要在<strong>methods:{}</strong> 中。</p>\n<p><strong>vue3</strong>：，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。使用以下三个步骤来建立反应性数据：</p>\n<ul>\n<li>从vue引入<strong>reactive</strong>；</li>\n<li>使用<strong>reactive()</strong> 方法来声明数据为响应性数据；</li>\n<li>使用setup()方法来返回我们的响应性数据，从而<strong>template</strong>可以获取这些响应性数据。</li>\n</ul>\n<h3 id=\"5、生命周期钩子函数不同\"><a href=\"#5、生命周期钩子函数不同\" class=\"headerlink\" title=\"5、生命周期钩子函数不同\"></a>5、生命周期钩子函数不同</h3><p><strong>vue2</strong>：<strong>vue2中的生命周期</strong>：</p>\n<ul>\n<li>beforeCreate 组件创建之前</li>\n<li>created 组件创建之后</li>\n<li>beforeMount 组价挂载到页面之前执行</li>\n<li>mounted 组件挂载到页面之后执行</li>\n<li>beforeUpdate 组件更新之前</li>\n<li>updated 组件更新之后</li>\n</ul>\n<p><strong>vue3</strong>：<strong>vue3中的生命周期</strong>：</p>\n<ul>\n<li>setup 开始创建组件</li>\n<li>onBeforeMount 组价挂载到页面之前执行</li>\n<li>onMounted 组件挂载到页面之后执行</li>\n<li>onBeforeUpdate 组件更新之前</li>\n<li>onUpdated 组件更新之后</li>\n</ul>\n<p>而且vue3.x 生命周期在调用前需要先进行引入。除了这些钩子函数外，vue3.x还增加了onRenderTracked 和onRenderTriggered函数。</p>\n<h3 id=\"6、父子传参不同\"><a href=\"#6、父子传参不同\" class=\"headerlink\" title=\"6、父子传参不同\"></a>6、父子传参不同</h3><p><strong>vue2</strong>：父传子，用props,子传父用事件 Emitting Events。在vue2中，会<strong>调用this$emit</strong>然后传入事件名和对象。</p>\n<p><strong>vue3</strong>：父传子，用props,子传父用事件 Emitting Events。在vue3中的setup()中的第二个参数content对象中就有emit，那么我们只要在setup()接收<strong>第二个参数中使用分解对象法取出emit</strong>就可以在setup方法中随意使用了。</p>\n<h3 id=\"7、指令与插槽不同\"><a href=\"#7、指令与插槽不同\" class=\"headerlink\" title=\"7、指令与插槽不同\"></a>7、指令与插槽不同</h3><p><strong>vue2</strong>：vue2中使用slot可以<strong>直接使用slot</strong>；v-for与v-if在vue2中优先级高的是<strong>v-for指令</strong>，而且不建议一起使用。</p>\n<p><strong>vue3</strong>：vue3中必须使用<strong>v-slot的形式</strong>；vue3中v-for与v-if,只会把当前v-if当做v-for中的一个判断语句，<strong>不会相互冲突</strong>；vue3中移除keyCode作为v-on的修饰符，当然也不支持config.keyCodes；vue3中<strong>移除v-on.native修饰符</strong>；vue3中<strong>移除过滤器filter</strong>。</p>\n<h3 id=\"8、main-js文件不同\"><a href=\"#8、main-js文件不同\" class=\"headerlink\" title=\"8、main.js文件不同\"></a>8、main.js文件不同</h3><p><strong>vue2</strong>：vue2中我们可以使用<strong>pototype(原型)</strong> 的形式去进行操作，引入的是<strong>构造函数</strong>。</p>\n<p><strong>vue3</strong>：vue3中需要使用<strong>结构</strong>的形式进行操作，引入的是<strong>工厂函数</strong>；vue3中app组件中可以<strong>没有根标签</strong>。</p>\n<h4 id=\"拓展阅读\"><a href=\"#拓展阅读\" class=\"headerlink\" title=\"拓展阅读\"></a>拓展阅读</h4><h3 id=\"setup-函数特性\"><a href=\"#setup-函数特性\" class=\"headerlink\" title=\"setup()函数特性\"></a>setup()函数特性</h3><ul>\n<li>setup()函数接收两个参数：props、context(包含attrs、slots、emit)。</li>\n<li>setup函数是处于生命周期beforeCreated和created俩个钩子函数之前。</li>\n<li>执行setup时，组件实例尚未被创建（在setup()内部，this不会是该活跃实例得引用，即不指向vue实例，Vue为了避免我们错误得使用，直接将setup函数中得this修改成了undefined）。</li>\n<li>与模板一起使用时，需要返回一个对象。</li>\n<li>因为setup函数中，props是响应式得，当传入新的prop时，它将会被更新，所以不能使用es6解构，因为它会消除prop得响应性，如需解构prop，可以通过使用setup函数中得toRefs来完成此操作。</li>\n<li>在setup()内使用响应式数据时，需要通过 .value 获取。</li>\n<li>从setup() 中返回得对象上得property 返回并可以在模板中被访问时，它将自动展开为内部值。不需要在模板中追加.value。</li>\n<li>setup函数只能是同步的不能是异步的。</li>\n</ul>\n<h3 id=\"1-vuex\"><a href=\"#1-vuex\" class=\"headerlink\" title=\"1.vuex\"></a>1.vuex</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>\n<p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。<br>主要包括以下几个模块：</p>\n<ul>\n<li><strong>State &#x3D;&gt;</strong> 基本数据，定义了应用状态的数据结构，可以在这里设置默认的初始状态。页面状态管理容器对象。集中存储 Vuecomponents 中 data对象的零散数据</li>\n<li><strong>Getter &#x3D;&gt;</strong> 从基本数据派生的数据，允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。</li>\n<li><strong>Mutation &#x3D;&gt;</strong> 是唯一更改 store 中状态的方法，且必须是同步函数。状态改变操作方法</li>\n<li><strong>Actions &#x3D;&gt;</strong> 像一个装饰器，包裹mutations，使之可以异步。用于提<strong>交 mutation</strong>，而不是直接变更状态，可以包含任意异步操作。操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。</li>\n<li><strong>Module &#x3D;&gt;</strong> 模块化Vuex，允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li>\n</ul>\n<h3 id=\"为什么-Vuex-的-mutation-中不能做异步操作？\"><a href=\"#为什么-Vuex-的-mutation-中不能做异步操作？\" class=\"headerlink\" title=\"为什么 Vuex 的 mutation 中不能做异步操作？\"></a>为什么 Vuex 的 mutation 中不能做异步操作？</h3><p>Vuex 中所有的状态更新的唯一途径都是 mutation，异步操作通过<br>Action 来提交 mutation 实现，这样可以方便地跟踪每一个状态的<br>变化，从而能够实现一些工具帮助更好地了解我们的应用。<br>每个 mutation 执行完成后都会对应到一个新的状态变更，这样<br>devtools 就可以打个快照存下来，然后就可以实现 time-travel 了。<br>如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，<br>无法很好的进行状态的追踪，给调试带来困难。</p>\n<h2 id=\"2、生命周期\"><a href=\"#2、生命周期\" class=\"headerlink\" title=\"2、生命周期\"></a>2、生命周期</h2><p>beforeCreate\t组件实例被创建之初，组件的属性生效之前<br>created\t组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用<br>beforeMount\t在挂载开始之前被调用：相关的 render 函数首次被调用<br>mounted\tel 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子<br>beforeUpdate\t组件数据更新之前调用，发生在虚拟 DOM 打补丁之前<br>updated\t组件数据更新之后<br>activited\tkeep-alive 专属，组件被激活时调用<br>deadctivated\tkeep-alive 专属，组件被销毁时调用<br>beforeDestory\t组件销毁前调用<br>destoryed\t组件销毁后调用</p>\n<p><strong>beforeCreate</strong> 在实例初始化之后，数据观测（data observe）和 event&#x2F;watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。</p>\n<p><strong>created</strong> 实例已经创建完成之后被调用。在这一步，实例已经完成以下的配置：数据观测（data observe ），属性和方法的运算，watch&#x2F;event 事件回调。这里没有 $el，如果非要想与 DOM 进行交互，可以通过vm.$nextTick 来访问 DOM。</p>\n<p><strong>beforeMount</strong> 在挂载开始之前被调用：相关的 render 函数首次被调用。</p>\n<p><strong>mounted</strong> 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom节点。</p>\n<p><strong>beforeUpdate</strong> 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁 （patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。（数据修改页面未修改）</p>\n<p><strong>updated</strong> 发生在更新完成之后，当前阶段组件 Dom 已经完成更新。要注意的是避免在此期间更新数据，因为这个可能导致无限循环的更新，该钩子在服务器渲染期间不被调用。</p>\n<p><strong>beforeDestroy</strong> 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行 善后收尾工作，比如清除定时器。</p>\n<p><strong>destroyed</strong>  Vue实例销毁后调用。调用后，Vue实例指示的东西都会解绑定，所有的事件监听器会被移除，左右的子实例也会被销毁，该钩子在服务器端渲染不被调用。</p>\n<p><strong>activated keep-alive</strong> 专属，组件被激活时调用</p>\n<h2 id=\"3、Vue-组件间通信有哪几种方式？\"><a href=\"#3、Vue-组件间通信有哪几种方式？\" class=\"headerlink\" title=\"3、Vue 组件间通信有哪几种方式？\"></a>3、Vue 组件间通信有哪几种方式？</h2><p>Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。<br>（1）props &#x2F; $emit 适用 父子组件通信</p>\n<p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。<br>（2）ref 与 $parent &#x2F; $children适用 父子组件通信</p>\n<p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例<br>$parent &#x2F; $children：访问父 &#x2F; 子实例<br>（3）EventBus （$emit &#x2F; $on）适用于 父子、隔代、兄弟组件通信</p>\n<p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。<br>（4）$attrs&#x2F;$listeners适用于 隔代组件通信</p>\n<p>$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind&#x3D;”$attrs” 传入内部组件。通常配合 inheritAttrs 选项一起使用。<br>$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on&#x3D;”$listeners” 传入内部组件<br>（5）provide &#x2F; inject适用于 隔代组件通信</p>\n<p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide &#x2F; inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。<br>（6）Vuex适用于 父子、隔代、兄弟组件通信</p>\n<h3 id=\"Vue组件通讯有哪些方式？\"><a href=\"#Vue组件通讯有哪些方式？\" class=\"headerlink\" title=\"Vue组件通讯有哪些方式？\"></a>Vue组件通讯有哪些方式？</h3><p>1、props 和 $emit。父组件向子组件传递数据是通过props传递的，子组件传递给父组件是通过$emit触发事件来做到的。</p>\n<p>2、$parent 和 $children 获取单签组件的父组件和当前组件的子组件。</p>\n<p>3、$attrs 和 $listeners A -&gt; B -&gt; C。Vue2.4开始提供了$attrs和$listeners来解决这个问题。</p>\n<p>4、父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。（官方不推荐在实际业务中适用，但是写组件库时很常用。）</p>\n<p>5、$refs 获取组件实例。</p>\n<p>6、envetBus 兄弟组件数据传递，这种情况下可以使用事件总线的方式。</p>\n<p>7、vuex 状态管理</p>\n<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。<br>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p>\n<h2 id=\"4、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？\"><a href=\"#4、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？\" class=\"headerlink\" title=\"4、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？\"></a>4、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h2><h3 id=\"（1）hash-模式的实现原理\"><a href=\"#（1）hash-模式的实现原理\" class=\"headerlink\" title=\"（1）hash 模式的实现原理\"></a>（1）hash 模式的实现原理</h3><p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：<br><a href=\"https://www.word.com/#search\">https://www.word.com#search</a><br>hash 路由模式的实现主要是基于下面几个特性：</p>\n<p>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；<br>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；<br>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；<br>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</p>\n<h3 id=\"（2）history-模式的实现原理\"><a href=\"#（2）history-模式的实现原理\" class=\"headerlink\" title=\"（2）history 模式的实现原理\"></a>（2）history 模式的实现原理</h3><p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。<br>唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：<br>window.history.pushState(null, null, path);<br>window.history.replaceState(null, null, path);<br>history 路由模式的实现主要基于存在下面几个特性：</p>\n<p>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；<br>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；<br>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</p>\n<h2 id=\"5、computed-和-watch-区分使用场景\"><a href=\"#5、computed-和-watch-区分使用场景\" class=\"headerlink\" title=\"5、computed 和 watch 区分使用场景\"></a>5、computed 和 watch 区分使用场景</h2><h3 id=\"computed：\"><a href=\"#computed：\" class=\"headerlink\" title=\"computed：\"></a>computed：</h3><p>是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>\n<h3 id=\"watch：\"><a href=\"#watch：\" class=\"headerlink\" title=\"watch：\"></a>watch：</h3><p>更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>\n<h3 id=\"运用场景：\"><a href=\"#运用场景：\" class=\"headerlink\" title=\"运用场景：\"></a>运用场景：</h3><p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；<br>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>\n<p>computed： 是<strong>计算属性</strong>，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；<br>watch： 更多的是「<strong>观察</strong>」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；<br>运用场景：<br>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；<br>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>\n<h2 id=\"6、v-if-和-v-show-有什么区别？\"><a href=\"#6、v-if-和-v-show-有什么区别？\" class=\"headerlink\" title=\"6、v-if 和 v-show 有什么区别？\"></a>6、v-if 和 v-show 有什么区别？</h2><p>v-if 是真正的条件渲染，会控制这个 DOM 节点的存在与否。因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：<strong>如果在初始渲染时条件为假</strong>，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br><strong>v-show 就简单得多——不管初始条件是什么，元素总是会被渲染</strong>，并且只是简单地基于 CSS 的 “display” 属性进行切换。<br>当我们需要经常切换某个元素的显示&#x2F;隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p>\n<h2 id=\"7、怎样理解-Vue-的单向数据流？\"><a href=\"#7、怎样理解-Vue-的单向数据流？\" class=\"headerlink\" title=\"7、怎样理解 Vue 的单向数据流？\"></a>7、怎样理解 Vue 的单向数据流？</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。<br>这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。<br>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。<br>这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。<br>子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p>\n<h2 id=\"8、v-model-的原理？\"><a href=\"#8、v-model-的原理？\" class=\"headerlink\" title=\"8、v-model 的原理？\"></a>8、v-model 的原理？</h2><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>\n<ul>\n<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>\n<li>checkbox 和 radio 使用 checked 属性和 change 事件</li>\n<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>\n</ul>\n<h2 id=\"9、vue-router历史模式和hash模式的区别？\"><a href=\"#9、vue-router历史模式和hash模式的区别？\" class=\"headerlink\" title=\"9、vue-router历史模式和hash模式的区别？\"></a>9、vue-router历史模式和hash模式的区别？</h2><p><strong>hash模式</strong>：<br>url里面带有#号，开发中默认的就是hash模式，hash虽然出现在URL中，但是不会被包括在HTTP请求中，所以改变hash不会重新刷新页面</p>\n<p>路由的哈希模式就是利用了window.onhashchange事件，也就是url中的hash值（#号后面的值）如果有变化，就会自动调用hashchange的监听事件，在hashchange的监听事件内可以得到改变后的url，这样就能找到对应页面进行加载</p>\n<p><strong>历史模式</strong>：<br>利用了H5新增的pushState()、replaceState()方法。当这两个方法执行时，只能改变当前地址栏的URL，但是浏览器不会像后端发起请求，也不会触发popstate事件的执行。</p>\n<h2 id=\"10、created和mounted的区别\"><a href=\"#10、created和mounted的区别\" class=\"headerlink\" title=\"10、created和mounted的区别\"></a>10、created和mounted的区别</h2><p><strong>created</strong>：<strong>在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成识图。</strong><br><strong>mounted</strong>：<strong>在模板渲染成html后调用，通常初始化页面完成后，再对html的dom节点进行一些需要的操作</strong>。</p>\n<h2 id=\"11、v-model-是如何实现的实现原理\"><a href=\"#11、v-model-是如何实现的实现原理\" class=\"headerlink\" title=\"11、v-[model]是如何实现的实现原理\"></a>11、v-[model]是如何实现的实现原理</h2><h3 id=\"1-作用在普通表单元素上\"><a href=\"#1-作用在普通表单元素上\" class=\"headerlink\" title=\"1. 作用在普通表单元素上\"></a>1. 作用在普通表单元素上</h3><ul>\n<li>动态绑定了 <code>input</code> 的 <code>value</code> 指向了 <code>message</code> 变量，并且在触发 <code>input</code> 事件的时候去动态把 <code>message</code> 设置为目标值</li>\n<li><h3 id=\"作用在组件上\"><a href=\"#作用在组件上\" class=\"headerlink\" title=\"作用在组件上\"></a>作用在组件上</h3><ul>\n<li>在自定义组件中，<code>v-model</code> 默认会利用名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件</li>\n<li>本质是一个父子组件通信的语法糖，通过 prop 和 $emit 实现</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"12、vue列表为什么加key\"><a href=\"#12、vue列表为什么加key\" class=\"headerlink\" title=\"12、vue列表为什么加key\"></a>12、vue列表为什么加key</h2><ul>\n<li>1、性能优化</li>\n<li>2、diff算法节点比对</li>\n<li>3、key不能是index</li>\n</ul>\n<h2 id=\"13路由的-hash-和-history-模式的区别\"><a href=\"#13路由的-hash-和-history-模式的区别\" class=\"headerlink\" title=\"13路由的 hash 和 history 模式的区别\"></a>13路由的 hash 和 history 模式的区别</h2><p>Vue-Router 有两种模式：hash 模式和 history 模式。默认的路由模<br>式是 hash 模式。</p>\n<p>hash 模式是开发中默认的模式，它的 URL 带着一个#，例如：<br><a href=\"http://www.abc.com/#/vue%EF%BC%8C%E5%AE%83%E7%9A%84\">http://www.abc.com/#/vue，它的</a> hash 值就是#&#x2F;vue。<br>特点：hash 值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对<br>后端完全没有影响。所以改变 hash 值，不会重新加载页面。这种模<br>式的浏览器支持度很好，低版本的 IE 浏览器也支持这种模式。hash<br>路由被称为是前端路由，已经成为 SPA（单页面应用）的标配。</p>\n<p>原理： hash 模式的主要原理就是 onhashchange()事件：</p>\n<p><img src=\"/images/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/1709212160938.png\" alt=\"1709212160938\"></p>\n<ol start=\"2\">\n<li>history 模式<br>简介： history 模式的 URL 中没有#，它使用的是传统的路由分发模<br>式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个<br>URL，然后做出相应的逻辑处理。<br>特 点 ： 当 使 用 history 模 式 时 ， URL 就 像 这 样 ：<br><a href=\"http://abc.com/user/id%E3%80%82%E7%9B%B8%E6%AF%94\">http://abc.com/user/id。相比</a> hash 模式更加好看。但是，history<br>模式需要后台配置支持。如果后台没有正确配置，访问时会返回 404。<br>API： history api 可以分为两大部分，切换历史状态和修改历史状<br>态：<br>修 改 历 史 状 态 ： 包 括 了 HTML5 History Interface 中 新 增 的<br>pushState() 和 replaceState() 方法，这两个方法应用于浏览器的<br>历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修<br>改时，虽然修改了 url，但浏览器不会立即向后端发送请求。如果要<br>做到改变 url 但又不刷新页面的效果，就需要前端用上这两个 API。<br>切换历史状态： 包括 forward()、back()、go()三个方法，对应浏<br>览器的前进，后退，跳转操作。<br>虽然 history 模式丢弃了丑陋的#。但是，它也有自己的缺点，就是<br>在刷新页面的时候，如果没有相应的路由或资源，就会刷出 404 来。<br>如果想要切换到 history 模式，就要进行以下配置（后端也要进行配<br>置）：</li>\n<li>两种模式对比<br>调用 history.pushState() 相比于直接修改 hash，存在以下优势:<br>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而<br>hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的<br>URL；<br>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把<br>记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动<br>作将记录添加到栈中；<br>pushState() 通过 stateObject 参数可以添加任意类型的数据到记<br>录中；而 hash 只可添加短字符串；<br>pushState() 可额外设置 title 属性供后续使用。<br>hash 模式下，仅 hash 符号之前的 url 会被包含在请求中，后端如果<br>没有做到对路由的全覆盖，也不会返回 404 错误；history 模式下，<br>前端的 url 必须和实际向后端发起请求的 url 一致，如果没有对用的<br>路由处理，将返回 404 错误。<br>hash 模式和 history 模式都有各自的优势和缺陷，还是要根据实际<br>情况选择性的使用。</li>\n</ol>\n<h1 id=\"5、状态码\"><a href=\"#5、状态码\" class=\"headerlink\" title=\"5、状态码\"></a>5、状态码</h1><p>常用的请求状态码</p>\n<h3 id=\"500-内部服务器错误\"><a href=\"#500-内部服务器错误\" class=\"headerlink\" title=\"500 内部服务器错误\"></a>500 内部服务器错误</h3><p>Internal Server Error 500内部服务器错误，服务器遇到未知无法解决的问题。</p>\n<p>一般情况下，出现500响应状态的原因有很多种，但是主要的是“程序代码和服务器配置”两个问题。相对于代码而言，就是对站点进行升级，网页改版，新增加了一些常用的插件。就比如WordPress插件的版本可能就需要更高版本的PHP才能兼容。</p>\n<p>而相对服务器而言的话，更多的是在系统版本升级导致，就比如最开始使用的是Windows Server 2003，后期想要升级2008、2012等版本的时候配置稍有不慎就会导致Internal Server Error 500。</p>\n<h3 id=\"404-请求错误\"><a href=\"#404-请求错误\" class=\"headerlink\" title=\"404 请求错误\"></a>404 请求错误</h3><p>Not Found 404 错误请求，因发送的请求语法错误,服务器无法正常读取。</p>\n<p>相信绝大多数的人都见过404的状态码，当用户试图请求Web服务器上一个不存在的资源时，就会触发Not Found404。出现404状态码可能是链接失效导致，也有可能是URL拼写错误，还有可能是因为Web服务器将所请求的资源移到了其他的地方。一般的网站都会设置自定义页面以防链接失效所产生不良的影响。</p>\n<p>403 禁止访问<br>Forbidden 403 禁止访问，客户端没有权利访问所请求内容,服务器拒绝本次请求。</p>\n<h3 id=\"状态码403通常代表客户端错误\"><a href=\"#状态码403通常代表客户端错误\" class=\"headerlink\" title=\"状态码403通常代表客户端错误\"></a>状态码403通常代表客户端错误</h3><p>是指的服务器端有能力处理该请求，但是拒绝授权访问。这个状态码类似于401，但是进入该状态后不能再继续进行验证，该访问是长期禁止的，并且与应用逻辑密切相关，比如密码不正确等。</p>\n<h3 id=\"400-错误请求\"><a href=\"#400-错误请求\" class=\"headerlink\" title=\"400 错误请求\"></a>400 错误请求</h3><p>Bad Request 400 错误请求，因发送的请求语法错误,服务器无法正常读取。</p>\n<p>状态码400表示该语法无效，服务器无法理解该请求。客服端不应该在未经修改的情况下重复此请求。一般会因为前端提交数据的字段名称，或者是字段类型和后台的实体类不一致，导致无法封装。</p>\n<h3 id=\"401-未经授权\"><a href=\"#401-未经授权\" class=\"headerlink\" title=\"401 未经授权\"></a>401 未经授权</h3><p>Unauthorized 401 未经授权，需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过。</p>\n<p>状态码401就是Web服务器认为，客户端发送的HTTP数据流浪是正确的，但是进入URL资源的时候需要身份验证，而客户端尚未提供相关的验证信息，或者是已提供但是没有通过验证。这也是通常所知的“HTTP基本验证”。</p>\n<h3 id=\"200-请求成功\"><a href=\"#200-请求成功\" class=\"headerlink\" title=\"200 请求成功\"></a>200 请求成功</h3><p>200 OK 请求成功，表示已经请求成功，默认情况下的状态码为200的响应就可以被缓存了。</p>\n<p>不同请求方式对于请求成功的意义如下：</p>\n<p>GET: 已经取得资源，并将资源添加到响应的消息体中。<br>HEAD: 响应的消息体为头部信息。<br>POST: 响应的消息体中包含此次请求的结果。<br>TRACE: 响应的消息体中包含服务器接收到的请求信息。</p>\n<p>PUT 和 DELETE 的请求成功通常并不是响应200OK的状态码而是 204No Content 表示无内容(或者 201Created表示一个资源首次被创建成功)。</p>\n<h3 id=\"206-部分内容\"><a href=\"#206-部分内容\" class=\"headerlink\" title=\"206 部分内容\"></a>206 部分内容</h3><p>Partial Content 206 部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码。</p>\n<p>状态码206表示服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p>\n<h3 id=\"301-永久重定向\"><a href=\"#301-永久重定向\" class=\"headerlink\" title=\"301 永久重定向\"></a>301 永久重定向</h3><p>Moved Permanently 301 永久移动，该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的Location:头字段里找到。</p>\n<p>尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用301，其他情况使用308 来替代301。</p>\n<h3 id=\"302-临时重定向\"><a href=\"#302-临时重定向\" class=\"headerlink\" title=\"302 临时重定向\"></a>302 临时重定向</h3><p>Found 302临时移动，该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的Location:头字段里找到。</p>\n<p>即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代，因为在这些场景下方法变换是明确禁止的。</p>\n<h3 id=\"502-无效网关\"><a href=\"#502-无效网关\" class=\"headerlink\" title=\"502 无效网关\"></a>502 无效网关</h3><p>Bad Gateway 502 网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应。</p>\n<h3 id=\"404-请求错误-1\"><a href=\"#404-请求错误-1\" class=\"headerlink\" title=\"404 请求错误\"></a>404 请求错误</h3><p>Not Found 404 错误请求，因发送的请求语法错误,服务器无法正常读取。</p>\n<p>相信绝大多数的人都见过404的状态码，当用户试图请求Web服务器上一个不存在的资源时，就会触发Not Found404。出现404状态码可能是链接失效导致，也有可能是URL拼写错误，还有可能是因为Web服务器将所请求的资源移到了其他的地方。一般的网站都会设置自定义页面以防链接失效所产生不良的影响。</p>\n<h3 id=\"403-禁止访问\"><a href=\"#403-禁止访问\" class=\"headerlink\" title=\"403 禁止访问\"></a>403 禁止访问</h3><p>Forbidden 403 禁止访问，客户端没有权利访问所请求内容,服务器拒绝本次请求。</p>\n<p>状态码403通常代表客户端错误，是指的服务器端有能力处理该请求，但是拒绝授权访问。这个状态码类似于401，但是进入该状态后不能再继续进行验证，该访问是长期禁止的，并且与应用逻辑密切相关，比如密码不正确等。</p>\n<h3 id=\"400-错误请求-1\"><a href=\"#400-错误请求-1\" class=\"headerlink\" title=\"400 错误请求\"></a>400 错误请求</h3><p>Bad Request 400 错误请求，因发送的请求语法错误,服务器无法正常读取。</p>\n<p>状态码400表示该语法无效，服务器无法理解该请求。客服端不应该在未经修改的情况下重复此请求。一般会因为前端提交数据的字段名称，或者是字段类型和后台的实体类不一致，导致无法封装。</p>\n<h3 id=\"401-未经授权-1\"><a href=\"#401-未经授权-1\" class=\"headerlink\" title=\"401 未经授权\"></a>401 未经授权</h3><p>Unauthorized 401 未经授权，需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过。</p>\n<p>状态码401就是Web服务器认为，客户端发送的HTTP数据流浪是正确的，但是进入URL资源的时候需要身份验证，而客户端尚未提供相关的验证信息，或者是已提供但是没有通过验证。这也是通常所知的“HTTP基本验证”。</p>\n<h3 id=\"200-请求成功-1\"><a href=\"#200-请求成功-1\" class=\"headerlink\" title=\"200 请求成功\"></a>200 请求成功</h3><p>200 OK 请求成功，表示已经请求成功，默认情况下的状态码为200的响应就可以被缓存了。</p>\n<p>不同请求方式对于请求成功的意义如下：</p>\n<p>GET: 已经取得资源，并将资源添加到响应的消息体中。<br>HEAD: 响应的消息体为头部信息。<br>POST: 响应的消息体中包含此次请求的结果。<br>TRACE: 响应的消息体中包含服务器接收到的请求信息。</p>\n<p>PUT 和 DELETE 的请求成功通常并不是响应200OK的状态码而是 204No Content 表示无内容(或者 201Created表示一个资源首次被创建成功)。</p>\n<h3 id=\"206-部分内容-1\"><a href=\"#206-部分内容-1\" class=\"headerlink\" title=\"206 部分内容\"></a>206 部分内容</h3><p>Partial Content 206 部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码。</p>\n<p>状态码206表示服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p>\n<h3 id=\"301-永久重定向-1\"><a href=\"#301-永久重定向-1\" class=\"headerlink\" title=\"301 永久重定向\"></a>301 永久重定向</h3><p>Moved Permanently 301 永久移动，该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的Location:头字段里找到。</p>\n<p>尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用301，其他情况使用308 来替代301。</p>\n<h3 id=\"302-临时重定向-1\"><a href=\"#302-临时重定向-1\" class=\"headerlink\" title=\"302 临时重定向\"></a>302 临时重定向</h3><p>Found 302临时移动，该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的Location:头字段里找到。</p>\n<p>即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代，因为在这些场景下方法变换是明确禁止的。</p>\n<h3 id=\"502-无效网关-1\"><a href=\"#502-无效网关-1\" class=\"headerlink\" title=\"502 无效网关\"></a>502 无效网关</h3><p>Bad Gateway 502 网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应。</p>\n<p>bad gateway502代表您所访问的网站出了问题，因为502 Bad Gateway 服务器作为网关或者代理时，是为了完成访问下一个服务器，但该服务器返回了非法的应答。也许是暂时的，也许是永久的。建议大家稍等一下再从新访问试试。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1、HTML\"><a href=\"#1、HTML\" class=\"headerlink\" title=\"1、HTML\"></a>1、HTML</h1><p><img src=\"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\" alt=\"1709997145390\"></p>\n<h2 id=\"1-你对-HTML-语义化的理解？★★★★★\"><a href=\"#1-你对-HTML-语义化的理解？★★★★★\" class=\"headerlink\" title=\"1.你对 HTML 语义化的理解？★★★★★\"></a>1.你对 HTML 语义化的理解？★★★★★</h2><ol>\n<li>html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、<a href=\"https://so.csdn.net/so/search?q=%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E&spm=1001.2101.3001.7020\">搜索引擎</a>解析；即使在没有样式 CSS 情况下也以    一种文档格式显示，并且是容易阅读的;</li>\n<li>搜索引擎的<a href=\"https://so.csdn.net/so/search?q=%E7%88%AC%E8%99%AB&spm=1001.2101.3001.7020\">爬虫</a>也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;</li>\n</ol>\n<h2 id=\"2、-title-与-alt-属性的区别是什么？\"><a href=\"#2、-title-与-alt-属性的区别是什么？\" class=\"headerlink\" title=\"2、 title 与 alt 属性的区别是什么？\"></a>2、 title 与 alt 属性的区别是什么？</h2><ol>\n<li>alt 是给搜索引擎识别，在图像无法显示时的替代文本；</li>\n<li>title 是关于元素的注释信息，主要是给用户解读。</li>\n<li>当鼠标放到文字或是图片上时有 title 文字显示。（因为 IE 不标准）在 IE 浏览器中 alt 起到了 title 的作用，变成文字提示。</li>\n</ol>\n<h2 id=\"3、href-与-src？\"><a href=\"#3、href-与-src？\" class=\"headerlink\" title=\"3、href 与 src？\"></a>3、href 与 src？</h2><blockquote>\n<p>href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。（目的不是为了引用资源，而是为了建立联系，让当前标签能够链接到目标地址。）<br>src source（缩写），指向外部资源的位置，指向的内容将会应用到文档中当前标签所在位置。<br>href与src的区别<br>1、请求资源类型不同：href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；<br>2、作用结果不同：href 用于在当前文档和引用资源之间确立联系；src 用于替换当前内容；<br>3、浏览器解析方式不同：当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。</p>\n</blockquote>\n<p>src和href都是对外部资源的引用，区别如下：</p>\n<p>src: 表示对资源的引用，用在js脚本、img、frame等元素上，当浏览器解析到该元素时，会<strong>暂停</strong>其他资源的下载和处理，直到该资源加载、编译、执行完成，所以js脚本会放在页面的底部，而不是头部。</p>\n<p>href：表示超文本引用，指向一些网络资源，当浏览器识别它指向的文件时，就会<strong>并行</strong>下载资源，不会停止对当前文件的处理，用在a、link上</p>\n<h2 id=\"4、HTML5、CSS3-里面都新增了那些新特性？\"><a href=\"#4、HTML5、CSS3-里面都新增了那些新特性？\" class=\"headerlink\" title=\"4、HTML5、CSS3 里面都新增了那些新特性？\"></a>4、HTML5、CSS3 里面都新增了那些新特性？</h2><p>HTML5</p>\n<ul>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n新的语义标签<br>article 独立的内容。<br>aside 侧边栏。<br>header 头部。<br>nav 导航。<br>section 文档中的节。<br>footer 页脚。<br>画布(Canvas) API<br>地理(Geolocation) API<br>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage 的数据在浏览器关闭后自动删除<br>新的技术webworker, websocket, Geolocation<br>拖拽释放(Drag and drop) API<br>音频、视频API(audio,video)<br>表单控件，calendar、date、time、email、url、searc<br>CSS3</p>\n</li>\n<li><p>2d，3d变换<br>Transition, animation<br>媒体查询<br>新的单位（rem, vw，vh 等）<br>圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);&#x2F;&#x2F;旋转,缩放,定位,倾斜<br>rgba</p>\n</li>\n</ul>\n<h2 id=\"5、行内元素与块级元素\"><a href=\"#5、行内元素与块级元素\" class=\"headerlink\" title=\"5、行内元素与块级元素\"></a>5、行内元素与块级元素</h2><h3 id=\"块级元素：-独占一行，可以设置宽高，设置margin和padding都有效，代表如下：\"><a href=\"#块级元素：-独占一行，可以设置宽高，设置margin和padding都有效，代表如下：\" class=\"headerlink\" title=\"块级元素： 独占一行，可以设置宽高，设置margin和padding都有效，代表如下：\"></a>块级元素： 独占一行，可以设置宽高，设置margin和padding都有效，代表如下：</h3><p>div、p、h1…h6、table、tr、ol、li、ul</p>\n<h3 id=\"行内元素元素：-可以排成一行，设置宽高无效，对margin设置左右方向有效，而上下无效，padding设置都无效，代表如下：\"><a href=\"#行内元素元素：-可以排成一行，设置宽高无效，对margin设置左右方向有效，而上下无效，padding设置都无效，代表如下：\" class=\"headerlink\" title=\"行内元素元素： 可以排成一行，设置宽高无效，对margin设置左右方向有效，而上下无效，padding设置都无效，代表如下：\"></a>行内元素元素： 可以排成一行，设置宽高无效，对margin设置左右方向有效，而上下无效，padding设置都无效，代表如下：</h3><p>基本上都是文本标签</p>\n<p>span、img、b、strong、font、br、a</p>\n<h2 id=\"什么是BFC\"><a href=\"#什么是BFC\" class=\"headerlink\" title=\"什么是BFC?\"></a>什么是BFC?</h2><p>BFC全称是Block Formatting Context，意思就是块级格式化上下文。你可以把BFC看做一个容器，容器里边的元素不会影响到容器外部的元素。</p>\n<p>BFC有什么特性？<br>BFC是一个块级元素，块级元素在垂直方向上依次排列。</p>\n<p>BFC是一个独立的容器，内部元素不会影响容器外部的元素。</p>\n<p>属于同一个BFC的两个盒子，外边距margin会发生重叠，并且取最大外边距。</p>\n<p><a href=\"https://\"><a href=\"https://blog.csdn.net/guoao20000915/article/details/125685983?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170929193616777224499886%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170929193616777224499886&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125685983-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=bfc&spm=1018.2226.3001.4187\">面试官：什么是BFC？BFC有什么特性？如何创建BFC？BFC有什么作用？-CSDN博客</a></a></p>\n<p>解决当父级元素没有高度时，子级元素浮动会使父级元素高度塌陷的问题</p>\n<p>解决子级元素外边距会使父级元素塌陷的问题</p>\n<h1 id=\"2、CSS\"><a href=\"#2、CSS\" class=\"headerlink\" title=\"2、CSS\"></a>2、CSS</h1><h2 id=\"1、介绍一下-CSS-的盒子模型？★★★★★\"><a href=\"#1、介绍一下-CSS-的盒子模型？★★★★★\" class=\"headerlink\" title=\"1、介绍一下 CSS 的盒子模型？★★★★★\"></a>1、介绍一下 CSS 的盒子模型？★★★★★</h2><p>有两种， IE 盒子模型、W3C 盒子模型；<br>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>区 别： IE 的 content 部分把 border 和 padding 计算了进去;</p>\n<h2 id=\"2、css-选择器优先级？★★★★★\"><a href=\"#2、css-选择器优先级？★★★★★\" class=\"headerlink\" title=\"2、css 选择器优先级？★★★★★\"></a>2、css 选择器优先级？★★★★★</h2><p>!important &gt; 行内样式（比重1000）&gt; ID 选择器（比重100） &gt; 类选择器（比重10） &gt; 标签（比重1） &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p>\n<h2 id=\"3、垂直居中几种方式？★★★★★\"><a href=\"#3、垂直居中几种方式？★★★★★\" class=\"headerlink\" title=\"3、垂直居中几种方式？★★★★★\"></a>3、垂直居中几种方式？★★★★★</h2><p>单行文本: line-height &#x3D; height<br>图片: vertical-align: middle;<br>absolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);<br>flex: display:flex;margin</p>\n<ul>\n<li>1 使用flex布局<br>利用flex的alignItems:center垂直居中，justifycontent:center水平居中</li>\n<li>2 利用相对定位和绝对定位的margin:auto</li>\n<li>相对定位下，使用绝对定位将上下左右都设置为0，再设置margin:auto即可实现居中</li>\n<li>3 利用相对定位和绝对定位，再加上外边距和平移的配合<br>相对定位下，使用绝对定位，利用margin偏移外容器的50%，再利用translate平移回补自身宽高的50%即可</li>\n<li>4 利用textAlign和verticalAlign<br>利用textAlign:center实现行内元素的水平居中，再利用verticalAlign:middle实现行内元素的垂直居中，前提是要先加上伪元素并给设置高度为100%，用过elementUI的可以去看看其消息弹窗居中实现方式就是如此</li>\n</ul>\n<p><strong>四种方式：</strong></p>\n<p><strong>利用绝对定位</strong>，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.div &#123;\n        position: absolute;\n        width: 200px;height: 200px;\n         left: 50%;top: 50%;\n        transform: translate(-50%, -50%);\n        或&#x2F;&#x2F;margin-left:-50px;margin-top:-50px;\n      &#125;</code></pre>\n\n<p><strong>利用绝对定位</strong>，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于盒子有宽高的情况。</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.div &#123;\n        position: relative;\n        width: 200px;height: 200px;\n        left: 50%; top: 50%;\n       transfrom:trable(-50%,-50%)\n      &#125;</code></pre>\n\n<p>使用*<em>flex布局</em>***，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.div &#123;\n       &#x2F;&#x2F; width: 100%; &#x2F;&#x2F;height: 100%;\n        display: flex;\n        justify-content: center;\n        align-items:center;\n      &#125;</code></pre>\n\n<h2 id=\"4-flex布局的父级元素中有哪些常用属性。\"><a href=\"#4-flex布局的父级元素中有哪些常用属性。\" class=\"headerlink\" title=\"4.flex布局的父级元素中有哪些常用属性。\"></a>4.flex布局的父级元素中有哪些常用属性。</h2><p>答：</p>\n<p>flex-direction: 设置主轴的方向</p>\n<p>justify-content: 设置主轴上的子元素对齐方式</p>\n<p>flex-wrap: 设置子元素是否换行</p>\n<p>align-content: 设置侧轴上的子元素的排列方式(多行)</p>\n<p>align-items:  设置侧轴上的子元素排列方式 (单行)</p>\n<p>flex-flow: 复合属性, 相当于同时设置了 flex-direction 和 flex-wrap</p>\n<h2 id=\"5、var、let、const-区别？★★★★★\"><a href=\"#5、var、let、const-区别？★★★★★\" class=\"headerlink\" title=\"5、var、let、const 区别？★★★★★\"></a>5、var、let、const 区别？★★★★★</h2><p>var 存在变量提升。<br>let 只能在块级作用域内访问。<br>const 用来定义常量，必须初始化，不能修改（对象特殊）</p>\n<p>var 全局作用域 变量更新 重新声明 可以变量提升(<strong>将var变量放到第一行</strong>)</p>\n<p>let 块作用域  变量更新 不能重新声明</p>\n<p>const 块作用域  不能变量更新 不能重新声明</p>\n<p>var 初始化为undefined</p>\n<h2 id=\"6、1rem、1em、1vh、1px各自代表的含义？\"><a href=\"#6、1rem、1em、1vh、1px各自代表的含义？\" class=\"headerlink\" title=\"6、1rem、1em、1vh、1px各自代表的含义？\"></a>6、1rem、1em、1vh、1px各自代表的含义？</h2><p>rem<br>rem是全部的长度都相对于根元素元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。<br>em<br>子元素字体大小的em是相对于父元素字体大小<br>元素的width&#x2F;height&#x2F;padding&#x2F;margin用em的话是相对于该元素的font-size<br>vw&#x2F;vh<br>全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。<br>px<br>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。<br>一般电脑的分辨率有{19201024}等不同的分辨率<br>19201024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素</p>\n<h2 id=\"7、怎么解决浮动中塌陷的问题\"><a href=\"#7、怎么解决浮动中塌陷的问题\" class=\"headerlink\" title=\"7、怎么解决浮动中塌陷的问题\"></a>7、怎么解决浮动中塌陷的问题</h2><h3 id=\"第一种：开启BFC\"><a href=\"#第一种：开启BFC\" class=\"headerlink\" title=\"第一种：开启BFC\"></a>第一种：开启BFC</h3><p>根据W3C的标准，在页面中元素都有一个隐含的属性 Block Formatting Context,简称BFC，默认是关闭的；</p>\n<p>开启元素BFC后，元素将会具有以下特性：</p>\n<p>父元素的垂直外边距不会和子元素重叠<br>开启BFC的元素不会被浮动元素所覆盖<br>开启BFC的元素可以包含浮动元素<br>开启BFC的方法：。</p>\n<p>** overflow【常见，副作用最小】**</p>\n<p>overflow设置为非visible的值。推荐使用hidden（副作用最小）</p>\n<p>a) auto （溢出显示滚动条）</p>\n<p>b) scroll （默认就显示滚动条）</p>\n<p>c) hidden （溢出隐藏）[常用]</p>\n<p>注：但在IE6及以下的浏览器中不支持BFC，所以使用这种方式不兼容IE6。在IE6中有类似BFC的隐含属性 hasLayout，开启方式很多，推荐使用zoom:1</p>\n<h3 id=\"第二种：在浮动元素后添加元素，并设置其clear属性\"><a href=\"#第二种：在浮动元素后添加元素，并设置其clear属性\" class=\"headerlink\" title=\"第二种：在浮动元素后添加元素，并设置其clear属性\"></a>第二种：在浮动元素后添加元素，并设置其clear属性</h3><h3 id=\"第三种：br元素的clear属性\"><a href=\"#第三种：br元素的clear属性\" class=\"headerlink\" title=\"第三种：br元素的clear属性\"></a>第三种：br元素的clear属性</h3><p>br元素本身没有高度，所以也就不会存在IE低版本下最小高度问题。只需要在浮动元素下添加一句 :</p>\n<p>※第四种：after伪类【各大公司推荐】</p>\n<p>可以通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动，和第二种方法原理相同，可达到相同的效果，而且不会在页面中添加多余的div，这是最推荐的方式，几乎没有副作用</p>\n<h2 id=\"8、display-none和visibility-hidden的区别？\"><a href=\"#8、display-none和visibility-hidden的区别？\" class=\"headerlink\" title=\"8、display:none和visibility:hidden的区别？\"></a>8、display:none和visibility:hidden的区别？</h2><p>display:none：     隐藏元素,不占空间 继承属性</p>\n<p>visibility:hidden：隐藏元素,不占空间 继承属性</p>\n<blockquote>\n<p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。<br>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>\n</blockquote>\n<h2 id=\"9、position的值，-relative和absolute分别是相对于谁进行定位的？\"><a href=\"#9、position的值，-relative和absolute分别是相对于谁进行定位的？\" class=\"headerlink\" title=\"9、position的值， relative和absolute分别是相对于谁进行定位的？\"></a>9、position的值， relative和absolute分别是相对于谁进行定位的？</h2><p>relative:相对定位，相对于自己本身在正常文档流中的位置进行定位。<br>absolute:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。<br>fixed: （老版本IE不支持）生成绝对定位，相对于浏览器窗口或者frame进行定位。<br>static:默认值，没有定位，元素出现在正常的文档流中。<br>sticky:生成粘性定位的元素，容器的位置根据正常文档流计算得出。</p>\n<p>10、</p>\n<h2 id=\"10、画一条0-5px的直线？\"><a href=\"#10、画一条0-5px的直线？\" class=\"headerlink\" title=\"10、画一条0.5px的直线？\"></a>10、画一条0.5px的直线？</h2><blockquote>\n<p>考查的是css3的transform</p>\n</blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">height: 1px;\ntransform: scale(0.5);</code></pre>\n\n<h2 id=\"11、BFC-是什么？\"><a href=\"#11、BFC-是什么？\" class=\"headerlink\" title=\"11、BFC 是什么？\"></a>11、BFC 是什么？</h2><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。<br>可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。<br>只要元素满足下面任一条件即可触发 BFC 特性</p>\n<p>body 根元素<br>浮动元素：float 除 none 以外的值<br>绝对定位元素：position (absolute、fixed)<br>display 为 inline-block、table-cells、flex<br>overflow 除了 visible 以外的值 (hidden、auto、scroll)</p>\n<h2 id=\"8、前端常见的布局方式\"><a href=\"#8、前端常见的布局方式\" class=\"headerlink\" title=\"8、前端常见的布局方式\"></a>8、前端常见的布局方式</h2><h3 id=\"一、静态布局\"><a href=\"#一、静态布局\" class=\"headerlink\" title=\"一、静态布局\"></a>一、静态布局</h3><p>静态布局是最为原始的布局方式，没有什么技术性可言，往往是计算机行业刚刚入门的小白使用的布局方式。制作的网页上的元素尺寸一律以px为单位</p>\n<p>布局特点： 页面上的布局是按最初写代码时候的布局方式进行布局的，常规的pc网站是进行设置了宽度值进行布局的，不会随着pc端的屏幕的大小而变化。<br>优点: 这种布局方式不管是对资深的前端开发工程师还是刚入门的小白来说都是最简单的，最让人容易以接受、学习的，没有我们所说的兼容性的问题。这种布局方式大多用在门户网站和企业的官网上，这些官网的设备的尺寸是固定的，这种布局方式往往是最简单的方法。<br>缺点： 不会随着pc端的屏幕大小而变化。</p>\n<h3 id=\"二、弹性布局（flexbox）\"><a href=\"#二、弹性布局（flexbox）\" class=\"headerlink\" title=\"二、弹性布局（flexbox）\"></a>二、弹性布局（flexbox）</h3><p>弹性布局可以简便、完整、响应的实现各种页面上的布局。与静态不同的是，使用em或rem单位（lem&#x3D;16px，1rem&#x3D;10px）进行相对布局，相对使用百分比更加方便、灵活，相应同时支持浏览器的字体大小调整和缩放的等正常显示。<br>优点：<br>1.适应性强，在做多种不同的屏幕分辨率不同的界面是非常使用。<br>2.随意按照宽度、比例划分元素的宽高。<br>3.可以轻松的改变元素的显示顺序。<br>4.网页布局实现快捷，维护起来更加容易。<br>如果做移动端时，如果客户对细微的之处的要求不高，使用弹性布局进行制作是最好的选择，一份css+一份js调节font-size搞定。<br>缺点： 浏览器兼容性较差，只能兼容到IE9及以上。</p>\n<h3 id=\"三、自适应布局（bootstrap）\"><a href=\"#三、自适应布局（bootstrap）\" class=\"headerlink\" title=\"三、自适应布局（bootstrap）\"></a>三、自适应布局（bootstrap）</h3><p>自适应布局分别为不同屏幕不同分辨率定义布局，即是创建多个静态页面，每个静态页面对应一个屏幕分辨率的一个范围内。在改变不同的屏幕分辨率可以切换到不同的静态布局上，但是布局中的元素位置会发生改变，但是在每个静态布局中，页面中的元素不会随着窗口大小的调整发生变化。使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。<br>优点：<br>1.对网站的复杂程度兼容性更大；<br>2.对开发工程师来说制作的成本代价更低；<br>3.代码执行效果更高效；<br>4.测试时更加容易，运营相对更加精准。<br>缺点： 在现如今的移动端设计百花齐放的时期之下，同一个网站往往需要为不同的设备制作不同的页面，不但会增加开发成本，还会因为客户的需求改变时，可能会改动多套代码、流程相比较来说较繁琐。</p>\n<h3 id=\"四、流式布局（fluid）\"><a href=\"#四、流式布局（fluid）\" class=\"headerlink\" title=\"四、流式布局（fluid）\"></a>四、流式布局（fluid）</h3><p>流式布局的布局方式是页面的元素的宽度按照屏幕的分辨率进行适配的调整，但是整体布局不变，也称之为栅栏系统。使用%百分比定义宽度，高度大都是用px来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width&#x2F;min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。<br>缺点： 屏幕大小变化时，页面元素也随之变化但是布局不变。这就会因为如果屏幕太大或太小都会布局时元素无法正常显示。</p>\n<h3 id=\"五、响应式布局\"><a href=\"#五、响应式布局\" class=\"headerlink\" title=\"五、响应式布局\"></a>五、响应式布局</h3><p>响应式布局是css3增加的新布局方式，该布局方式2010年提出来的一个概念，说白了就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。响应式几乎成为优秀页面布局的标准。<br>设计方法： 媒体查询+流式布局。通常使用@media媒体查询，和网格系统配合相对布局单位进行布局，实际上说白了就是综合响应式等技术通过css给单一网页不同设备分辨率返回不式时的技术。<br>优点： 适应pc端和移动端，如果有足够的耐心，页面效果会很完美。<br>缺点：<br>1.只能适应主流的宽高；<br>2.如果匹配足够多的设备屏幕的大小，对于工程师来说工作量不小，设计更需要多个版本，工作量增大。</p>\n<h3 id=\"六、浮动布局\"><a href=\"#六、浮动布局\" class=\"headerlink\" title=\"六、浮动布局\"></a>六、浮动布局</h3><p>浮动布局进行调用浮动属性改变页面中元素的位置，浮动布局应该是目前各大网站用的最多的一种布局方式了，但是也特别复杂。浮动元素是脱离文档流的，但不脱离文本流。浮动元素有左浮动（float : left）和右浮动（float : right）两种</p>\n<p>优点： 兼容性比较好<br>缺点： 浮动带来的影响比较多，页面宽度不够的时候会影响布局。</p>\n<h3 id=\"七、定位布局\"><a href=\"#七、定位布局\" class=\"headerlink\" title=\"七、定位布局\"></a>七、定位布局</h3><p>定位布局时利用position属性控制页面元素设置一些不规则布局。</p>\n<h1 id=\"3、js\"><a href=\"#3、js\" class=\"headerlink\" title=\"3、js\"></a>3、js</h1><h2 id=\"什么是async？\"><a href=\"#什么是async？\" class=\"headerlink\" title=\"什么是async？\"></a>什么是async？</h2><p>async 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用 await 来表示异步。相较于 Generator，async 函数的改进在于下面四点：</p>\n<p>内置执行器。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，调用方式跟普通函数的调用一样<br>更好的语义。async 和 await 相较于 * 和 yield 更加语义化<br>更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise对象。而 async 函数的 await 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）<br>返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用</p>\n<h2 id=\"await是什么？\"><a href=\"#await是什么？\" class=\"headerlink\" title=\"await是什么？\"></a>await是什么？</h2><p>await意思是async wait(异步等待)。这个关键字只能在使用async定义的函数里面使用。任何async函数都会默认返回promise，并且这个promise解析的值都将会是这个函数的返回值，而async函数必须等到内部所有的 await 命令的 Promise 对象执行完，才会发生状态改变。</p>\n<p>打个比方，await是学生，async是校车，必须等人齐了再开车。</p>\n<p>就是说，必须等所有await 函数执行完毕后，才会告诉promise我成功了还是失败了，执行then或者catch</p>\n<h2 id=\"19、var-let-const-三者区别？\"><a href=\"#19、var-let-const-三者区别？\" class=\"headerlink\" title=\"19、var,let ,const 三者区别？\"></a>19、var,let ,const 三者区别？</h2><p>共同点：都是可以声明变量</p>\n<p>区别1：var具有变量提升的机制，let和const 没有变量提升机制，</p>\n<p>区别2：var可以多次声明同一个变量，let和const 不可以多次声明同一个变量，</p>\n<p>区别3：var和let声明的是常量，const声明常量，var和let声明的变量可以再一次赋值，而const 不可以再次赋值</p>\n<p>面试的时候会问const 一个对象，里面是a:1，我现在想打印console.log(obj.a)这个结果是1，我想改变a:2,打印的就是2因为里面的值不是const,从内存的角度看，一个对象里面修改了对量里面的属性值，那么再次打印会打印出新的值，</p>\n<p>什么是常量：常量是一个在程序执行过程中不能被改变或修改的固定值。它是被赋予一个固定值后就不能再改变的变量。理解成，不能被操作所修改的变量就是常量。用途：保护数据，可以提高程序的可读性、可维护性</p>\n<p>变量：变量是用于存储和表示数据的一种命名容器。它是程序中的一个基本概念，用于在内存中存储和操作数据。变量的值可以被修改和更新。</p>\n<p>区别4：var没有作用域，在ES6之后才出现的作用域块的概念，</p>\n<h3 id=\"null-和-undefined-区别\"><a href=\"#null-和-undefined-区别\" class=\"headerlink\" title=\"null 和 undefined 区别\"></a>null 和 undefined 区别</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型<br>分别都只有一个值，就是 undefined 和 null。<br>undefined 代表的含义是未定义，null 代表的含义是空对象。一般<br>变量声明了但还没有定义的时候会返回 undefined，null 主要用于<br>赋值给一些可能会返回对象的变量，作为初始化。</p>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个<br>变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域<br>查找，依次向上级作用域查找，直到访问到 window 对象就被终止，<br>这一层层的关系就是作用域链</p>\n<h3 id=\"1、深拷贝、浅拷贝（笔试题）★★★★★\"><a href=\"#1、深拷贝、浅拷贝（笔试题）★★★★★\" class=\"headerlink\" title=\"1、深拷贝、浅拷贝（笔试题）★★★★★\"></a><strong>1、深拷贝、浅拷贝（笔试题）★★★★★</strong></h3><p>【{},[]】</p>\n<ul>\n<li>浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个<strong>地址</strong>，修改时原对象也会受到影响<ul>\n<li>Object.assign</li>\n<li>展开运算符 …</li>\n</ul>\n</li>\n<li>深拷贝: 完全拷贝一个新<strong>对象</strong>，修改时原对象不再受到任何影响</li>\n</ul>\n<h2 id=\"2、作用域、作用域链\"><a href=\"#2、作用域、作用域链\" class=\"headerlink\" title=\"2、作用域、作用域链\"></a>2、作用域、作用域链</h2><p>作用域：变量和函数起作用的范围。</p>\n<p>作用域链：是js查找方式，决定的变量和函数向上查找的范围。</p>\n<p>作用域是可访问的变量的<br>集合。在JavaScript中，作用域为可访问变量，对象，函数的集合，它分为局部作用域和全局作用域。作用域决定了这些变量的可访问性（可见性）。</p>\n<p>作用域链</p>\n<p>我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含<br>父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p>\n<p>它由两部分组成:<br>[[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO<br>AO: 自身活动对象<br>如此 [[scope]]包含[[scope]]，便自上而下形成一条 链式作用域。</p>\n<h2 id=\"1、闭包★★★★★\"><a href=\"#1、闭包★★★★★\" class=\"headerlink\" title=\"1、闭包★★★★★\"></a>1、闭包★★★★★</h2><h3 id=\"1、变量作用域\"><a href=\"#1、变量作用域\" class=\"headerlink\" title=\"1、变量作用域\"></a>1、变量作用域</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">要理解闭包，首先要理解 JavasSript 的特殊的变量作用域。</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">变量的作用域无非就两种：全局变量和局部变量。</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">JavasSript 语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局                    部变量。</code></pre>\n\n<p><strong>注意点：</strong>在函数内部声明变量的时候，一定要使用 var 命令。如果不用的话，你实际上声明的是一个全局变量！</p>\n<h3 id=\"2、如何从外部读取函数内部的局部变量？\"><a href=\"#2、如何从外部读取函数内部的局部变量？\" class=\"headerlink\" title=\"2、如何从外部读取函数内部的局部变量？\"></a>2、如何从外部读取函数内部的局部变量？</h3><p>出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。</p>\n<p>那就是在函数内部，再定义一个函数。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function f1()&#123;\n    var n&#x3D;999;\n    function f2()&#123;\n        alert(n); &#x2F;&#x2F; 999\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的代码中，函数 f2 就被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。</p>\n<p>这就是 JavasSript 语言特有的”链式作用域”结构（chain scope）</p>\n<h3 id=\"3、闭包的概念\"><a href=\"#3、闭包的概念\" class=\"headerlink\" title=\"3、闭包的概念\"></a>3、闭包的概念</h3><p>上面代码中的 f2 函数，就是闭包。</p>\n<p>各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。</p>\n<p>由于在 JavaScript 中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成”定义在一个函数内部的函数”。</p>\n<p>所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p>\n<p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数</p>\n<p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>\n<p>闭包有三个特性：</p>\n<p>1.函数嵌套函数</p>\n<p>2.函数内部可以引用外部的参数和变量</p>\n<p>3.参数和变量不会被垃圾回收机制回收</p>\n<h3 id=\"4、闭包的用途\"><a href=\"#4、闭包的用途\" class=\"headerlink\" title=\"4、闭包的用途\"></a>4、闭包的用途</h3><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在 f1 调用后被自动清除。</p>\n<p>为什么会这样呢？原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>\n<p>这段代码中另一个值得注意的地方，就是 “nAdd&#x3D;function(){n+&#x3D;1}” 这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量。其次，nAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。</p>\n<ul>\n<li>使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。</li>\n<li>闭包有三个特性：</li>\n<li>函数嵌套函数</li>\n<li>函数内部可以引用外部的参数和变量</li>\n<li>参数和变量不会被垃圾回收机制回收</li>\n</ul>\n<p>应用场景：</p>\n<ul>\n<li>设置私有变量的方法</li>\n<li>不适用场景：返回闭包的函数是个非常大的函数<br>闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏</li>\n</ul>\n<h3 id=\"5、使用闭包的注意点\"><a href=\"#5、使用闭包的注意点\" class=\"headerlink\" title=\"5、使用闭包的注意点\"></a>5、使用闭包的注意点</h3><p>（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值</p>\n<h2 id=\"2、-原型链★★★★★\"><a href=\"#2、-原型链★★★★★\" class=\"headerlink\" title=\"2、 原型链★★★★★\"></a>2、 原型链★★★★★</h2><p>那什么是原型链呢？</p>\n<p>简单理解就是原型组成的链，对象的__proto__它的是原型，而原型也是一个对象，也有__proto__属性，原型的__proto__又是原型的原型，就这样可以一直通过__proto__想上找，这就是原型链，当向上找找到Object的原型的时候，这条原型链就算到头了。</p>\n<p>原型对象和实例之间有什么作用呢？</p>\n<p>通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。</p>\n<p>在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法。</p>\n<h2 id=\"3、-请列举几种隐藏元素的方法\"><a href=\"#3、-请列举几种隐藏元素的方法\" class=\"headerlink\" title=\"3、 请列举几种隐藏元素的方法\"></a>3、 请列举几种隐藏元素的方法</h2><p>visibility: hidden;这个属性只是简单的隐藏某个元素，但是元素占用的空间仍然存在<br>opacity: 0; CSS3属性，设置0可以使一个元素完全透明，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的<br>display: none;元素会变得不可见，并且不会再占用元素位置。会改变页面布局。<br>transform: scale(0);将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留。</p>\n<h2 id=\"4、-防抖和节流★★★★★\"><a href=\"#4、-防抖和节流★★★★★\" class=\"headerlink\" title=\"4、 防抖和节流★★★★★\"></a>4、 防抖和节流★★★★★</h2><p>本质上是优化高频率执行代码的一种手段</p>\n<p>如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p>\n<p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（防抖）和debounce（节流）的方式来减少调用频率</p>\n<p>定义：</p>\n<p><strong>节流</strong>: <strong>n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</strong><br><strong>防抖</strong>: <strong>n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</strong><br>一个经典的比喻:</p>\n<p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应</p>\n<p>假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制</p>\n<p>电梯第一个人进来后，15秒后准时运送一次，这是节流。</p>\n<p>电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖。</p>\n<p>防抖应用场景</p>\n<p>搜索框搜索输入。只需用户最后一次输入完，再发送请求<br>手机号、邮箱验证输入检测 onchange &#x2F; oninput事件<br>窗口大小计算。只需窗口调整完成后，计算窗口大小。防止重复渲染。<br>节流应用场景</p>\n<p>懒加载、滚动加载、加载更多或监听滚动条位置；<br>百度搜索框，搜索联想功能；<br>防止高频点击提交，防止表单重复提交；</p>\n<h2 id=\"5、-和-的区别\"><a href=\"#5、-和-的区别\" class=\"headerlink\" title=\"5、&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D; 的区别?\"></a>5、&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D; 的区别?</h2><p>&#x3D;&#x3D;（相等操作符）：比较时会进行类型转换，尝试将两个操作数转换为相同的类型，然后进行值的比较。如果操作数的类型不同，会进行类型转换后再比较。这种比较方式被称为弱类型相等比较。</p>\n<p>&#x3D;&#x3D;&#x3D;（严格相等操作符）：比较时不进行类型转换，仅当两个操作数的类型相同且值相等时，返回true。这种比较方式要求比较的操作数类型和值都要相同。</p>\n<p>&#x3D;&#x3D;，当且仅当两个运算数相等时，它返回 true，即不检查数据类型<br>&#x3D;&#x3D;&#x3D;，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型</p>\n<h2 id=\"6、JS-数据类型\"><a href=\"#6、JS-数据类型\" class=\"headerlink\" title=\"6、JS 数据类型 ?\"></a>6、JS 数据类型 ?</h2><p>数据类型主要包括两部分：</p>\n<p>基本数据类型： Undefined、Null、Boolean、Number 和 String<br>引用数据类型： Object (包括 Object 、Array 、Function)<br>ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</p>\n<h2 id=\"7、null-和-undefined-的区别？\"><a href=\"#7、null-和-undefined-的区别？\" class=\"headerlink\" title=\"7、null 和 undefined 的区别？\"></a>7、null 和 undefined 的区别？</h2><p>null 表示一个对象被定义了，值为“空值”；<strong>无对象</strong><br>undefined 表示不存在这个值。<strong>无值</strong><br>（1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。</p>\n<p>null 和 undefined 区别</p>\n<p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型<br>分别都只有一个值，就是 undefined 和 null。<br>undefined 代表的含义是未定义，null 代表的含义是空对象。一般<br>变量声明了但还没有定义的时候会返回 undefined，null 主要用于<br>赋值给一些可能会返回对象的变量，作为初始化。</p>\n<h2 id=\"8、★★★★★-promise理解、手写promise\"><a href=\"#8、★★★★★-promise理解、手写promise\" class=\"headerlink\" title=\"8、★★★★★ promise理解、手写promise\"></a>8、★★★★★ promise理解、手写promise</h2><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，避免了地狱回调<br>Promise有三种状态： pending(等待态)，fulfilled(成功态)，rejected(失败态) ；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。<br>Promise拥有一个then方法，用以处理resolved或rejected状态下的值<br>then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。<br>then方法返回一个新的Promise对象，因此可以通过链式调用then方法</p>\n<p>Promise 是异步编程的一种解决方案，它是一个对象，可以获取异步<br>操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，<br>它比传统的解决方案回调函数和事件更合理和更强大。<br>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束<br>的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一<br>个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，<br>各种异步操作都可以用同样的方法进行处理。<br>（1）Promise 的实例有三个状态:<br>Pending（进行中）<br>Resolved（已完成）<br>Rejected（已拒绝）<br>当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了<br>状态就变成了 Resolved、没有完成失败了就变成了 Rejected。<br>（2）Promise 的实例有两个过程：<br>pending -&gt; fulfilled : Resolved（已完成）<br>pending -&gt; rejected：Rejected（已拒绝）<br>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p>\n<h2 id=\"9、async-await函数★★★★★\"><a href=\"#9、async-await函数★★★★★\" class=\"headerlink\" title=\"9、async await函数★★★★★\"></a>9、async await函数★★★★★</h2><p>async&#x2F;await函数是异步代码的新方式<br>async&#x2F;await是基于promise实现的<br>async&#x2F;await使异步代码更像同步代码<br>await 只能在async函数中使用，不能再普通函数中使用，要成对出现<br>默认返回一个promise实例，不能被改变<br>await下面的代码是异步，后面的代码是同步的</p>\n<h3 id=\"10、异步编程的实现方式？\"><a href=\"#10、异步编程的实现方式？\" class=\"headerlink\" title=\"10、异步编程的实现方式？\"></a>10、异步编程的实现方式？</h3><p>回调函数</p>\n<p>使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。<br>Promise</p>\n<h3 id=\"使用-Promise-的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个-then-的链式调用，可能会造成代码的语义不够明确。\"><a href=\"#使用-Promise-的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个-then-的链式调用，可能会造成代码的语义不够明确。\" class=\"headerlink\" title=\"使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。\"></a>使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</h3><p>async 函数</p>\n<p>async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</p>\n<h2 id=\"箭头函数与普通函数的区别？\"><a href=\"#箭头函数与普通函数的区别？\" class=\"headerlink\" title=\"箭头函数与普通函数的区别？\"></a>箭头函数与普通函数的区别？</h2><h3 id=\"1、箭头函数比普通函数更加简洁\"><a href=\"#1、箭头函数比普通函数更加简洁\" class=\"headerlink\" title=\"1、箭头函数比普通函数更加简洁\"></a>1、箭头函数比普通函数更加简洁</h3><p>如果没有参数，就直接写一个空括号即可</p>\n<p>如果只有一个参数，可以省去参数的括号</p>\n<p>如果有多个参数，用逗号分割</p>\n<p>如果函数体的返回值只有一句，可以省略大括号</p>\n<h3 id=\"2-箭头函数没有自己的this\"><a href=\"#2-箭头函数没有自己的this\" class=\"headerlink\" title=\"2. 箭头函数没有自己的this\"></a>2. 箭头函数没有自己的this</h3><p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p>\n<h3 id=\"3-箭头函数继承来的this指向永远不会改变\"><a href=\"#3-箭头函数继承来的this指向永远不会改变\" class=\"headerlink\" title=\"3. 箭头函数继承来的this指向永远不会改变\"></a>3. 箭头函数继承来的this指向永远不会改变</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var id &#x3D; &#39;GLOBAL&#39;;\nvar obj &#x3D; &#123;\n  id: &#39;OBJ&#39;,\n  a: function()&#123;\n    console.log(this.id);\n  &#125;,\n  b: () &#x3D;&gt; &#123;\n    console.log(this.id);\n  &#125;\n&#125;;\nobj.a();    &#x2F;&#x2F; &#39;OBJ&#39;\nobj.b();    &#x2F;&#x2F; &#39;GLOBAL&#39;\nnew obj.a()  &#x2F;&#x2F; undefined\nnew obj.b()  &#x2F;&#x2F; Uncaught TypeError: obj.b is not a constructor</code></pre>\n\n<p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号**{ }**是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p>\n<h3 id=\"4-call-、apply-、bind-等方法不能改变箭头函数中this的指向\"><a href=\"#4-call-、apply-、bind-等方法不能改变箭头函数中this的指向\" class=\"headerlink\" title=\"4. call()、apply()、bind()等方法不能改变箭头函数中this的指向\"></a>4. call()、apply()、bind()等方法不能改变箭头函数中this的指向</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var id &#x3D; &#39;Global&#39;;\nlet fun1 &#x3D; () &#x3D;&gt; &#123;\n    console.log(this.id)\n&#125;;\nfun1();                     &#x2F;&#x2F; &#39;Global&#39;\nfun1.call(&#123;id: &#39;Obj&#39;&#125;);     &#x2F;&#x2F; &#39;Global&#39;\nfun1.apply(&#123;id: &#39;Obj&#39;&#125;);    &#x2F;&#x2F; &#39;Global&#39;\nfun1.bind(&#123;id: &#39;Obj&#39;&#125;)();   &#x2F;&#x2F; &#39;Global&#39;</code></pre>\n\n<h3 id=\"5、箭头函数不能作为构造函数使用\"><a href=\"#5、箭头函数不能作为构造函数使用\" class=\"headerlink\" title=\"5、箭头函数不能作为构造函数使用\"></a>5、箭头函数不能作为构造函数使用</h3><p>由于箭头函数时没有自己的this，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p>\n<h3 id=\"6、箭头函数没有自己的arguments\"><a href=\"#6、箭头函数没有自己的arguments\" class=\"headerlink\" title=\"6、箭头函数没有自己的arguments\"></a>6、箭头函数没有自己的arguments</h3><p>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p>\n<h3 id=\"7、箭头函数没有prototype\"><a href=\"#7、箭头函数没有prototype\" class=\"headerlink\" title=\"7、箭头函数没有prototype\"></a>7、箭头函数没有prototype</h3><h3 id=\"8、箭头函数的this指向哪⾥？★★★★★\"><a href=\"#8、箭头函数的this指向哪⾥？★★★★★\" class=\"headerlink\" title=\"8、箭头函数的this指向哪⾥？★★★★★\"></a>8、箭头函数的this指向哪⾥？★★★★★</h3><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p>\n<h2 id=\"10、常见的DOM操作有哪些\"><a href=\"#10、常见的DOM操作有哪些\" class=\"headerlink\" title=\"10、常见的DOM操作有哪些\"></a>10、常见的DOM操作有哪些</h2><p>Create：动态增加DOM 节点</p>\n<p>Delete：删除DOM 节点</p>\n<p>Update：更新DOM 节点的内容</p>\n<p>Read：获取DOM 节点</p>\n<p>1 Document.getElementById()</p>\n<p>2 Document.getElementsByTagName()</p>\n<p>3 Document.getElementsByClassName()</p>\n<p>4 Document.querySelector()</p>\n<p>5 Document.querySelectorAll()</p>\n<p>6 父节点Node.parentNode</p>\n<h2 id=\"11、对this对象的理解\"><a href=\"#11、对this对象的理解\" class=\"headerlink\" title=\"11、对this对象的理解\"></a>11、对this对象的理解</h2><h5 id=\"this-关键字含义是什么？\"><a href=\"#this-关键字含义是什么？\" class=\"headerlink\" title=\"this 关键字含义是什么？\"></a>this 关键字含义是什么？</h5><p>解答：this总是返回一个对象，**this就是属性或方法“当前”所在对象。**由于对象的属性可以赋值给另一个对象，所以属性所在的当前对象是可变的，即**this指向是可变的**。</p>\n<p>1.this是js 的一个关键字，随着函数的使用场合的不同，this 的值会发生变化。</p>\n<p>2.一个总原则：即this指的是调用函数的那个对象。</p>\n<p>3.一般情况下，this 是全局对象，可以作为方法调用。</p>\n<h2 id=\"12、-call、apply-及-bind-函数-★★★★★\"><a href=\"#12、-call、apply-及-bind-函数-★★★★★\" class=\"headerlink\" title=\"12、 call、apply 及 bind 函数 ★★★★★\"></a>12、 call、apply 及 bind 函数 ★★★★★</h2><p><strong>call()、apply()、bind()都是用于改变this指向的方法，不同点传参方式不太相同以及返回不同。</strong></p>\n<ul>\n<li>call( ) 是接收一个及其以上的参数，第一个参数表示this要指向的对象，其余参数表示调用函数需要传入的参数，返回调用函数的返回结果，属于立即执行函数；</li>\n<li>apply( ) 是接收两个参数，第一个参数表示this要指向的对象，第二参数表示调用函数需要传入的参数所组成的数组，返回调用函数的返回结果，属于立即执行函数；</li>\n<li>bind( ) 是接收一个及其以上的参数，和call(）一致，但是其返回是一个函数，而不是调用函数的返回结果；</li>\n</ul>\n<h2 id=\"13-、异步编程-★★★★★\"><a href=\"#13-、异步编程-★★★★★\" class=\"headerlink\" title=\"13 、异步编程 ★★★★★\"></a>13 、<strong>异步编程 ★★★★★</strong></h2><h3 id=\"一、回调函数\"><a href=\"#一、回调函数\" class=\"headerlink\" title=\"一、回调函数\"></a>一、回调函数</h3><p>这是异步编程最基本的方法</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function asyncFn(callback) &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n        console.log(&#39;asyncFn&#39;);\n        callback();\n    &#125;, 0)\n&#125;\nfunction normalFn() &#123;\n    console.log(&#39;normalFn&#39;);\n&#125;\n\nasyncFn(normalFn);</code></pre>\n\n<ul>\n<li>缺点<ul>\n<li>容易出现回调地狱</li>\n<li>当多个回调函数嵌套，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪</li>\n<li>不能使用 try catch 不能直接return</li>\n</ul>\n</li>\n<li>优点<ul>\n<li>简单、容易理解和实现</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、事件触发模式\"><a href=\"#二、事件触发模式\" class=\"headerlink\" title=\"二、事件触发模式\"></a>二、事件触发模式</h3><p>另一种思路是采用事件驱动模式。即<strong>异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</strong><br>比如一个我们注册一个按钮的点击事件或者注册一个自定义事件，然后通过点击或者trigger的方式触发这个事件。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var btn &#x3D; document.getElementById(&#39;Button&#39;);\nbtn.onclick &#x3D; function() &#123;\n    console.log(&#39;展示异步操作&#39;);\n&#125;</code></pre>\n\n<ul>\n<li>缺点<ul>\n<li>整个程序变成事件驱动型，运行流程不清晰</li>\n</ul>\n</li>\n<li>优点<ul>\n<li>可以绑定多个事件，每个事件可以指定多个回调函数</li>\n<li>可以“去耦合”，有利于实现模块化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、发布订阅\"><a href=\"#三、发布订阅\" class=\"headerlink\" title=\"三、发布订阅\"></a>三、发布订阅</h3><p>发布&#x2F;订阅模式，又称<a href=\"https://so.csdn.net/so/search?q=%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020\">观察者模式</a></p>\n<p>我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subcribe）这个信号，从而知道什么时候自己可以开始执行。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;f2向信号中心Jquery订阅done信号\n\tjQuery.subscribe(&quot;done&quot;, f2);\n\tfunction f1()&#123;\n　　　　setTimeout(function () &#123;\n　　　　　　&#x2F;&#x2F; f1的任务代码\n\t\t   &#x2F;&#x2F;发布done信号\n　　　　　　jQuery.publish(&quot;done&quot;);\n　　　　&#125;, 1000);\n　　&#125;\n　　&#x2F;&#x2F;f2执行完成后，取消订阅\n　　jQuery.unsubscribe(&quot;done&quot;, f2);</code></pre>\n\n<p>发布&#x2F;订阅，性质与“事件监听类似”，但是明显优于后者，因为我们可以通过查看”消息中心“，了解存在多少信号，多少个订阅者，从而监听程序的运行。</p>\n<h3 id=\"四、Promises对象\"><a href=\"#四、Promises对象\" class=\"headerlink\" title=\"四、Promises对象\"></a>四、Promises对象</h3><p>Promises对象是CommonJs工作提出的一种规范，目的是为了异步编程提供统一接口</p>\n<p>他的思想是每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数，比如f1的回调函数f2，可以写成：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">f1().then(f2);\n　\tfunction f1()&#123;\n　\t\t&#x2F;&#x2F;deferred对象就是jQuery的回调函数解决方案。\n　　　　var dfd &#x3D; $.Deferred();\n　　　　setTimeout(function () &#123;\n　　　　　　&#x2F;&#x2F; f1的任务代码\n\t\t   &#x2F;&#x2F;将dtd对象的执行状态从&quot;未完成&quot;改为&quot;已完成&quot;，从而触发done()方法\n　　　　　　dfd.resolve();\n　　　　&#125;, 500);\n\t   &#x2F;&#x2F;返回promise对象 \n\t   &#x2F;&#x2F; deferred.promise()方法。它的作用是，在原来的deferred对象上返回另一个deferred对象，\n\t   &#x2F;&#x2F;后者只开放与改变执行状态无关的方法（比如done()方法和fail()方法），\n\t   &#x2F;&#x2F;屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），\n\t   &#x2F;&#x2F;从而使得执行状态不能被改变。\n　　　　return dfd.promise;\n　　&#125;\n \n\tf1().then(f2).then(f3); &#x2F;&#x2F;指定多个回调函数\n\tf1().then(f2).fail(f3); &#x2F;&#x2F;指定发生错误时的回调函数</code></pre>\n\n<h3 id=\"五、生成器函数-Generator-yield\"><a href=\"#五、生成器函数-Generator-yield\" class=\"headerlink\" title=\"五、生成器函数 Generator&#x2F;yield\"></a>五、生成器函数 Generator&#x2F;yield</h3><p>Generator函数是 ES6 提供的一种异步编程解决方案。</p>\n<p>yield表达式可以暂停函数执行，next方法用于恢复函数执行，这使得Generator函数非常适合将异步任务同步化。<br>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。<br>每个yield返回的是｛value:yield返回的值，done:true&#x2F;false(执行状态)｝</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function *generatorDemo() &#123;\n\t yield &#39;hello&#39;;\n\t yield 1 + 2;\n\t return &#39;ok&#39;;\n\t&#125;\n\t \n\tvar demo &#x3D; generatorDemo()\n\t \n\tdemo.next()  &#x2F;&#x2F; &#123; value: &#39;hello&#39;, done: false &#125; \n\tdemo.next()  &#x2F;&#x2F; &#123; value: 3, done: false &#125; \n\tdemo.next()  &#x2F;&#x2F; &#123; value: &#39;ok&#39;, done: ture &#125; \n\tdemo.next()  &#x2F;&#x2F; &#123; value: undefined, done: ture &#125;</code></pre>\n\n<p>六、async&#x2F;await 函数的实现<br>async是“异步”的意思，而 await 是等待的意思。所以应该很好理解 async 用于申明一个 异步的function （实际上是asnyc function 对象）</p>\n<p>await 用于等待一个异步任务执行完成的结果，并且await只等出现在 async 函数中</p>\n<p>一个函数如果加上 asnyc，那么该函数就会返回一个 Promise</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function async1() &#123;\n  return &quot;1&quot;\n&#125;\nconsole.log(async1()) &#x2F;&#x2F; -&gt; Promise &#123;&lt;resolved&gt;: &quot;1&quot;&#125;</code></pre>\n\n<p>async函数返回的是一个 Promise 对象，可以使用 then 方法添加回调函数，async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<br>1.await命令后面返回的是 Promise 对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。</p>\n<h2 id=\"14、seTimeout，Promise，Async-await的区别\"><a href=\"#14、seTimeout，Promise，Async-await的区别\" class=\"headerlink\" title=\"14、seTimeout，Promise，Async&#x2F;await的区别\"></a>14、seTimeout，Promise，Async&#x2F;await的区别</h2><p>共同点</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">都是用来解决异步回调问题\n区别：</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1.setTimeout属于宏任务。</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2.Promise属于异步操作，只有当只有当.then(), resove(),.catch()等操作后才会进入微任务。</code></pre>\n\n<p>3.Async&#x2F;await 在await之前都是异步操作，只有在await后才会进入微任务。<br>也可以说如果函数体有一个await，async就一定会异步，没有的话就是同步。<br>15、Promise理解<br>（1）抽象描述：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">①promise 是一门新的技术(ES6 规范)；\n\n②promise 是 js 中进行异步编程的新解决方案(旧方案是单纯使用回调函数)。</code></pre>\n\n<p>（2）具体描述：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">①从语法上看：promise 是一个构造函数；\n\n②从功能上看：promise 对象用来封装一个异步操作并可以获取其成功或者失败的结果值。</code></pre>\n\n<h2 id=\"15、async、await详解\"><a href=\"#15、async、await详解\" class=\"headerlink\" title=\"15、async、await详解\"></a>15、async、await详解</h2><p>async&#x2F;awiat的使用规则:</p>\n<ol>\n<li>async 表示这是一个async函数， await只能用在async函数里面，不能单独使用</li>\n<li>async 返回的是一个Promise对象，await就是等待这个promise的返回结果后，再继续执行</li>\n<li>await 等待的是一个Promise对象，后面必须跟一个Promise对象，但是不必写then()，直接就可以得到返回值</li>\n</ol>\n<h2 id=\"16、什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？\"><a href=\"#16、什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？\" class=\"headerlink\" title=\"16、什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？\"></a>16、什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</h2><p><a href=\"https://so.csdn.net/so/search?q=%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020\">回调函数</a>：就是把一个函数当作一个函数的参数</p>\n<h2 id=\"回调地狱：\"><a href=\"#回调地狱：\" class=\"headerlink\" title=\"回调地狱：\"></a>回调地狱：</h2><p>当<a href=\"https://so.csdn.net/so/search?q=%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C&spm=1001.2101.3001.7020\">异步操作</a>想要有顺序时，只能在一个异步成功以后的回调函数里面嵌套另一个异步的操作，如果嵌套的层数过多就形成了回调地狱</p>\n<p>回调地狱的弊端：后期代码维护比较困难</p>\n<p><strong>async await  回调地狱的最终解决方法 （es7）</strong></p>\n<p><strong>原理：</strong>实际上就是生成器函数的语法糖</p>\n<p>可以将异步嵌套的语法，改成像是同步一样。不需要嵌套，就可以有先后顺序</p>\n<h1 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a>vue</h1><p>一、var、let、const的相同点</p>\n<p>二、var、let、const的不同</p>\n<p>区别一：var 存在变量提升 而 let 与 const 不存在变量提升</p>\n<p>区别二：var定义的变量可以声明多次，而let、const定义的变量只能声明</p>\n<p>区别三：var、let声明的变量可以再次赋值，而const声明的变量不能再次赋值</p>\n<h2 id=\"v-if和v-show的详解\"><a href=\"#v-if和v-show的详解\" class=\"headerlink\" title=\"v-if和v-show的详解\"></a>v-if和v-show的详解</h2><p>v-if:通过移除元素来实现元素的显示与隐藏，每次显示都会触发组件的mouted钩子函数。可以用来表面意义上的刷新组件<br>v-show:通过设置元素的display属性来控制元素的显示与隐藏。elementui的弹窗组件就是利用v-show来控制显示与隐藏的。<br>二.v-if和v-show的区别<br>加载速度不同，v-show要比v-if快，实际项目中就是这样。<br>原理不同。<br>应用场景不同，v-if多用于需要刷新的组件。v-show多用于不需要刷新组件的显示与隐藏。<br>组件内缓存子组件就是用的v-show。<br>做项目优化的时候可以尽量使用v-show,具体看需求。</p>\n<h2 id=\"vue2和vue3的区别\"><a href=\"#vue2和vue3的区别\" class=\"headerlink\" title=\"vue2和vue3的区别\"></a>vue2和vue3的区别</h2><h3 id=\"1、双向数据绑定原理不同\"><a href=\"#1、双向数据绑定原理不同\" class=\"headerlink\" title=\"1、双向数据绑定原理不同\"></a>1、双向数据绑定原理不同</h3><p><strong>vue2</strong>：<a href=\"https://so.csdn.net/so/search?q=vue2&spm=1001.2101.3001.7020\">vue2</a>的双向数据绑定是利用<strong>ES5的一个APIObject.definePropert()</strong> 对数据进行劫持，结合发布订阅模式的方式来实现的。</p>\n<p><strong>vue3</strong>：<a href=\"https://so.csdn.net/so/search?q=vue3&spm=1001.2101.3001.7020\">vue3</a>中使用了<strong>ES6的Proxy API</strong>对数据代理。相比vue2.x，使用proxy的优势如下：</p>\n<ul>\n<li>defineProperty只能监听某个属性，不能对全对象监听</li>\n<li>可以省去for in，闭包等内容来提升效率(直接绑定整个对象即可)</li>\n<li>可以监听数组，不用再去单独的对数组做特异性操作vue3.x可以检测到数组内部数据的变化。</li>\n</ul>\n<h3 id=\"2、是否支持碎片\"><a href=\"#2、是否支持碎片\" class=\"headerlink\" title=\"2、是否支持碎片\"></a>2、是否支持碎片</h3><p><strong>vue2</strong>：vue2<strong>不支持</strong>碎片。</p>\n<p><strong>vue3</strong>：vue3<strong>支持碎片（Fragments）</strong> ，就是说可以拥有多个根节点。</p>\n<h3 id=\"3、API类型不同\"><a href=\"#3、API类型不同\" class=\"headerlink\" title=\"3、API类型不同\"></a>3、API类型不同</h3><p><strong>vue2</strong>：vue2使用<strong>选项类型api</strong>，选项型api在代码里分割了不同的属性：data,computed,methods等。</p>\n<p><strong>vue3</strong>：vue3使用<strong>合成型api</strong>，新的合成型api能让我们使用方法来分割，相比于旧的api使用属性来分组，这样代码会更加简便和整洁。</p>\n<h3 id=\"4、定义数据变量和方法不同\"><a href=\"#4、定义数据变量和方法不同\" class=\"headerlink\" title=\"4、定义数据变量和方法不同\"></a>4、定义数据变量和方法不同</h3><p><strong>vue2</strong>：vue2是把数据放入data中，在vue2中定义数据变量是<strong>data(){}</strong> ，创建的方法要在<strong>methods:{}</strong> 中。</p>\n<p><strong>vue3</strong>：，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。使用以下三个步骤来建立反应性数据：</p>\n<ul>\n<li>从vue引入<strong>reactive</strong>；</li>\n<li>使用<strong>reactive()</strong> 方法来声明数据为响应性数据；</li>\n<li>使用setup()方法来返回我们的响应性数据，从而<strong>template</strong>可以获取这些响应性数据。</li>\n</ul>\n<h3 id=\"5、生命周期钩子函数不同\"><a href=\"#5、生命周期钩子函数不同\" class=\"headerlink\" title=\"5、生命周期钩子函数不同\"></a>5、生命周期钩子函数不同</h3><p><strong>vue2</strong>：<strong>vue2中的生命周期</strong>：</p>\n<ul>\n<li>beforeCreate 组件创建之前</li>\n<li>created 组件创建之后</li>\n<li>beforeMount 组价挂载到页面之前执行</li>\n<li>mounted 组件挂载到页面之后执行</li>\n<li>beforeUpdate 组件更新之前</li>\n<li>updated 组件更新之后</li>\n</ul>\n<p><strong>vue3</strong>：<strong>vue3中的生命周期</strong>：</p>\n<ul>\n<li>setup 开始创建组件</li>\n<li>onBeforeMount 组价挂载到页面之前执行</li>\n<li>onMounted 组件挂载到页面之后执行</li>\n<li>onBeforeUpdate 组件更新之前</li>\n<li>onUpdated 组件更新之后</li>\n</ul>\n<p>而且vue3.x 生命周期在调用前需要先进行引入。除了这些钩子函数外，vue3.x还增加了onRenderTracked 和onRenderTriggered函数。</p>\n<h3 id=\"6、父子传参不同\"><a href=\"#6、父子传参不同\" class=\"headerlink\" title=\"6、父子传参不同\"></a>6、父子传参不同</h3><p><strong>vue2</strong>：父传子，用props,子传父用事件 Emitting Events。在vue2中，会<strong>调用this$emit</strong>然后传入事件名和对象。</p>\n<p><strong>vue3</strong>：父传子，用props,子传父用事件 Emitting Events。在vue3中的setup()中的第二个参数content对象中就有emit，那么我们只要在setup()接收<strong>第二个参数中使用分解对象法取出emit</strong>就可以在setup方法中随意使用了。</p>\n<h3 id=\"7、指令与插槽不同\"><a href=\"#7、指令与插槽不同\" class=\"headerlink\" title=\"7、指令与插槽不同\"></a>7、指令与插槽不同</h3><p><strong>vue2</strong>：vue2中使用slot可以<strong>直接使用slot</strong>；v-for与v-if在vue2中优先级高的是<strong>v-for指令</strong>，而且不建议一起使用。</p>\n<p><strong>vue3</strong>：vue3中必须使用<strong>v-slot的形式</strong>；vue3中v-for与v-if,只会把当前v-if当做v-for中的一个判断语句，<strong>不会相互冲突</strong>；vue3中移除keyCode作为v-on的修饰符，当然也不支持config.keyCodes；vue3中<strong>移除v-on.native修饰符</strong>；vue3中<strong>移除过滤器filter</strong>。</p>\n<h3 id=\"8、main-js文件不同\"><a href=\"#8、main-js文件不同\" class=\"headerlink\" title=\"8、main.js文件不同\"></a>8、main.js文件不同</h3><p><strong>vue2</strong>：vue2中我们可以使用<strong>pototype(原型)</strong> 的形式去进行操作，引入的是<strong>构造函数</strong>。</p>\n<p><strong>vue3</strong>：vue3中需要使用<strong>结构</strong>的形式进行操作，引入的是<strong>工厂函数</strong>；vue3中app组件中可以<strong>没有根标签</strong>。</p>\n<h4 id=\"拓展阅读\"><a href=\"#拓展阅读\" class=\"headerlink\" title=\"拓展阅读\"></a>拓展阅读</h4><h3 id=\"setup-函数特性\"><a href=\"#setup-函数特性\" class=\"headerlink\" title=\"setup()函数特性\"></a>setup()函数特性</h3><ul>\n<li>setup()函数接收两个参数：props、context(包含attrs、slots、emit)。</li>\n<li>setup函数是处于生命周期beforeCreated和created俩个钩子函数之前。</li>\n<li>执行setup时，组件实例尚未被创建（在setup()内部，this不会是该活跃实例得引用，即不指向vue实例，Vue为了避免我们错误得使用，直接将setup函数中得this修改成了undefined）。</li>\n<li>与模板一起使用时，需要返回一个对象。</li>\n<li>因为setup函数中，props是响应式得，当传入新的prop时，它将会被更新，所以不能使用es6解构，因为它会消除prop得响应性，如需解构prop，可以通过使用setup函数中得toRefs来完成此操作。</li>\n<li>在setup()内使用响应式数据时，需要通过 .value 获取。</li>\n<li>从setup() 中返回得对象上得property 返回并可以在模板中被访问时，它将自动展开为内部值。不需要在模板中追加.value。</li>\n<li>setup函数只能是同步的不能是异步的。</li>\n</ul>\n<h3 id=\"1-vuex\"><a href=\"#1-vuex\" class=\"headerlink\" title=\"1.vuex\"></a>1.vuex</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>\n<p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。<br>主要包括以下几个模块：</p>\n<ul>\n<li><strong>State &#x3D;&gt;</strong> 基本数据，定义了应用状态的数据结构，可以在这里设置默认的初始状态。页面状态管理容器对象。集中存储 Vuecomponents 中 data对象的零散数据</li>\n<li><strong>Getter &#x3D;&gt;</strong> 从基本数据派生的数据，允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。</li>\n<li><strong>Mutation &#x3D;&gt;</strong> 是唯一更改 store 中状态的方法，且必须是同步函数。状态改变操作方法</li>\n<li><strong>Actions &#x3D;&gt;</strong> 像一个装饰器，包裹mutations，使之可以异步。用于提<strong>交 mutation</strong>，而不是直接变更状态，可以包含任意异步操作。操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。</li>\n<li><strong>Module &#x3D;&gt;</strong> 模块化Vuex，允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li>\n</ul>\n<h3 id=\"为什么-Vuex-的-mutation-中不能做异步操作？\"><a href=\"#为什么-Vuex-的-mutation-中不能做异步操作？\" class=\"headerlink\" title=\"为什么 Vuex 的 mutation 中不能做异步操作？\"></a>为什么 Vuex 的 mutation 中不能做异步操作？</h3><p>Vuex 中所有的状态更新的唯一途径都是 mutation，异步操作通过<br>Action 来提交 mutation 实现，这样可以方便地跟踪每一个状态的<br>变化，从而能够实现一些工具帮助更好地了解我们的应用。<br>每个 mutation 执行完成后都会对应到一个新的状态变更，这样<br>devtools 就可以打个快照存下来，然后就可以实现 time-travel 了。<br>如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，<br>无法很好的进行状态的追踪，给调试带来困难。</p>\n<h2 id=\"2、生命周期\"><a href=\"#2、生命周期\" class=\"headerlink\" title=\"2、生命周期\"></a>2、生命周期</h2><p>beforeCreate\t组件实例被创建之初，组件的属性生效之前<br>created\t组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用<br>beforeMount\t在挂载开始之前被调用：相关的 render 函数首次被调用<br>mounted\tel 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子<br>beforeUpdate\t组件数据更新之前调用，发生在虚拟 DOM 打补丁之前<br>updated\t组件数据更新之后<br>activited\tkeep-alive 专属，组件被激活时调用<br>deadctivated\tkeep-alive 专属，组件被销毁时调用<br>beforeDestory\t组件销毁前调用<br>destoryed\t组件销毁后调用</p>\n<p><strong>beforeCreate</strong> 在实例初始化之后，数据观测（data observe）和 event&#x2F;watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。</p>\n<p><strong>created</strong> 实例已经创建完成之后被调用。在这一步，实例已经完成以下的配置：数据观测（data observe ），属性和方法的运算，watch&#x2F;event 事件回调。这里没有 $el，如果非要想与 DOM 进行交互，可以通过vm.$nextTick 来访问 DOM。</p>\n<p><strong>beforeMount</strong> 在挂载开始之前被调用：相关的 render 函数首次被调用。</p>\n<p><strong>mounted</strong> 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom节点。</p>\n<p><strong>beforeUpdate</strong> 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁 （patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。（数据修改页面未修改）</p>\n<p><strong>updated</strong> 发生在更新完成之后，当前阶段组件 Dom 已经完成更新。要注意的是避免在此期间更新数据，因为这个可能导致无限循环的更新，该钩子在服务器渲染期间不被调用。</p>\n<p><strong>beforeDestroy</strong> 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行 善后收尾工作，比如清除定时器。</p>\n<p><strong>destroyed</strong>  Vue实例销毁后调用。调用后，Vue实例指示的东西都会解绑定，所有的事件监听器会被移除，左右的子实例也会被销毁，该钩子在服务器端渲染不被调用。</p>\n<p><strong>activated keep-alive</strong> 专属，组件被激活时调用</p>\n<h2 id=\"3、Vue-组件间通信有哪几种方式？\"><a href=\"#3、Vue-组件间通信有哪几种方式？\" class=\"headerlink\" title=\"3、Vue 组件间通信有哪几种方式？\"></a>3、Vue 组件间通信有哪几种方式？</h2><p>Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。<br>（1）props &#x2F; $emit 适用 父子组件通信</p>\n<p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。<br>（2）ref 与 $parent &#x2F; $children适用 父子组件通信</p>\n<p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例<br>$parent &#x2F; $children：访问父 &#x2F; 子实例<br>（3）EventBus （$emit &#x2F; $on）适用于 父子、隔代、兄弟组件通信</p>\n<p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。<br>（4）$attrs&#x2F;$listeners适用于 隔代组件通信</p>\n<p>$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind&#x3D;”$attrs” 传入内部组件。通常配合 inheritAttrs 选项一起使用。<br>$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on&#x3D;”$listeners” 传入内部组件<br>（5）provide &#x2F; inject适用于 隔代组件通信</p>\n<p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide &#x2F; inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。<br>（6）Vuex适用于 父子、隔代、兄弟组件通信</p>\n<h3 id=\"Vue组件通讯有哪些方式？\"><a href=\"#Vue组件通讯有哪些方式？\" class=\"headerlink\" title=\"Vue组件通讯有哪些方式？\"></a>Vue组件通讯有哪些方式？</h3><p>1、props 和 $emit。父组件向子组件传递数据是通过props传递的，子组件传递给父组件是通过$emit触发事件来做到的。</p>\n<p>2、$parent 和 $children 获取单签组件的父组件和当前组件的子组件。</p>\n<p>3、$attrs 和 $listeners A -&gt; B -&gt; C。Vue2.4开始提供了$attrs和$listeners来解决这个问题。</p>\n<p>4、父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。（官方不推荐在实际业务中适用，但是写组件库时很常用。）</p>\n<p>5、$refs 获取组件实例。</p>\n<p>6、envetBus 兄弟组件数据传递，这种情况下可以使用事件总线的方式。</p>\n<p>7、vuex 状态管理</p>\n<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。<br>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p>\n<h2 id=\"4、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？\"><a href=\"#4、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？\" class=\"headerlink\" title=\"4、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？\"></a>4、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h2><h3 id=\"（1）hash-模式的实现原理\"><a href=\"#（1）hash-模式的实现原理\" class=\"headerlink\" title=\"（1）hash 模式的实现原理\"></a>（1）hash 模式的实现原理</h3><p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：<br><a href=\"https://www.word.com/#search\">https://www.word.com#search</a><br>hash 路由模式的实现主要是基于下面几个特性：</p>\n<p>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；<br>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；<br>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；<br>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</p>\n<h3 id=\"（2）history-模式的实现原理\"><a href=\"#（2）history-模式的实现原理\" class=\"headerlink\" title=\"（2）history 模式的实现原理\"></a>（2）history 模式的实现原理</h3><p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。<br>唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：<br>window.history.pushState(null, null, path);<br>window.history.replaceState(null, null, path);<br>history 路由模式的实现主要基于存在下面几个特性：</p>\n<p>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；<br>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；<br>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</p>\n<h2 id=\"5、computed-和-watch-区分使用场景\"><a href=\"#5、computed-和-watch-区分使用场景\" class=\"headerlink\" title=\"5、computed 和 watch 区分使用场景\"></a>5、computed 和 watch 区分使用场景</h2><h3 id=\"computed：\"><a href=\"#computed：\" class=\"headerlink\" title=\"computed：\"></a>computed：</h3><p>是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>\n<h3 id=\"watch：\"><a href=\"#watch：\" class=\"headerlink\" title=\"watch：\"></a>watch：</h3><p>更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>\n<h3 id=\"运用场景：\"><a href=\"#运用场景：\" class=\"headerlink\" title=\"运用场景：\"></a>运用场景：</h3><p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；<br>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>\n<p>computed： 是<strong>计算属性</strong>，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；<br>watch： 更多的是「<strong>观察</strong>」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；<br>运用场景：<br>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；<br>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>\n<h2 id=\"6、v-if-和-v-show-有什么区别？\"><a href=\"#6、v-if-和-v-show-有什么区别？\" class=\"headerlink\" title=\"6、v-if 和 v-show 有什么区别？\"></a>6、v-if 和 v-show 有什么区别？</h2><p>v-if 是真正的条件渲染，会控制这个 DOM 节点的存在与否。因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：<strong>如果在初始渲染时条件为假</strong>，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br><strong>v-show 就简单得多——不管初始条件是什么，元素总是会被渲染</strong>，并且只是简单地基于 CSS 的 “display” 属性进行切换。<br>当我们需要经常切换某个元素的显示&#x2F;隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p>\n<h2 id=\"7、怎样理解-Vue-的单向数据流？\"><a href=\"#7、怎样理解-Vue-的单向数据流？\" class=\"headerlink\" title=\"7、怎样理解 Vue 的单向数据流？\"></a>7、怎样理解 Vue 的单向数据流？</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。<br>这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。<br>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。<br>这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。<br>子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p>\n<h2 id=\"8、v-model-的原理？\"><a href=\"#8、v-model-的原理？\" class=\"headerlink\" title=\"8、v-model 的原理？\"></a>8、v-model 的原理？</h2><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>\n<ul>\n<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>\n<li>checkbox 和 radio 使用 checked 属性和 change 事件</li>\n<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>\n</ul>\n<h2 id=\"9、vue-router历史模式和hash模式的区别？\"><a href=\"#9、vue-router历史模式和hash模式的区别？\" class=\"headerlink\" title=\"9、vue-router历史模式和hash模式的区别？\"></a>9、vue-router历史模式和hash模式的区别？</h2><p><strong>hash模式</strong>：<br>url里面带有#号，开发中默认的就是hash模式，hash虽然出现在URL中，但是不会被包括在HTTP请求中，所以改变hash不会重新刷新页面</p>\n<p>路由的哈希模式就是利用了window.onhashchange事件，也就是url中的hash值（#号后面的值）如果有变化，就会自动调用hashchange的监听事件，在hashchange的监听事件内可以得到改变后的url，这样就能找到对应页面进行加载</p>\n<p><strong>历史模式</strong>：<br>利用了H5新增的pushState()、replaceState()方法。当这两个方法执行时，只能改变当前地址栏的URL，但是浏览器不会像后端发起请求，也不会触发popstate事件的执行。</p>\n<h2 id=\"10、created和mounted的区别\"><a href=\"#10、created和mounted的区别\" class=\"headerlink\" title=\"10、created和mounted的区别\"></a>10、created和mounted的区别</h2><p><strong>created</strong>：<strong>在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成识图。</strong><br><strong>mounted</strong>：<strong>在模板渲染成html后调用，通常初始化页面完成后，再对html的dom节点进行一些需要的操作</strong>。</p>\n<h2 id=\"11、v-model-是如何实现的实现原理\"><a href=\"#11、v-model-是如何实现的实现原理\" class=\"headerlink\" title=\"11、v-[model]是如何实现的实现原理\"></a>11、v-[model]是如何实现的实现原理</h2><h3 id=\"1-作用在普通表单元素上\"><a href=\"#1-作用在普通表单元素上\" class=\"headerlink\" title=\"1. 作用在普通表单元素上\"></a>1. 作用在普通表单元素上</h3><ul>\n<li>动态绑定了 <code>input</code> 的 <code>value</code> 指向了 <code>message</code> 变量，并且在触发 <code>input</code> 事件的时候去动态把 <code>message</code> 设置为目标值</li>\n<li><h3 id=\"作用在组件上\"><a href=\"#作用在组件上\" class=\"headerlink\" title=\"作用在组件上\"></a>作用在组件上</h3><ul>\n<li>在自定义组件中，<code>v-model</code> 默认会利用名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件</li>\n<li>本质是一个父子组件通信的语法糖，通过 prop 和 $emit 实现</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"12、vue列表为什么加key\"><a href=\"#12、vue列表为什么加key\" class=\"headerlink\" title=\"12、vue列表为什么加key\"></a>12、vue列表为什么加key</h2><ul>\n<li>1、性能优化</li>\n<li>2、diff算法节点比对</li>\n<li>3、key不能是index</li>\n</ul>\n<h2 id=\"13路由的-hash-和-history-模式的区别\"><a href=\"#13路由的-hash-和-history-模式的区别\" class=\"headerlink\" title=\"13路由的 hash 和 history 模式的区别\"></a>13路由的 hash 和 history 模式的区别</h2><p>Vue-Router 有两种模式：hash 模式和 history 模式。默认的路由模<br>式是 hash 模式。</p>\n<p>hash 模式是开发中默认的模式，它的 URL 带着一个#，例如：<br><a href=\"http://www.abc.com/#/vue%EF%BC%8C%E5%AE%83%E7%9A%84\">http://www.abc.com/#/vue，它的</a> hash 值就是#&#x2F;vue。<br>特点：hash 值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对<br>后端完全没有影响。所以改变 hash 值，不会重新加载页面。这种模<br>式的浏览器支持度很好，低版本的 IE 浏览器也支持这种模式。hash<br>路由被称为是前端路由，已经成为 SPA（单页面应用）的标配。</p>\n<p>原理： hash 模式的主要原理就是 onhashchange()事件：</p>\n<p><img src=\"/images/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/1709212160938.png\" alt=\"1709212160938\"></p>\n<ol start=\"2\">\n<li>history 模式<br>简介： history 模式的 URL 中没有#，它使用的是传统的路由分发模<br>式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个<br>URL，然后做出相应的逻辑处理。<br>特 点 ： 当 使 用 history 模 式 时 ， URL 就 像 这 样 ：<br><a href=\"http://abc.com/user/id%E3%80%82%E7%9B%B8%E6%AF%94\">http://abc.com/user/id。相比</a> hash 模式更加好看。但是，history<br>模式需要后台配置支持。如果后台没有正确配置，访问时会返回 404。<br>API： history api 可以分为两大部分，切换历史状态和修改历史状<br>态：<br>修 改 历 史 状 态 ： 包 括 了 HTML5 History Interface 中 新 增 的<br>pushState() 和 replaceState() 方法，这两个方法应用于浏览器的<br>历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修<br>改时，虽然修改了 url，但浏览器不会立即向后端发送请求。如果要<br>做到改变 url 但又不刷新页面的效果，就需要前端用上这两个 API。<br>切换历史状态： 包括 forward()、back()、go()三个方法，对应浏<br>览器的前进，后退，跳转操作。<br>虽然 history 模式丢弃了丑陋的#。但是，它也有自己的缺点，就是<br>在刷新页面的时候，如果没有相应的路由或资源，就会刷出 404 来。<br>如果想要切换到 history 模式，就要进行以下配置（后端也要进行配<br>置）：</li>\n<li>两种模式对比<br>调用 history.pushState() 相比于直接修改 hash，存在以下优势:<br>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而<br>hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的<br>URL；<br>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把<br>记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动<br>作将记录添加到栈中；<br>pushState() 通过 stateObject 参数可以添加任意类型的数据到记<br>录中；而 hash 只可添加短字符串；<br>pushState() 可额外设置 title 属性供后续使用。<br>hash 模式下，仅 hash 符号之前的 url 会被包含在请求中，后端如果<br>没有做到对路由的全覆盖，也不会返回 404 错误；history 模式下，<br>前端的 url 必须和实际向后端发起请求的 url 一致，如果没有对用的<br>路由处理，将返回 404 错误。<br>hash 模式和 history 模式都有各自的优势和缺陷，还是要根据实际<br>情况选择性的使用。</li>\n</ol>\n<h1 id=\"5、状态码\"><a href=\"#5、状态码\" class=\"headerlink\" title=\"5、状态码\"></a>5、状态码</h1><p>常用的请求状态码</p>\n<h3 id=\"500-内部服务器错误\"><a href=\"#500-内部服务器错误\" class=\"headerlink\" title=\"500 内部服务器错误\"></a>500 内部服务器错误</h3><p>Internal Server Error 500内部服务器错误，服务器遇到未知无法解决的问题。</p>\n<p>一般情况下，出现500响应状态的原因有很多种，但是主要的是“程序代码和服务器配置”两个问题。相对于代码而言，就是对站点进行升级，网页改版，新增加了一些常用的插件。就比如WordPress插件的版本可能就需要更高版本的PHP才能兼容。</p>\n<p>而相对服务器而言的话，更多的是在系统版本升级导致，就比如最开始使用的是Windows Server 2003，后期想要升级2008、2012等版本的时候配置稍有不慎就会导致Internal Server Error 500。</p>\n<h3 id=\"404-请求错误\"><a href=\"#404-请求错误\" class=\"headerlink\" title=\"404 请求错误\"></a>404 请求错误</h3><p>Not Found 404 错误请求，因发送的请求语法错误,服务器无法正常读取。</p>\n<p>相信绝大多数的人都见过404的状态码，当用户试图请求Web服务器上一个不存在的资源时，就会触发Not Found404。出现404状态码可能是链接失效导致，也有可能是URL拼写错误，还有可能是因为Web服务器将所请求的资源移到了其他的地方。一般的网站都会设置自定义页面以防链接失效所产生不良的影响。</p>\n<p>403 禁止访问<br>Forbidden 403 禁止访问，客户端没有权利访问所请求内容,服务器拒绝本次请求。</p>\n<h3 id=\"状态码403通常代表客户端错误\"><a href=\"#状态码403通常代表客户端错误\" class=\"headerlink\" title=\"状态码403通常代表客户端错误\"></a>状态码403通常代表客户端错误</h3><p>是指的服务器端有能力处理该请求，但是拒绝授权访问。这个状态码类似于401，但是进入该状态后不能再继续进行验证，该访问是长期禁止的，并且与应用逻辑密切相关，比如密码不正确等。</p>\n<h3 id=\"400-错误请求\"><a href=\"#400-错误请求\" class=\"headerlink\" title=\"400 错误请求\"></a>400 错误请求</h3><p>Bad Request 400 错误请求，因发送的请求语法错误,服务器无法正常读取。</p>\n<p>状态码400表示该语法无效，服务器无法理解该请求。客服端不应该在未经修改的情况下重复此请求。一般会因为前端提交数据的字段名称，或者是字段类型和后台的实体类不一致，导致无法封装。</p>\n<h3 id=\"401-未经授权\"><a href=\"#401-未经授权\" class=\"headerlink\" title=\"401 未经授权\"></a>401 未经授权</h3><p>Unauthorized 401 未经授权，需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过。</p>\n<p>状态码401就是Web服务器认为，客户端发送的HTTP数据流浪是正确的，但是进入URL资源的时候需要身份验证，而客户端尚未提供相关的验证信息，或者是已提供但是没有通过验证。这也是通常所知的“HTTP基本验证”。</p>\n<h3 id=\"200-请求成功\"><a href=\"#200-请求成功\" class=\"headerlink\" title=\"200 请求成功\"></a>200 请求成功</h3><p>200 OK 请求成功，表示已经请求成功，默认情况下的状态码为200的响应就可以被缓存了。</p>\n<p>不同请求方式对于请求成功的意义如下：</p>\n<p>GET: 已经取得资源，并将资源添加到响应的消息体中。<br>HEAD: 响应的消息体为头部信息。<br>POST: 响应的消息体中包含此次请求的结果。<br>TRACE: 响应的消息体中包含服务器接收到的请求信息。</p>\n<p>PUT 和 DELETE 的请求成功通常并不是响应200OK的状态码而是 204No Content 表示无内容(或者 201Created表示一个资源首次被创建成功)。</p>\n<h3 id=\"206-部分内容\"><a href=\"#206-部分内容\" class=\"headerlink\" title=\"206 部分内容\"></a>206 部分内容</h3><p>Partial Content 206 部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码。</p>\n<p>状态码206表示服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p>\n<h3 id=\"301-永久重定向\"><a href=\"#301-永久重定向\" class=\"headerlink\" title=\"301 永久重定向\"></a>301 永久重定向</h3><p>Moved Permanently 301 永久移动，该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的Location:头字段里找到。</p>\n<p>尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用301，其他情况使用308 来替代301。</p>\n<h3 id=\"302-临时重定向\"><a href=\"#302-临时重定向\" class=\"headerlink\" title=\"302 临时重定向\"></a>302 临时重定向</h3><p>Found 302临时移动，该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的Location:头字段里找到。</p>\n<p>即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代，因为在这些场景下方法变换是明确禁止的。</p>\n<h3 id=\"502-无效网关\"><a href=\"#502-无效网关\" class=\"headerlink\" title=\"502 无效网关\"></a>502 无效网关</h3><p>Bad Gateway 502 网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应。</p>\n<h3 id=\"404-请求错误-1\"><a href=\"#404-请求错误-1\" class=\"headerlink\" title=\"404 请求错误\"></a>404 请求错误</h3><p>Not Found 404 错误请求，因发送的请求语法错误,服务器无法正常读取。</p>\n<p>相信绝大多数的人都见过404的状态码，当用户试图请求Web服务器上一个不存在的资源时，就会触发Not Found404。出现404状态码可能是链接失效导致，也有可能是URL拼写错误，还有可能是因为Web服务器将所请求的资源移到了其他的地方。一般的网站都会设置自定义页面以防链接失效所产生不良的影响。</p>\n<h3 id=\"403-禁止访问\"><a href=\"#403-禁止访问\" class=\"headerlink\" title=\"403 禁止访问\"></a>403 禁止访问</h3><p>Forbidden 403 禁止访问，客户端没有权利访问所请求内容,服务器拒绝本次请求。</p>\n<p>状态码403通常代表客户端错误，是指的服务器端有能力处理该请求，但是拒绝授权访问。这个状态码类似于401，但是进入该状态后不能再继续进行验证，该访问是长期禁止的，并且与应用逻辑密切相关，比如密码不正确等。</p>\n<h3 id=\"400-错误请求-1\"><a href=\"#400-错误请求-1\" class=\"headerlink\" title=\"400 错误请求\"></a>400 错误请求</h3><p>Bad Request 400 错误请求，因发送的请求语法错误,服务器无法正常读取。</p>\n<p>状态码400表示该语法无效，服务器无法理解该请求。客服端不应该在未经修改的情况下重复此请求。一般会因为前端提交数据的字段名称，或者是字段类型和后台的实体类不一致，导致无法封装。</p>\n<h3 id=\"401-未经授权-1\"><a href=\"#401-未经授权-1\" class=\"headerlink\" title=\"401 未经授权\"></a>401 未经授权</h3><p>Unauthorized 401 未经授权，需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过。</p>\n<p>状态码401就是Web服务器认为，客户端发送的HTTP数据流浪是正确的，但是进入URL资源的时候需要身份验证，而客户端尚未提供相关的验证信息，或者是已提供但是没有通过验证。这也是通常所知的“HTTP基本验证”。</p>\n<h3 id=\"200-请求成功-1\"><a href=\"#200-请求成功-1\" class=\"headerlink\" title=\"200 请求成功\"></a>200 请求成功</h3><p>200 OK 请求成功，表示已经请求成功，默认情况下的状态码为200的响应就可以被缓存了。</p>\n<p>不同请求方式对于请求成功的意义如下：</p>\n<p>GET: 已经取得资源，并将资源添加到响应的消息体中。<br>HEAD: 响应的消息体为头部信息。<br>POST: 响应的消息体中包含此次请求的结果。<br>TRACE: 响应的消息体中包含服务器接收到的请求信息。</p>\n<p>PUT 和 DELETE 的请求成功通常并不是响应200OK的状态码而是 204No Content 表示无内容(或者 201Created表示一个资源首次被创建成功)。</p>\n<h3 id=\"206-部分内容-1\"><a href=\"#206-部分内容-1\" class=\"headerlink\" title=\"206 部分内容\"></a>206 部分内容</h3><p>Partial Content 206 部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码。</p>\n<p>状态码206表示服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p>\n<h3 id=\"301-永久重定向-1\"><a href=\"#301-永久重定向-1\" class=\"headerlink\" title=\"301 永久重定向\"></a>301 永久重定向</h3><p>Moved Permanently 301 永久移动，该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的Location:头字段里找到。</p>\n<p>尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用301，其他情况使用308 来替代301。</p>\n<h3 id=\"302-临时重定向-1\"><a href=\"#302-临时重定向-1\" class=\"headerlink\" title=\"302 临时重定向\"></a>302 临时重定向</h3><p>Found 302临时移动，该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的Location:头字段里找到。</p>\n<p>即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代，因为在这些场景下方法变换是明确禁止的。</p>\n<h3 id=\"502-无效网关-1\"><a href=\"#502-无效网关-1\" class=\"headerlink\" title=\"502 无效网关\"></a>502 无效网关</h3><p>Bad Gateway 502 网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应。</p>\n<p>bad gateway502代表您所访问的网站出了问题，因为502 Bad Gateway 服务器作为网关或者代理时，是为了完成访问下一个服务器，但该服务器返回了非法的应答。也许是暂时的，也许是永久的。建议大家稍等一下再从新访问试试。</p>\n"},{"abbrlink":"","abstracts":" 数据结构是一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合。","author":{"avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg","description":"古来圣贤皆寂寞，惟有饮者留其名。","link":"https://hexo-git-test-3309446352s-projects.vercel.app/","name":"好名字都是狗起的","socials":{"github":"https://github.com/3309446352"}},"cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/w.jpg","date":"2024-03-23T08:35:52.619Z","description":"计算机中存储、组织数据的方式。  数据结构是一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合。它包含三方面的内容，逻辑关系、存储关系及操作。","excerpt":"   description       ...","title":"数据结构与算法","updated":"2024-03-24T17:07:26.543Z","_content":"1. {{ description}}\n","source":"_posts/数据结构与算法.md","raw":"---\nabbrlink: ''\nabstracts:  数据结构是一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合。\nauthor:\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\n  description: 古来圣贤皆寂寞，惟有饮者留其名。\n  link: https://hexo-git-test-3309446352s-projects.vercel.app/\n  name: 好名字都是狗起的\n  socials:\n    github: https://github.com/3309446352\ncategories: []\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/w.jpg\ndate: '2024-03-23T16:35:52.619878+08:00'\ndescription: 计算机中存储、组织数据的方式。  数据结构是一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合。它包含三方面的内容，逻辑关系、存储关系及操作。\nexcerpt:    description       ...\ntags: []\ntitle: 数据结构与算法\nupdated: '2024-03-25T01:07:26.543+08:00'\n---\n1. {{ description}}\n","slug":"数据结构与算法","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgyo002wiou28j257fh8","content":"<ol>\n<li>计算机中存储、组织数据的方式。  数据结构是一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合。它包含三方面的内容，逻辑关系、存储关系及操作。</li>\n</ol>\n","site":{"data":{}},"more":"<ol>\n<li>计算机中存储、组织数据的方式。  数据结构是一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合。它包含三方面的内容，逻辑关系、存储关系及操作。</li>\n</ol>\n"},{"title":"设计模式","author":{"name":"好名字都是狗起的","link":"https://hexo-git-test-3309446352s-projects.vercel.app/","avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg","description":"古来圣贤皆寂寞，惟有饮者留其名。","socials":{"github":"https://github.com/3309446352"}},"date":"2024-03-22T12:30:05.000Z","cover":"https://raw.githubusercontent.com/3309446352/Images/main/img/5f729cb0aa121b0c2ac6a0a0.webp","description":null,"abstracts":"设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。","_content":"# 设计模式","source":"_posts/设计模式.md","raw":"---\ntitle: 设计模式\nauthor:\n  name: 好名字都是狗起的\n  link: https://hexo-git-test-3309446352s-projects.vercel.app/\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\n  description: 古来圣贤皆寂寞，惟有饮者留其名。\n  socials:\n    github: https://github.com/3309446352\ndate: 2024-03-22 20:30:05\ntags:\n  - 设计模式\ncategories:\ncover: https://raw.githubusercontent.com/3309446352/Images/main/img/5f729cb0aa121b0c2ac6a0a0.webp\ndescription: \nabstracts: 设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。\n---\n# 设计模式","slug":"设计模式","published":1,"updated":"2024-03-22T13:26:10.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clu74rgyp002yiou2dfic1xxq","content":"<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1>"},{"title":"Python爬虫","author":{"name":"好名字都是狗起的","link":"https://hexo-git-test-3309446352s-projects.vercel.app/","avatar":"https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg","description":"古来圣贤皆寂寞，惟有饮者留其名。","socials":{"github":"https://github.com/3309446352"}},"date":"2024-03-25T16:11:09.000Z","cover":null,"description":"爬虫是一种自动获取网页信息的程序，爬虫程序模拟人的浏览行为，自动访问互联网上的网页，获取网页内容。爬虫程序可以自动获取网页内容，提取感兴趣的信息，存储到本地或者数据库中。","abstracts":"爬虫是一种自动获取网页信息的程序，爬虫程序模拟人的浏览行为，自动访问互联网上的网页，获取网页内容。爬虫程序可以自动获取网页内容，提取感兴趣的信息，存储到本地或者数据库中。","_content":"# {{ title }}\n\n## 简介 :\n- {{ description}}\n\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n\t<form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\"></form>\n</div>","source":"_posts/python爬虫.md","raw":"---\ntitle: python爬虫\nauthor:\n  name: 好名字都是狗起的\n  link: https://hexo-git-test-3309446352s-projects.vercel.app/\n  avatar: https://raw.githubusercontent.com/3309446352/Images/main/img/preview.jpg\n  description: 古来圣贤皆寂寞，惟有饮者留其名。\n  socials:\n    github: https://github.com/3309446352\ndate: 2024-03-26 00:11:09\ntags: \n  - 爬虫\ncategories:\n    - 爬虫\ncover:\ndescription: 爬虫是一种自动获取网页信息的程序，爬虫程序模拟人的浏览行为，自动访问互联网上的网页，获取网页内容。爬虫程序可以自动获取网页内容，提取感兴趣的信息，存储到本地或者数据库中。 \nabstracts: 爬虫是一种自动获取网页信息的程序，爬虫程序模拟人的浏览行为，自动访问互联网上的网页，获取网页内容。爬虫程序可以自动获取网页内容，提取感兴趣的信息，存储到本地或者数据库中。\n---\n# {{ title }}\n\n## 简介 :\n- {{ description}}\n\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n\t<form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\"></form>\n</div>","slug":"python爬虫","published":1,"updated":"2024-03-25T16:12:48.824Z","_id":"clu75ajlm0000p0u22ptfdf6u","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>Python爬虫</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介 :\"></a>简介 :</h2><ul>\n<li>爬虫是一种自动获取网页信息的程序，爬虫程序模拟人的浏览行为，自动访问互联网上的网页，获取网页内容。爬虫程序可以自动获取网页内容，提取感兴趣的信息，存储到本地或者数据库中。</li>\n</ul>\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n    <form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\"></form>\n</div>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>Python爬虫</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介 :\"></a>简介 :</h2><ul>\n<li>爬虫是一种自动获取网页信息的程序，爬虫程序模拟人的浏览行为，自动访问互联网上的网页，获取网页内容。爬虫程序可以自动获取网页内容，提取感兴趣的信息，存储到本地或者数据库中。</li>\n</ul>\n<div class=\"box\" style=\"  position: relative;width: 100%;height: 350px;background: #1c1c1c;border-radius: 8px;overflow: hidden;\">\n    <form autocomplete=\"off\" style=\" box-shadow: 0 0 20px 19px aqua; position: absolute;inset: 2px;background: #28292d;padding: 50px 40px;border-radius: 8px;z-index: 2;display: flex;flex-direction: column;\"></form>\n</div>"}],"PostAsset":[{"_id":"source/_posts/hexo-文档详解/60b9ed3cae5a9ba4024b411c.png","slug":"60b9ed3cae5a9ba4024b411c.png","post":"clu74rgxr000ziou2at2309ia","modified":0,"renderable":0}],"PostCategory":[{"post_id":"clu74rgx90003iou2ejaxh8cc","category_id":"clu74rgxc0006iou26k6eho53","_id":"clu74rgxl000iiou2d06u8p6m"},{"post_id":"clu74rgxb0005iou22wgr0bvr","category_id":"clu74rgxi000diou2a8vg9ob9","_id":"clu74rgxn000oiou2caoo2xuc"},{"post_id":"clu74rgxj000giou2gbv25k8p","category_id":"clu74rgxl000kiou2aqj93ade","_id":"clu74rgxq000wiou29dsmc0tn"},{"post_id":"clu74rgxk000hiou27rtu9b89","category_id":"clu74rgxo000riou204kqbdei","_id":"clu74rgxt0013iou24phvh0ln"},{"post_id":"clu74rgxm000niou22wogc1ec","category_id":"clu74rgxo000riou204kqbdei","_id":"clu74rgxv0018iou28qu15r1j"},{"post_id":"clu74rgxn000qiou2goq8bymc","category_id":"clu74rgxo000riou204kqbdei","_id":"clu74rgxy001eiou21vk9bg9u"},{"post_id":"clu74rgxw001aiou2d2bba4qh","category_id":"clu74rgxi000diou2a8vg9ob9","_id":"clu74rgy1001kiou2hebq4kbm"},{"post_id":"clu74rgxp000viou26dpicvp2","category_id":"clu74rgxv0017iou27y0j61k1","_id":"clu74rgy2001niou2737uc03p"},{"post_id":"clu74rgxs0010iou25dum5ji8","category_id":"clu74rgxy001fiou20prm6llq","_id":"clu74rgy7001riou218c088ax"},{"post_id":"clu74rgy7001tiou243w7egnw","category_id":"clu74rgxo000riou204kqbdei","_id":"clu74rgyf001ziou2h4zbh5j6"},{"post_id":"clu74rgy0001jiou20xmy4j7k","category_id":"clu74rgy3001piou28714eh2p","_id":"clu74rgyf0021iou29mwc5pi1"},{"post_id":"clu74rgy6001qiou2ehp3d5uv","category_id":"clu74rgye001wiou25bgz29ze","_id":"clu74rgyg0023iou218t612gw"},{"post_id":"clu74rgy8001viou20ayub59i","category_id":"clu74rgyf0020iou2dhqqgrrk","_id":"clu74rgyg0026iou24r104vfk"},{"post_id":"clu74rgyo002viou2ffuw33g0","category_id":"clu74rgy3001piou28714eh2p","_id":"clu74rgyq002ziou2hbsi0kqj"},{"post_id":"clu75ajlm0000p0u22ptfdf6u","category_id":"clu74rgxy001fiou20prm6llq","_id":"clu75coiq0004p0u24rbx5vlu"}],"PostTag":[{"post_id":"clu74rgx90003iou2ejaxh8cc","tag_id":"clu74rgxe0007iou2ea6e24q8","_id":"clu74rgxi000fiou2hcxxcao9"},{"post_id":"clu74rgxb0005iou22wgr0bvr","tag_id":"clu74rgxi000eiou2e2st443y","_id":"clu74rgxm000miou2ftxv16qm"},{"post_id":"clu74rgxh000ciou20smscqnk","tag_id":"clu74rgxl000jiou2h3bdek9q","_id":"clu74rgxo000siou2chyrffsf"},{"post_id":"clu74rgxj000giou2gbv25k8p","tag_id":"clu74rgxn000piou2az9l5b8r","_id":"clu74rgxr000yiou2dfhe00ng"},{"post_id":"clu74rgxr000ziou2at2309ia","tag_id":"clu74rgxl000jiou2h3bdek9q","_id":"clu74rgxt0014iou275dhesb7"},{"post_id":"clu74rgxk000hiou27rtu9b89","tag_id":"clu74rgxp000uiou22is2hiev","_id":"clu74rgxw001biou21o4i8ghv"},{"post_id":"clu74rgxk000hiou27rtu9b89","tag_id":"clu74rgxs0011iou2c9o620xu","_id":"clu74rgxy001diou2563shnrr"},{"post_id":"clu74rgxl000liou2c1jb2rzh","tag_id":"clu74rgxv0019iou28si53r4d","_id":"clu74rgy0001iiou23b5l5q91"},{"post_id":"clu74rgxm000niou22wogc1ec","tag_id":"clu74rgxz001giou218nh22wh","_id":"clu74rgy3001oiou28r6ug8xz"},{"post_id":"clu74rgxn000qiou2goq8bymc","tag_id":"clu74rgxp000uiou22is2hiev","_id":"clu74rgy8001uiou28n8d58a8"},{"post_id":"clu74rgxo000tiou28hyaaxqr","tag_id":"clu74rgy7001siou2107wbb3f","_id":"clu74rgyf001yiou29lr24v82"},{"post_id":"clu74rgxp000viou26dpicvp2","tag_id":"clu74rgye001xiou2gobt47cy","_id":"clu74rgyg0025iou29ll32mpt"},{"post_id":"clu74rgxp000viou26dpicvp2","tag_id":"clu74rgyf0022iou2c6vy3kxy","_id":"clu74rgyg0027iou24pdsa8s9"},{"post_id":"clu74rgxs0010iou25dum5ji8","tag_id":"clu74rgyg0024iou2hs3fa7vm","_id":"clu74rgyg0029iou20jh086nk"},{"post_id":"clu74rgxt0015iou26c1mhuhc","tag_id":"clu74rgyg0028iou28s2hgjwe","_id":"clu74rgyg002biou2e47s3iue"},{"post_id":"clu74rgxu0016iou2928rcvv6","tag_id":"clu74rgyg002aiou2gdlu42du","_id":"clu74rgyh002diou2aykshd00"},{"post_id":"clu74rgxw001aiou2d2bba4qh","tag_id":"clu74rgyh002ciou2h58o1c0q","_id":"clu74rgyh002fiou28vdf5i0u"},{"post_id":"clu74rgxx001ciou21mzneqw0","tag_id":"clu74rgyh002eiou248xcc9pf","_id":"clu74rgyh002hiou26jzv7tzz"},{"post_id":"clu74rgxz001hiou23x8z37kz","tag_id":"clu74rgyh002giou2eanj87se","_id":"clu74rgyi002jiou2bdve0mxi"},{"post_id":"clu74rgy0001jiou20xmy4j7k","tag_id":"clu74rgyh002iiou276iy2sav","_id":"clu74rgyi002liou2alyd14kl"},{"post_id":"clu74rgy6001qiou2ehp3d5uv","tag_id":"clu74rgyi002kiou2cjl1f8n8","_id":"clu74rgyi002oiou20lwk7jzd"},{"post_id":"clu74rgy6001qiou2ehp3d5uv","tag_id":"clu74rgyi002miou2gckzasiz","_id":"clu74rgyj002piou21zhhgsqd"},{"post_id":"clu74rgy7001tiou243w7egnw","tag_id":"clu74rgyi002niou2g5aias24","_id":"clu74rgyj002riou2az1f1o73"},{"post_id":"clu74rgy8001viou20ayub59i","tag_id":"clu74rgyj002qiou2f5i54x6w","_id":"clu74rgyk002tiou2f9xw8rbq"},{"post_id":"clu74rgy8001viou20ayub59i","tag_id":"clu74rgyk002siou20axgdhqd","_id":"clu74rgyk002uiou21co72py9"},{"post_id":"clu74rgyo002viou2ffuw33g0","tag_id":"clu74rgyp002xiou2bni1fpej","_id":"clu74rgys0039iou27uz78k9o"},{"post_id":"clu74rgyo002viou2ffuw33g0","tag_id":"clu74rgyq0030iou298sa6krw","_id":"clu74rgys003aiou20ivph99j"},{"post_id":"clu74rgyo002viou2ffuw33g0","tag_id":"clu74rgyq0031iou22oc20603","_id":"clu74rgys003biou2gad29l20"},{"post_id":"clu74rgyo002viou2ffuw33g0","tag_id":"clu74rgyq0032iou25d3n2tey","_id":"clu74rgys003ciou292qeh1vl"},{"post_id":"clu74rgyo002viou2ffuw33g0","tag_id":"clu74rgyg0028iou28s2hgjwe","_id":"clu74rgys003diou24hfj8cx7"},{"post_id":"clu74rgyo002viou2ffuw33g0","tag_id":"clu74rgy7001siou2107wbb3f","_id":"clu74rgys003eiou28jve7yz5"},{"post_id":"clu74rgyo002viou2ffuw33g0","tag_id":"clu74rgyr0033iou25tkpa7z2","_id":"clu74rgys003fiou27nc4377p"},{"post_id":"clu74rgyo002viou2ffuw33g0","tag_id":"clu74rgyr0034iou2c6l58s6a","_id":"clu74rgyt003giou2b7dvf21o"},{"post_id":"clu74rgyo002viou2ffuw33g0","tag_id":"clu74rgyr0035iou2fhptcs0g","_id":"clu74rgyt003hiou20mxfeyon"},{"post_id":"clu74rgyo002viou2ffuw33g0","tag_id":"clu74rgyr0036iou21mgo13zb","_id":"clu74rgyt003iiou2byrf21x0"},{"post_id":"clu74rgyo002viou2ffuw33g0","tag_id":"clu74rgys0037iou22kyq89gj","_id":"clu74rgyt003jiou2gbbj7x91"},{"post_id":"clu74rgyp002yiou2dfic1xxq","tag_id":"clu74rgys0038iou2d2l156q5","_id":"clu74rgyt003kiou2a0w3ami3"},{"post_id":"clu75ajlm0000p0u22ptfdf6u","tag_id":"clu74rgyg002aiou2gdlu42du","_id":"clu75b5wy0003p0u24s5h5w68"}],"Tag":[{"name":"农民运动","_id":"clu74rgxe0007iou2ea6e24q8"},{"name":"Docker","_id":"clu74rgxi000eiou2e2st443y"},{"name":"博客搭建","_id":"clu74rgxl000jiou2h3bdek9q"},{"name":"-Mysql","_id":"clu74rgxn000piou2az9l5b8r"},{"name":"后端","_id":"clu74rgxp000uiou22is2hiev"},{"name":"RabbitMQ","_id":"clu74rgxs0011iou2c9o620xu"},{"name":"SSM","_id":"clu74rgxv0019iou28si53r4d"},{"name":"-springboot","_id":"clu74rgxz001giou218nh22wh"},{"name":"React","_id":"clu74rgy7001siou2107wbb3f"},{"name":"Blender","_id":"clu74rgye001xiou2gobt47cy"},{"name":"3D建模","_id":"clu74rgyf0022iou2c6vy3kxy"},{"name":"-爬虫","_id":"clu74rgyg0024iou2hs3fa7vm"},{"name":"Vue","_id":"clu74rgyg0028iou28s2hgjwe"},{"name":"爬虫","_id":"clu74rgyg002aiou2gdlu42du"},{"name":"k8s","_id":"clu74rgyh002ciou2h58o1c0q"},{"name":"面试题","_id":"clu74rgyh002eiou248xcc9pf"},{"name":"liunx","_id":"clu74rgyh002giou2eanj87se"},{"name":"pinia","_id":"clu74rgyh002iiou276iy2sav"},{"name":"工具","_id":"clu74rgyi002kiou2cjl1f8n8"},{"name":"插件","_id":"clu74rgyi002miou2gckzasiz"},{"name":"Spingboot","_id":"clu74rgyi002niou2g5aias24"},{"name":"动漫","_id":"clu74rgyj002qiou2f5i54x6w"},{"name":"音乐","_id":"clu74rgyk002siou20axgdhqd"},{"name":"Tag","_id":"clu74rgyp002xiou2bni1fpej"},{"name":"HTML","_id":"clu74rgyq0030iou298sa6krw"},{"name":"CSS","_id":"clu74rgyq0031iou22oc20603"},{"name":"JavaScript","_id":"clu74rgyq0032iou25d3n2tey"},{"name":"Node.js","_id":"clu74rgyr0033iou25tkpa7z2"},{"name":"Webpack","_id":"clu74rgyr0034iou2c6l58s6a"},{"name":"Babel","_id":"clu74rgyr0035iou2fhptcs0g"},{"name":"TypeScript","_id":"clu74rgyr0036iou21mgo13zb"},{"name":"Vuex","_id":"clu74rgys0037iou22kyq89gj"},{"name":"设计模式","_id":"clu74rgys0038iou2d2l156q5"},{"name":"python","_id":"clu75b5wv0001p0u28vkyg303"}]}}